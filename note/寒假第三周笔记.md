# 0 泛型

## 0.1 概念

泛型:是一种未知的数据类型,当我们不知道使用什么数据类型的时候，可以使用泛型。

泛型也可以看成是一个变量,用来接收数据类型。

- E e：Element 元素
- T t ：Type 类型

ArrayList集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型。

E:未知的数据类型。

```java
public class ArraylList<E>{
    public boolean add(E e){}

    public E get(int index) {}
}
```



创建集合对象的时候,就会确定泛型的数据类型，例如：

`ArrayList<String> list = new ArrayList<String>();`

会把数据类型作为参数传递，把String赋值给泛型E。

然后就变成了：

```java
public class ArraylList<String>{
    public boolean add(String e){}
	public String get(int index) {}
｝
```

String类型也可以换成任意的自定义类型，如Student类

```java
ArrayList<Student> list =new ArrayList<Student>();
public class ArraylList<Student>{
    public boolean add(Student e){}
	public Student get(int index) {}
｝
```

------

## 0.2 使用泛型的好处

创建集合对象，不使用泛型。

好处：

集合不使用泛型，默认的类型就是Object类型,可以存储任意类型的数据。

弊端:

不安全，会引发异常。

```java
private static void method() {
    ArrayList<Object> list=new ArrayList<>();
    //即使这里不写Object，留空，也默认为Object
    list.add("abc");
    list.add(1);
    System.out.println(list);
    Iterator<Object> it= list.iterator();
    //即使这里不写Object，留空，也默认为Object
    while (it.hasNext()){
    //取出的元素也是Object类型
        Object obj=it.next();
        System.out.println(obj);
        //想要使用string类特有的方法,length获取字符串的长度，但事实上不能使用，因为需要进行向下转型。
        String str=(String)obj;
        System.out.println(str.length());
        //在输出数字1的长度时会抛出CLassCastException类型转换异常,不能把Integer类型转换为String类型。但前面是正常运行的
    }
}
```

------

创建集合对象，使用泛型

好处:

1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型

2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)

弊端:

泛型是什么类型，只能存储什么类型的数据。

```java
private static void method05() {
        ArrayList<String> list=new ArrayList<>();
        list.add("abc");
        list.add("bhg");
        Iterator<String> it=list.iterator();
        while (it.hasNext()){
            String s=it.next();
            System.out.println(s);
            System.out.println(s.length());
        }
    }
```

------

## 0.3 定义和使用含有泛型的类

定义一个含有泛型的类,模拟ArrayList集合

泛型是一个未知的数据类型,当我们不确定用什么数据类型的时候,可以使用泛型。

泛型可以接收任意的数据类型,可以使用Integer,String,Student.等

创建对象的时候确定泛型的数据类型。

```java
public class Demo03<E> {
    private E name;
    public E getName() {
        return name;
    }
    public E setName(E name) {
        this.name = name;
        return this.name;
    }
}
```

```java
public static void main(String[] args) {
    Demo03<String> obj=new Demo03<>();
    obj.setName("jim");
    String name = obj.getName();
    System.out.println(name);
    Demo03<Integer> obj1=new Demo03<>();
    obj1.setName(1);
    System.out.println(obj1.getName());
}
```

------

## 0.4 定义和使用含有泛型的方法

定义含有泛型的方法:

泛型定义在方法的修饰符和返回值类型之间

格式:

修饰符<泛型>返回值类型 方法名(参数列表(使用泛型)){方法体;}

含有泛型的方法，在调用方法的时候确定泛型的数据类型

传递什么类型的参数，泛型就是什么类型。

```java
public <E> void method01(E e){
    System.out.println(e);
}
public <E> void method01(E e){
    System.out.println(e);
}
```

```java
public class Generic {
    public static void main(String[] args) {
        //创建GenericMethod对象
        GenericMethod g=new GenericMethod();
        //调用含有泛型的方法method01
        //传递什么类型,泛型就是什么类型
        g.method01(1);
        GenericMethod.method("jdh");
        //静态方法的使用不用new一个对象来调用。
    }
}
```

------

## 0.5 定义和使用含有泛型的接口

两种接口都要写上泛型。

### 第一种使用方式:

定义接口的实现类，实现接口,指定接口的泛型。

格式：

```java
public interface Iterator<E> {
	E next();
}
```

Scanner类实现了Iterator接口,并指定接口的泛型为String,所以重写的next方法泛型默认就是String

```java
public final class Scanner implements Iterator<String>{
	public string next() {}
}
```

------

### 第二种使用方式：

接口使用什么泛型,实现类就使用什么泛型，类跟着接口走。

这就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型。

```java
public interface List<E>{
	boolean add(E e);
	E get(int index);
}
//例：
//注意：实现类也要记得写上泛型
public class Arraylist<E> implements List<E>{
    public boolean add(E e) {}
    public E get(int index){}
}
```

------

```java
public interface GenericInterface<E> {//定义含有泛型的接口
    public abstract void method(E e);
}
```

```java
public class GenericInterfaceImplements implements GenericInterface<String>{//第一种定义方式
    @Override
    public void method(String s) {
        System.out.println(s);
    }
}
```

```java
public class Demo02GenericInterface<I> implements GenericInterface<I>{//第二种定义方式
    @Override
    public void method(I e){
        System.out.println(e);
    }
}
```

```java
public class Demo01GenericInterface {
    public static void main(String[] args) {
        GenericInterfaceImplements g=new GenericInterfaceImplements();
        g.method("sdf");//第一种使用方式
        Demo02GenericInterface<String> str=new Demo02GenericInterface<>();
        str.method("jsdf");//第二种使用方式
        Demo02GenericInterface<Integer> str1=new Demo02GenericInterface<>();
        str1.method(1);
    }
}
```

------

## 0.6 泛型通配符

定义一个方法，能遍历所有类型的ArrayList集合。

这时候我们不知道ArrayList集合使用什么数据类型，可以用泛型的通配符**?**来接收数据类型。

注意:

泛型是没有继承概念的。泛型是不能进行自动提升的。

```java
public static void main(String[] args) {
    ArrayList<String> list=new ArrayList<>();
    list.add("sf");
    list.add("sdffsd");
    print(list);
    ArrayList<Integer> list1=new ArrayList<>();
    list1.add(12);
    list1.add(134);
    print(list1);
}
//下面的？号换成Object也不行，因为泛型是没有继承概念的。
private static void print(ArrayList<?> list) {
    Iterator<?> it= list.iterator();
    while (it.hasNext()) System.out.println(it.next());
}
```

------

泛型的上限限定: 

`? extends E`

代表使用的泛型只能是E类型的子类/本身

泛型的下限限定:

`? super E`

代表使用的泛型只能是E类型的父类/本身

类与类之间的继承关系

Integer extends Number extends Object

String extends Object

Number 是一个抽象类，也是一个超类（即父类）。Number 类属于 java.lang 包，所有的包装类（如 Double、Float、Byte、Short、Integer 以及 Long）都是抽象类 Number 的子类。 

```java
public static void main(String[] args) {
    ArrayList<Integer> list1=new ArrayList<>();
    ArrayList<String> list2=new ArrayList<>();
    ArrayList<Number> list3=new ArrayList<>();
    ArrayList<Object> list4=new ArrayList<>();
    getList(list1);
    getList(list2);//报错
    getList(list3);
    getList(list4);//报错

    getList1(list1);//报错
    getList1(list2);//报错
    getList1(list3);
    getList1(list4);

}
// 泛型的上限: 此时的泛型?，必须是Number类型或者Number类型的子类
private static void getList(ArrayList<?extends Number> list4) {
}
// 泛型的下限: 此时的泛型?，必须是Number类型或者Number类型的父类
private static void getList1(ArrayList<?super Number> list4) {
}
```

# 1 数据结构

数据存储的常用结构有:栈、队列、数组、链表和红黑树。

## 1.1 栈

栈:stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。

记忆：先进后出，(即，存进去的元素，要在它后面的元素依次取出后，才能取出该元素)

一个栈相当于一个容器，只有一端有开口，这个容器就相当于一个集合。

栈的入口和出口在同一侧，都在栈顶的位置。

入栈、压栈：存储元素到集合

第一个进栈的元素就放到栈底的位置，然后元素依次进栈，放到前一个进栈的元素的上端。

例如，一号先进栈，然后2号再进栈，最后是3号进栈。在栈中的位置分别是，一号靠近栈底，二号在一号的上方，三号在二号的上方。

出栈、弹栈：取出集合中元素。

若二号元素要出来，则三号元素必须先出来然后二号元素才能出来。

入栈123，出栈321.

------

## 1.2 队列

队列:

queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

记忆：先进先出。即，存进去的元素，要在它**前面**的元素依次取出后，才能取出该元素。

一个队列相当于一个容器，两端端都有开口，这个容器就相当于一个集合。

入口和出口在两侧，存储123，取出123.

例如，一号先进入队列，然后2号再进入队列，最后3号进入队列。

出去的时候也是按顺序出，1号先出，然后再到2号，最后是3号。

若二号元素要出来，则1号元素必须先出来然后二号元素才能出来。

------

## 1.3 数组

数组:Array,是有序的元素序列，数组是在内存中开辟一段**连续的**空间，并在此空间存放元素。

ArrayList也是运用了数组的原理，其特点与数组一样，查询快、增删慢。

就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。

**特点**:

- 查找元素快: 通过索引，可以快速访问指定位置的元素

  - 在内存中，数姐的**数据连续存放**，数据长度**固定**，这样知道数组开头位置和偏移量就可以直接算出数据地址。

- 增删元素慢

  - 指定索引位置增加或删除元素:需要创建一个新组，将指定新元素存储在指定索引位置，再把原数组元素根据素引，复制到新数组对应索引的位置。

  - 要把数组中索引是3的元素删除，

    必须创建一个新的数组,长度是源数组的长度-1

    把源数组的其他元素复制到新数组中

    把新数组的地址赋值给原来的数组变量arr

    源数组会在内存中被销毁(垃圾回收)

------

## 1.4 链表

链表:linked list,由一系列结点node( 链表中每一个元素称为结点)组成，结点可以在运行时动态生成。链表中的每一个元素也称之为一个结点。

每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

我们常说的链表结构有单向链表与双向链表。

单向链表:链表中只有一条链子,不能保证元素的顺序(存储元素和取出元素的顺序有可能不一致)

双向链表:链表中有两条链子,有一条链子是专门记录元素的顺序,是一个有序的集合。上一个结点会记录下一个结点的地址，下一个结点也会记录上一个结点的地址。

链表的特点：

- 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。
- 查找元素慢:想查找某个元素，都必须从头开始查询。链表中的地址不是连续的，需要通过连接的节点，依次向后查找指定元素。
- 增删元素快:
  - 增加或删除元素 : 只需要修改连接下个元素的地址即可，对表的整体构没有影响。

------

## 1.5 红黑树

**二叉树** : binary tree ,是每个结点不超过2的有序**树**( tree )。

简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。分叉不能超过2个。

二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和"右子树”。

红黑树本身就是一棵二叉查找树，将节点插入后，该树仍然是二叉查找树。

计算机中的树是倒过来的，根部在最上端。

------

排序数/查找树

在二叉树的基础上,元素是有大小顺序的。

左子树小,右子树大。

例如：

```
	 4
左 2    6  右
 1  3  5  7
 每一个分叉算作上一个结点的子树。
 猜数字小游戏:1-100之间的数字,从50开始猜,猜一次减去一半
```

------

平衡树: 左子树和右子树相等，对称，分叉的个数也相等。

不平衡树:左子树不等于右子树，不对称，分叉的个数不相等。

红黑树：

- 特点：趋近于平衡树,查询的速度非常的快,查询叶子节点最大次数和最小次数不能超过2倍。
- 约束:
  - 1.节点可以是红色的或者黑色的
  - 2.根节点是黑色的
  - 3.叶子节点(空节点)是黑色的
  - 4.每个红色的节点的子节点都是黑色的
  - 5.任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同。

例:

```
      黑
   红     红
黑   黑 黑   黑
```

------

# 2 List集合

## 2.1 介绍以及常用方法

List接口的底层是一个长度可变的数组。

List接口的特点:

- 1.有序的集合，存储元素和取出元素的顺序是一致的(存储123，取出123)
- 2.有索引,包含了一些带索引的方法
- 3.允许存储重复的元素

List接口中带索引的方法(特有)

- `public void add(int index，E element):` 将指定的元素，添加到该集合中的指定位置（index就是索引编号）上。
- `public E get(int index):`返回集合中指定位置的元素。
- `public E remove(int index):` 移除列表中指定位置的元素，返回的是移除的元素。
- `public E set(int ndex，E element):`用指定元素替换集合中指定位置的元素,返回值为更新前的元素。

注意：

操作索引的时候,一定要防止索引越界异常。

IndexOutofBoundsException:索引越界异常

ArrayIndexQutofBoundsException;数组索引越界异常

StringIndexOutofBoundsException:字符串索引越界异常

遍历List集合的三种方法：

- 普通for循环搭配get()方法。
- 迭代器
- 增强for循环

------

## 2.2 ArrayList集合

ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList 是最常用的集合。

许多程序员开发时非常随意地使用ArrayLIst完成任何需求，并不严谨，这种用法是不提倡的.

如果需要更多地查询，那么用ArrayList集合效率就比较高。如果增删比较多，那么用ArrayList集合效率就比较低。

------

## 2.3 LinkedList集合

LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。

LinkedList集合是List接口的实现类。

LinkedList集合的特点:

- 1.底属是一个链表结构:查询慢,增删快
- 2.里边包含了大量操作首尾元素的方法

注意:使用Linkedlist集合特有的方法，不能使用多态

- `public void addFirst(E e):`将指定元素插入此列表的开头。
- `public void addLast(E e):`将指定元素添加到此列表的结尾。
- `public void push(E e):`将元素推入此列表所表示的堆栈。等效于addFirst()
- `public E getFirst()`:返回此列表的第一个元素。
- `public E getLast()`:返回此列表的最后一个元素。
- `public E removeFirst():`移除并返回此列表的第一个元素
- `public E removeLast():`移除并返回此列表的最后一个元素
- `public E pop()`:从此列表所表示的堆栈处弹出一个元素，等效于removeFirst()
- `public boolean isEmpty():` 如果列表不包含元素，则返回true.
- `public void clear();`清空集合中的元素,清空后再用get()或getFirst()或getLast()获取集合中的元素就会抛出NoSuchELementException异常。

```java
public static void main(String[] args) {
    ArrayList<String> list=new ArrayList<>();
    list.add("jaskdh");
    list.add("jaskdh");
    list.add("jaskdh");
    list.add(1,"123");
    //System.out.println(list);
    method();
}

private static void method() {
    LinkedList<String> list=new LinkedList<>();
    list.add("a");
    list.add("b");
    list.add("c");
    System.out.println(list);
    String str=list.pop();
    System.out.println(str);
    //list.clear();
    System.out.println(list);
    if (!list.isEmpty()){//可以避免抛出异常
        String first = list.getFirst();
        String last = list.getLast();
        System.out.println(first);
        System.out.println(last);
    }
}
```

------

## 2.4 Vector集合

Vector 类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector后进行添加或移除项的操作。

缺点：单线程，速度慢。

------

## 2.5 HashSet集合介绍

javo.util.HashSet集合实现Set接口，由哈希表（速度非常快）支持。它是一个无序的结构。

优点：多线程，速度快。

而Set接口实现了Collection接口

Set接口的特点:

- 1.不允许存储重复的元素
- 2.没有索引,没有带素引的方法,也不能使用**昔通的for循环**遍历
- 3.可以使用增强for循环和迭代器来遍历set集合

HashSet特点:

- 1.不允许存储重复的元素
- 2.没有索引,没有带索引的方法,也不能使用普通的for循环遍历
- 3.是一个无序的集合，存储元素和取出元素的顺序有可能不一致
- 4.底层是一个哈希表结构(查询的速度非常的快)

------

## 2.6 哈希值

哈希值:是一个十进制的整数，由系统随机给出（就是对象的地址值,是一个逻辑地址,是模拟出来得到的地址,不是数据实际存储的物理地址）

在Obiect类有一个方法，可以获取对象的哈希值

int hashCode() 返回该对象的哈希码值。

hashCode方法的源码:

`public native int hashCode();`

native:代表该方法调用的是本地操作系统的方法

例：

直接输出一个对象名，该对象名属于的类没有重写toString方法。

```java
public static void main(String[] args) {
    Person person1=new Person();
    Person person=new Person();
    System.out.println(person);//@4f3f5b24
    int h1=person1.hashCode();
    int h2=person.hashCode();
    System.out.println(h2);//1329552164
    System.out.println(person1);//@15aeb7ab
    System.out.println(h1);//363771819
}
```

我们可以发现，直接输出对象名的结果是一个十六进制的地址值，而用了hashCode方法之后，输出的是一个十进制的地址值，这两个地址值在数值上是相等的。

toString方法的源码:

```java
return getclass().getName()+"@”+ Integer.tohexString(hashcode());
```

注意：

如果对象所在的类重写了hashCode方法，则输出十进制哈希值时用的就是重写后的hashCode方法。

调用toString方法时使用的hashCode方法也是自己重写的那个方法（如果没重写则默认输出十六进制）。

比较两个对象名是否相等时，实际上比较的是对象名的物理地址值，而不是哈希值（逻辑地址值）。

即使我把p1和p2的哈希值都改为1，p1==p2的返回值还是false。

```java
System.out.println("abc".hashCode());//96354
System.out.println("abc".hashCode());//96354
System.out.println("重地".hashCode());//1179395
System.out.println("通话".hashCode());//1179395
```

------

## 2.7 HashSet集合存储数据的结构（哈希表）

HashSet集合存储数据的结构（**哈希表**）

jdk1.8版本之前:哈希表=数组+链表

jdk1.8版本之后:

哈希表=数组+链表;

哈希表=数组+红黑树(提高查询的速度)

哈希表的特点:速度快

存储数据到集合中，先计算元素的哈希值。

例如：

“abc”字符串在数组中的存储位置是96354

哈希冲突：两个元素不同，但是哈希值相同。

例如：

“重地”和“通话”的哈希值都为1179395.

数据结构:把元素进行了分组(相同哈希值的元素是一组) 

链表/红黑树结构把相同哈希值的元素连接到一起。

“重地”和“通话”连接在一起，且通过链表连接到数组中的同一个单元。例如：“重地”连接数组单元，“通话”连接“重地”。

**如果链表的长度超过了8位，那么就会把链表转换为红黑树(提高查询的速度)**

------

## 2.8  Set集合存储元素不重复的原理

Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法判断元素是否重复。

步骤：

- set.add(s1);
- add方法会调用s1的hashCode方法，计算宇符串"abc”的哈希值，哈希值是96354。
- 在集合中找有没有**96354**这个哈希值的元素,发现**没有**。
- **就会把s1存储到集合中**。
- set.add(s2);
- add方法会调用s2的hashCode方法，计算字符串”abc”的哈希值，哈希值是**96354**。
- 在集合中找有没有**96354**这个哈希值的元素，发现**有**(哈希冲突)。
- s2会调用equals方法和哈希值相同的元素进行比较。
- s2.equals(s1),返回**true**
- 两个元素的哈希值相同,equals方法返回true,认定**两个元素相同**。
- **就不会把s2存储到集合中**。

set集合存储元素不重复的元素

前提:存储的元素必须重写hashCode方法和equals方法。

注意：如果没有用到Set集合则不需要重写hashCode方法。

“重地”和“通话”也是如此。

两个元素的哈希值相同,调用equals方法后，equals方法返回false，发现两个元素**不同**。就会把“通话”存储到集合中。

------

## 2.9 HashSet存储自定义类型元素

set集合保证元素唯一:

存储的元素(String,Integer,...Student,Person...)必须重写hashCode方法和equals方法。

要求:

同名同年龄的人,视为同一个人，只能存储一次。

```java
public class Demo04HashSet02 {
    public static void main(String[] args) {
        Person person=new Person("jim",18);
        Person person1=new Person("jim",18);
        Person person2=new Person("marry",18);
        Person person3=new Person("marry",20);
        HashSet<Person> s1=new HashSet<>();
        s1.add(person1);
        s1.add(person2);
        s1.add(person3);
        s1.add(person);
        System.out.println(person1.hashCode());
        System.out.println(person.hashCode());
        System.out.println(person1==person);
        System.out.println(person1.equals(person));
        System.out.println(s1);
    }
}
```

```java
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    @Override
    public String toString() {//toString方法也最好重写。
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {//一定要重写equals方法
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {//一定要重写hashCode方法
        return Objects.hash(name, age);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

```

------

## 2.10 LinkedHashSet集合

javo.util.LinkedHashSet集合 extends Hashset集合

LinkedHashSet集合特点:

底层是一个哈希表(数组+链表/红黑树)+链表:多了一条表(记录元素的存储顺序),保证元素有序。

```java
public static void main(String[] args) {
    HashSet<String> hashSet=new HashSet<>();
    hashSet.add("jim");
    hashSet.add("marry");
    hashSet.add("bobby");
    System.out.println(hashSet);//无序，不允许重复
    LinkedHashSet<String> linkedHashSet=new LinkedHashSet<>();
    linkedHashSet.add("jim");
    linkedHashSet.add("marry");
    linkedHashSet.add("bobby");
    System.out.println(linkedHashSet);//有序，不允许重复
}
```

------

# 3 可变参数

可变参数:是JDK1.5之后出现的新特性

使用前提:当方法的参数列表数据类型已经确定，但是参数的个数不确定,就可以使用可变参数。

使用格式:（定义方法时使用）

- 修饰符 返回值类型 方法名(数据类型...变量名){}

可变参数的原理:

- 可变参数底层就是一个**数组**，根据传递参数个数不同,会创建不同长度的数组,来存储这些参数传递的参数个数,可以是0个(不传递),1,2...多个.

直接输出形参变量名，得到的是一个地址，这个变量名其实就是数组名。

有n个参数，就会new一个有n个数组单元的数组（数组长度为n），每个数组单元按顺序存放参数值。

```java
public static void main(String[] args) {
    int result=method(1,2,3,4,5);
    System.out.println(result);
}
public static int method(int...num){
    int sum=0;
    for (int i:num){
        sum+=i;
    }
    return sum;
}
```

可变参数的注意事项：

- 1.一个方法的参数列表，只能有一个可变参数
  - 错误写法：`public static void method(int...a,string..b)`
- 2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。
  - 正确写法：`public static void method(string b,double c, int d, int...a)`
  - 错误写法：`public static void method(int...a,string b,double c, int d)`
- 3.可变参数的特殊(终极)写法
  - `public static void method(Object...obj)`

------

# 4 Collections集合工具类的方法

## 4.1 addAll方法和shuffle方法

java.utils.Collecttons是集合工具类，用来对集合进行操作。

- `public static <T> boolean addAll(Collection<T> c,T...elements):`往集合中添加一些元素。
- `public static void shuffle(List<?> list)` 打乱顺序：打乱集合顺序。每执行一次该方法，集合的顺序就有可能不同。

用法：

```java
public static void main(String[] args) {
    ArrayList<String> list=new ArrayList<>();
    //注意：这里是Collections类直接调用方法，而不是集合对象来调用方法。
    Collections.addAll(list,"a","b","c");
    System.out.println(list);
    Collections.shuffle(list);
    System.out.println(list);
}
```

------

## 4.2 sort方法之Comparable

`public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。

注意:
sort(List<T> List)的使用前提：

被排序的集合里边存储的元素，必须实现Comparable,重写接口中的方法compareTo定义排序的规则。

Comparable接口的排序规则:

- 自己(this)-参数:升序
- 参数-自己(this):降序

```java
public static void main(String[] args) {
    ArrayList<Person> list=new ArrayList<>();
    list.add(new Person("bobby",19));
    list.add(new Person("jim",18));
    list.add(new Person("marry",18));
    list.add(new Person("tom",20));
    System.out.println(list);
    Collections.sort(list);
    System.out.println(list);
}
```

```java
public class Person implements Comparable<Person>{
    @Override
    public int compareTo(Person o) {
        return o.getAge()-this.getAge();//年龄降序排序
        //如果返回0，则表示两个元素是相同的。
    }
    private String name;
    private int age;
    public Person() {
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

------

## 4.3 sort方法之Comparator

`public static <T> void sort(List<T> list, Comparator<? super T> ):`

将集合中元素按照指定规则排序。

Comparator和Comparable的区别：

- Comparable:自己(this)和别人(参数)比较,自己（this所指的类）需要实现Comparable接口,重写比较的规则compareTo方法。
- Comparator:相当于找一个第三方的裁判,比较两个元素。

Comparator的排序规则:

重写compare方法，其中的参数o1和o2

- o1-o2：升序
- o2-o1：降序

```java
public static void main(String[] args) {
    ArrayList<Person> list=new ArrayList<>();
    list.add(new Person("bobby",19));
    list.add(new Person("jim",18));
    list.add(new Person("marry",18));
    list.add(new Person("tom",20));
    System.out.println(list);
    Collections.sort(list, new Comparator<Person>() {
        @Override
        public int compare(Person o1, Person o2) {
            int result=o1.getAge()-o2.getAge();//按照年龄升序排序
            if (result!=0)return result;//比较年龄大小
            else {
                return o2.getName().charAt(0)-o1.getName().charAt(0);
                //如果两个人年龄相同,再使用姓名的第一个字比较。降序排序
            }
        }
    });
    System.out.println(list);
}
```

------

# 5 Map集合

## 5.1 概述

Collection集合是单列集合，而Map集合是双列集合。

Map<K ，V>

类型参数:

- K-此映射所维护的**键的类型**（key）
- V- 映射**值的类型**（value）

注意：键和值是一一对应的。

将键映射到值的对象。一个映射不能包含重复的键（K），每个键最多只能映射到一个值。

一个对象包括两个值，一个是键，一个是值。

Collection 接口 ：定义了单列集合规范，每次存储一个元素，一个元素只有一个值。

Map 接口：

- 定义了双列集合的规范，每次存储一个元素，但一个元素包含两个值，K和V。
- 通过键可以找到对应的值。
  - 键唯一，不允许重复，value值可以重复。
  - 键和值一一映射，一个键对应一个值。
  - 靠键维护他们的关系。
- Map集合中的元素，key和value的数据类型可以相同,也可以不同。
- Map集合中的元素,key和value是一一对应的。

------

## 5.2 Map常用子类

java.util.HashMap<k,v>集合 implements Map<k,v>接口

HashMap集合的特点:

- HashMap集合底层是哈希表:查询的速度特别的快
  - JDK1.8之前:数组+单向链表
  - JDK1.8之后:数组+单向链表/红黑树(链表的长超过8):提高查询的速度
- HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致

java.util.LinkedHashMap<k,v>集合 extends HashMap<k,v>集合

LinkedHashMap的特点:

- LinkedHashMap集合底层是哈希表+链表(保证选代的顺序)
- LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的。

------

## 5.3 Map接口中的常用方法

HashMap方法重写了toString方法。

`public V put(k key，V value):` 

把指定的键与指定的值添加到Map集合中。

返回值:V

存储键值对的时候,key不重复,返回值v是null.

存储键值对的时候,key重复,会使用**新的**value替换map中重复的value,返回被替换的value值。

------

public V remove(Object key): 把指定的键以及所对应的键值对元素，在Map集合中删除，返回被删除元素的值。

返回值:V

- key存在，v返回被删除的值
- key不存在，则v返回null。

```java
String jim = map.remove("jim");
String a = map.remove("A");
System.out.println(a);//null
System.out.println(jim);//sam
System.out.println(map);
```

```java
Map<String,Integer> map1=new HashMap<>();
map1.put("jim",18);
map1.put("marry",18);
map1.put("jane",19);
System.out.println(map1);
Integer jim1 = map1.remove("jim");//Integer可以换成int，有自动拆箱的过程。
Integer a1 = map1.remove("a");//Integer不可以换成int，因为map中没有“a”这个键，会返回null。
//将null返回给int，会抛出空指针异常。NullPointerException
System.out.println(jim1);
System.out.println(a1);
System.out.println(map1);
```

注意：我们要多使用包装类来接收这种类型的返回值，尽量少使用基本数据类型。

------

`public V get(Object key)`

根据指定的键，在Map集合中获取对应的值。

返回值:

- key存在，返回对应的value值.
- key不存在，返回null。

```java
Integer jane = map1.get("jane");
System.out.println(jane);//19
Integer a2 = map1.get("a");
System.out.println(a2);//null
```

------

`boolean containsKey(Object key)`

判断集合中是否包合指定的键，包含返回true,不包含返回false。

```java
boolean jim2 = map1.containsKey("jim");
boolean jane1 = map1.containsKey("jane");
System.out.println(jim2);//false
System.out.println(jane1);//true
```

------

## 5.4 Map集合遍历键找值方式

Map集合的k值是什么类型，keySet方法的返回值就是什么类型，用于接收该返回值的Set集合就是什么类型。

Map集合的第一种遍历方式:通过键找值的方式。

Map集合中的方法:

`set<K> keySet()` 返回此映射中包含的键的 Set 视图。

实现步骤:

- 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中。
- 2.遍历Set集合,获取Map集合中的每一个key
- 3.通过Map集合中的方法get(key),通过key找到value。

```java
public static void main(String[] args) {
    //创建Map集合对象
    Map<String,Integer> map=new HashMap<>();
    map.put("jim",18);
    map.put("jane",19);
    map.put("bobby",28);
    //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个set集合中
    Set<String> set=map.keySet();
    //2.遍历set集合,获取Map集合中的每一个key
    //使用迭代器遍历Set集合
    Iterator<String> it=set.iterator();
    while (it.hasNext()){
        String key=it.next();
        //3.通过Map集合中的方法get(key),找到VoLue
        Integer value=map.get(key);
        System.out.println(key+"="+value);
    }
    //使用增强for遍历set集合
    for (String key:set){
        Integer value=map.get(key);
        System.out.println(key+"="+value);
    }
    //使用增强for遍历set集合
    for (String key: map.keySet()){
        Integer value=map.get(key);
        System.out.println(key+"="+value);
    }
}
```

------

## 5.5 Entry键值对对象

MapEntry<K，V>:在Map接口中有一个内部接口Entry.

作用:当Map集合一创建，那么就会在Map集合中创建一个Entry对象,用来记录键与值（键值对对象,键与值的映射关系）。

Map集合遍历的第二种方式:使用Entry对象遍历

Map集合中的方法:

`Set<Map.Entry<k,V>> entrySet()` 返回此映射中包合的映射关系的 Set 视图。

实现步骤:

- 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中
  - `Set<Map.Entry<K,V>> entrySet()`
- 2.遍历Set集合,获取每一个Entry对象
- 3.使用Entry对象中的方法getKey()和getValue()获取键与值。

```java
public static void main(String[] args) {
    //创建Map集合对象
    Map<String,Integer> map=new HashMap<>();
    map.put("jim",18);
    map.put("jane",19);
    map.put("bobby",28);
    //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中
    Set<Map.Entry<String, Integer>> set = map.entrySet();
    //2.遍历set集合,获取每一个Entry对象
    // 使用迭代器遍历set集合
    Iterator<Map.Entry<String ,Integer>> it=set.iterator();
    while (it.hasNext()){
        Map.Entry<String, Integer> entry = it.next();
        //3.使用Entry对象中的方法getKey()和getValue()获取键与值
        String name=entry.getKey();
        Integer age=entry.getValue();
        System.out.println(name+"="+age);
    }
    for (Map.Entry<String, Integer> entry:set){
        String name=entry.getKey();
        Integer age=entry.getValue();
        System.out.println(name+"="+age);
    }

}
```

------

## 5.6 HashMap存储自定义类型键值

HashMap存储自定义类型键值

Map集合保证key是唯一的:

作为key的元素，必须重写hashCode方法和equals方法,以保证key唯一。

例：

key:String类型

- String类重写了hashCode方法和equals方法,可以保证key的唯一。
- value;Person类型

value可以重复(同名同年龄的人视为同一个)

```java
public static void main(String[] args) {
    HashMap<String,Person> map=new HashMap<>();
    map.put("北京",new Person("jim",18));
    map.put("上海",new Person("marry",19));
    map.put("广州",new Person("jane",18));
    map.put("北京",new Person("tom",20));
    for (String s : map.keySet()) {
        Person value=map.get(s);
        System.out.println(s+value.getName()+value.getAge());
        //System.out.println(value);
    }
}
```



HoshMap存储自定义类型键值

key:Person类型

- Person类就必须重写hashcode方法和equals方法,以保证key唯一

value:String类型

- 可以重复

```java
private static void method02() {
    HashMap<Person,String> map=new HashMap<>();
    map.put(new Person("jim",21),"北京");
    map.put(new Person("jane",20),"上海");
    map.put(new Person("tom",18),"广州");
    map.put(new Person("jim",21),"深圳");
    Set<Map.Entry<Person, String>> entries = map.entrySet();
    for (Map.Entry<Person,String > entry:entries){
        Person key=entry.getKey();
        String address=entry.getValue();
        System.out.println(key+address);
    }
}
```

------

## 5.7 LinkedHashMap集合

java.util.LinkedHashMap<k,V> extends HashMap<k ,V>

Map 接口的哈希表和链接列表实现，具有可预知的选代顺序。

底层原理:

哈希表+链表(记录元素的顺序)

注意：

HashMap集合的Key不允许重复，无序。

HashMap集合的Key不允许重复，有序。

```java
private static void method03() {
    LinkedHashMap<String,String> map1=new LinkedHashMap<>();
    map1.put("a","a");
    map1.put("c","c");
    map1.put("d","d");
    map1.put("b","b");
    System.out.println(map1);//按顺序输出
}
```

------

## 5.8 Hashtable集合

java.util.Hashtable<K,V>集合 implements Map<K,V>接口

Hashtable:底层也是一个哈希表,是一个线程安全的集合，是单线程集合，速度慢。

HashMap:底层是一个哈希表,是一个线程不安全的集合，是多线程的集合，速度快。

HashMap集合(以及之前学的所有的集合):可以存储null值和null键

Hashtable集合，不能存储null值和null键。

Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。

Hashtable的子类properties依然活跃在历史舞台上。

Properties集合是一个唯一和io流相结合的集合。

```java
public static void main(String[] args) {
    HashMap<String,String > map=new HashMap<>();
    map.put("a",null);
    map.put(null,null);
    map.put(null,"a");
    System.out.println(map);
    Hashtable<String,String> map1=new Hashtable<>();
    map1.put(null,"a");//NullPointerException
    map1.put(null,null);//NullPointerException
    map1.put("a",null);//NullPointerException
}
```

------

# 6 补充知识点

## 6.1 JDK9对集合添加的优化

JDK9的新特性:

List接口,Set接口，Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素.

static <E> List<E> of (E... elements)

使用前提:

当集合中存储的元素的个数已经确定了，不在改变时使用（意思是使用完of方法后，不能再用add方法或者put方法了）

注意:

- 1.of方法只适用于Ltst接口,Set接口,Map接口,不适用于这些接口的实现类
- 2.of方法的返回值是一个不能改变的集合，集合不能再使用add或put方法添加元素，否则会抛出异常
- 3.Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出导常，而List接口可以有重复的元素。

```java
public static void main(String[] args) {
    List<String> list=List.of("a","b","v","c","d","a");
    System.out.println(list);
    list.add("a");//UnsupportedOperationException:不支持操作异常

    Set<String> set=Set.of("a","b","v","c","d","a");//ILLegalArgumentException:非法参数异常，有重复的元素
    Set<String> set=Set.of("a","b","v","c","d");
    System.out.println(set);
    set.add("a");//UnsupportedOperationException:不支持操作异常
    Map<String,Integer> map=Map.of("jim",18,"marry",20,"jane",19,"jim",20);//ILLegalArgumentException:非法参数异常，有重复的元素
    Map<String,Integer> map=Map.of("jim",18,"marry",20,"jane",19);
    System.out.println(map);
    map.put("a",180);//UnsupportedOperationException:不支持操作异常
}
```



------

## 6.2 Debug追踪

Debug调试程序:

可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug

使用方式:

- 在行号的右边,鼠标左键单击，添加断点(每个方法的第一行，哪里有bug添加到哪里)
- 右键,选择Debug执行程序
- 程序就会停留在添加的第一个断点处

执行程序:

- F8:逐行执行程序
- F7:进入到方法中(在执行到调用方法的那一行的时候（即高亮的时候），按F7)
- shift+F8:跳出方法
- F9:跳到下一个断点,如果没有下一个断点,那么就结束程序
- ctrL+F2:退出debug模式，停止程序
- Console:切换到控制台

------

# 7 异常

## 7.1 概述

**异常** : 指的是程序在执行过程中，出现的非正常的情况，最终会导致VM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是**创建异常对象**并**抛出了一个异常对象**。Java处理异常的方式是中断处理。

注意：异常指的并不是语法错讽,语法错了,编译不通过,不会产生字节码文件,根本不能运行。

------

## 7.2 异常体系

异常机制其实是帮助我们找到程序中的问题，异常的根类是 java.lang.Throwable，其下有两个子类:

- java.lang.Error（攻城狮不能处理，只能尽量避免）
  - 严重错误Error，无法通过处理的错误，只能事先避免。
- java.lang.Exception （由于使用不当导致，可以避免的）
  - 表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。

平常所说的异常指 java.lang.Exception.

出观异常不要紧张，把异常的简单类名拷贝到API中去查询。

Throwable中的常用方法:

`public void printstackTrace():`

打印异常的详细信息.

包含了异常的类型、异常的原因还包括异常出现的位置。在开发和测试阶段都得使用printStackTrace.

`public String getMessage()`:获取发生异常的原因.

提示给用户的时候，就提示错误原因。

`public String toString():`

获取异常的类型和异常描述信息(不用).

------

## 7.3 异常分类

java.lang.Throwable类是 Java 语言中所有错误或异常的超类。

- Exception：编译期异常，进行编译(写代码)java程序出现的问题。

  - RuntimeException:运行期异常，java程序运行过程中出现的问题

    异常就相当于程序得了一个小毛病(感冒,发烧),把异常处理掉,程序可以继续执行。

  ```java
  public static void main(String[] args) /*throws ParseException*/ {
      //Exception:编译期异常,进行编译(写代码)java程序出现的问题
      SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd");
      Date date= null;
      try {
          date = format.parse("2002-1024");
      } catch (ParseException e) {
          //throw new RuntimeException(e);//执行这一句，抛出异常后就直接终止程序
          e.printStackTrace();//执行这一句，抛出异常后会进行下面的语句
      }
      System.out.println(date);
      System.out.println("后续代码");
  
      //RuntimeException:运行期异常，java程序运行过程中出现的问题
      int[] arr={1,2,3,4};
      System.out.println(arr[3]);
      try {
          //可能会出现异常的代码
          System.out.println(arr[4]);
      }catch (Exception e){
          //异常的处理逻辑
          e.printStackTrace();
      }
  
  }
  ```

- Error:错误，就相当于程序得了一个无法治愈的毛病，必须修改源代码,程序才能继续执行。即出现Error之后，下面的代码不会再执行了，程序终止。

  ```java
  /*Error:错误
  OutOfMemoryError: Java heap space内存潜出的错误,创建的数组太大了,超出了给JVM分配的内存
  */
  int[] arr1 = new int[1024*1024*1024];
  //OutOfMemoryError异常
  //必须修改代码,创建的数组小一点
  int[] arr2= new int[1024*1024];
  System.out.println("后续代码~");
  ```

------

## 7.4 异常的产生过程解析

```java
public static void main(String[] args) {//第三步
    //创建int类型的数组,并赋值
    int[] arr= {1,2,3};
    int ele=getElements(arr,3);
    //第二步
    System.out.println(ele);
}
public static int getElements(int[] arr,int ele){
    return arr[ele];
    //第一步
}
```

- 一、访问了数组中的3索引，而数组是没有3索引的,这时候JVM就会检测出程序会出现异常。

  JVM会做两件事情:

  - 1.JVM会根据异常产生的原因创建一个异常对象，这个异常对象包含了异常产生的(**内容,原因,位置**)

    `new ArrayIndexOutofBoundsException("3");`

  - 2.在getElements方法中没有异常的处理逻辑(try...catch),那么JVM就会把异常对象抛出给方法的调用者main方法来处理这个异常。（getElements方法把异常对象抛出给main方法）

- 二、
  main方法接收到了这个（**new ArrayIndexOutofBoundsException("3");**）异常对象，main方法也没有异常的处理逻辑，继续把对象抛出给main方法的调用者JVM处理。

- 三、JVM接收到了这个异常对象,做了两件事博：

  - 1.把异常对象(**内容,原因,位置**)以红色的字体打印在控制名
  - 2.JVM会终止当前正在执行的java程序，即**中断处理**。

------

## 7.5 异常的处理

Java异常处理的五个关键字**:try、catch、finally、throw、throws**

### 7.5.1  抛出异常throw

在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。

步骤：

- 1.创建一个异常对象。封装一些提示信息(信息可以自己编写)。

- 2.需要将这个异常对象告知给调用者。通过关键字throw就可以将这个异常对象告知给调用者且传递到调用者处。

  throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

使用格式:

`throw new 异常类名(参数);`

throw关键字的作用:

可以使用throw关键字在指定的方法中抛出指定的异常。

使用格式：

throw new xxxException("异常产生的原因”);

注意:

- 1.throw关健字必须写在方法的内部

- 2.throw关键字后边new的对象必领是Exception或者Exception的子类对象

- 3.throw关键字抛出指定的异常对象，我们就必须处理这个异常对象。

  throw关键字后边如果创建的是RuntimeException或者是 RuntimeException的子类对象，我们可以不处理,默认交给JVM处理（打印异常对象，中断程序）。

  throw关键字后边如果创建的是编译异常(写代码的时候报错)，我们就必须处理这个异常，要么throws,要么try...catch。

我们首先必须对方法传递过来的参数进行合法性校验。

如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。

注意:

NullPotnterException是一个运行期异常，我们不用处理，默认交给JVM处理。

ArrayIndexOutofBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理。

```java
public static void main(String[] args) {
    int[] arr=new int[3];
    //int[] arr=null;
    int e=method(arr,3);
    System.out.println(e);
}
public static int method(int[] arr,int num){
    //对传递过来的参数进行合法性判断，判断其是否为null
    if (arr==null){
        throw new NullPointerException("传递的数组的值为空");
    }else if (num>arr.length-1||num<0){
        throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围");
    }
    return arr[num];
}
```

------

### 7.5.2 Objects非空判断

Objects类，它由一些静态的实用方法组成，这些方法是null-save( 空指针安全的)或null-tolerant(容忍空指针的)，那么在它的源码中，对对象为null的值进行了抛出异常操作。

public static <T> T requireNonNull(T obj) :查看指定引用对象是不是null.

requireNonNull(T obj)方法源码：

```java
public static <T> T requireNonNull(T obj) {
    if (obj == null)
        throw new NullPointerException();
    return obj;
}
```

```java
//对传递过来的参数进行合法性判断，判断其是否为null
    if (obj==null){
        throw new NullPointerException("传递的数组的值为空");
  /*效果：
        Exception in thread "main” java.lang.NullPointerException: 传递的数组的值为空
        */
//方法2：
	Objects.requireNonNull(obj);
        /*效果：
        Exception in thread "main” java.lang.NullPointerException
        */
//方法3：（重载方法）
	Objects.requireNonNull(obj，"传递的对象的值是null");
        /*效果：
  Exception in thread "main” java.lang.NullPointerException: 传递的对象的值是null
         */
```

------

### 7.5.3 throws关键字

throws关键字:异常处理的第一种方式，交给别人处理。

作用:

当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象。

可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理)，最终交给JVM处理（**中断处理**）（即后面的代码不再执行）

使用格式：在方法声明时使用

```java
修饰符 返回值类型 方法名(参数列表) throws AAAExceptton, BBBExcepiton...{
	throw new AAAExcgpiton("产生原因");
	throw new BBBExceptton("产生原因");
}
```

注意:

- 1.throws关键宇必须写**在方法声明处**.

- 2.throws关键字后边声明的异常必须是Exception或是Exception的子类

- 3.方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常，以逗号分隔开。

  如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可。

- 4.调用了一个声明抛出异常的方法，我们就必须的处理声明的异常。

  要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM处理。要么用try...catch自己处理异常。

```java
/*
FileNotFoundException extends IOExption extends Excepiton
如果抛出的多个异常对象有子父类关系。那么直接声明父类异常即可
public static void main(String[] args) throws FileNotFoundException, IOException 
public static void main(String[] args) throws IOException
public static void main(string[] args) throws Exception
*/
public static void main(String[] args) throws IOException {
    readFile("c:\\text.txt");
    System.out.println("c:\\text.txt");
}
/*
定义一个方法，对传递的文件路径进行合法性判断。
如果路径不是"c:\\text.txt",那么我们就抛出文件找不到异常对象,告知方法的调用者。
注意:
FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常。
可以使用throws继续声明抛出FiLeNotFoundException这个异常对象，让方法的调用者处理。
*/
private static void readFile(String fileName) throws IOException {
    if (!fileName.equals("c:\\text.txt")){
        throw new FileNotFoundException("传递的文件路径不是c:\\text.txt");
    }
    /*
    如果传递的路径,不是.txt结尾那么我们就抛出IO异常对象，告知方法的调用者,文件的后缀名不对
    */
    if (!fileName.endsWith(".txt")){
        throw new IOException("后缀名错误");
    }
    System.out.println("success");
}
```

#### 补充

```java
public boolean endsWith(String suffix)
```

 endsWith() 方法用于测试字符串是否以指定的后缀结束。

参数：

- **suffix** -- 指定的后缀。

返回值：

如果参数表示的字符序列是此对象表示的字符序列的后缀，则返回 true；否则返回 false。注意，如果参数是空字符串，或者等于此 String 对象（用 equals(Object) 方法确定），则结果为 true。

------

### 7.5.4 try_catch捕获异常

try...catch:异常处理的第二种方式,自己处理异常

格式:

```java
try{
	可能产生异常的代码
}catch(异常类名 变量名){//定义一个异常的变量，用来接收try中抛出的异常对象
    异常的处理逻辑,创建异常对象之后,怎么处理异常对象.
    一般在工作中，会把异常的信息记录到一个日志中
}
...
catch(异常类名 变量名){}
```

注意:

- 1.try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象

- 2.如果try中产生了异常,那么就会执行catch中的异常处理逻辑，执行究毕catch中的处理逻辑,继续执行try...catch之后的代码。

  如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try...catch之后的代码。

```java
public static void main(String[] args) {
    try {
        //可能产生异常的代码
        Demo04Exception.readFile("c:\\text.txt");
    }catch (IOException e){//try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象
        //异常的处理逻辑,创建异常对象之后,怎么处理异常对象
        System.out.println("传递的文件后缀不是.txt");
    }
    System.out.println("后续代码");
}
```

------

### 7.5.5 Throwable类中3个异常处理的方法

Throwable类中定义了3个异常处理的方法：

`String getMessage()` 返回此 throwable 的简短指述。

`String toString()` 返回此 throwable 的详细消息字符串。

`void printStackTrace()` JVM打印异常对象,默认此方法,打印的异常信息是最全面的。

```java
System.out.println(e.getMessage());
//文件的后缀名不对

System.out.println(e.toString());
//重写object类的toString方法
//Java.io.IOException: 文件的后缀名不对

System.out.println(e);//实际上就是toString方法
//java.io.IOException: 文件的后缀名不对

e.printStackTrace();
//最详细的红色字体报错
```

------

### 7.5.6 finally代码块

```java
try{
    语句1;
    语句2;
}catch(){
    
}finally{
    //无论是否出现异常，都会执行。
}
```

如果语句1出现异常，则语句2不会执行。要想语句2被执行，可以移动语句2到finally中。

#### 注意事项

如果finally中有return语句，永远返回finally中的结果，避免该情况。

```java
private static int method() {
    try {
        return 100;
    }catch (Exception e){
        System.out.println(e);
    }finally {
        return 10;
    }
}
public static void main(String[] args){
    int a =method();
    System.out.println(a);//最终a的值为10.
}
```



------

### 7.5.7 多异常的捕获处理

- 1.多个异常分别处理。

  ```java
  public static void main(String[] args) {
      try {
          int[] arr={1,2,3};
          System.out.println(arr[3]);
      }catch (ArrayIndexOutOfBoundsException e){
          e.printStackTrace();
      }
  
      try {
          List<Integer> list=List.of(1,2,3);
          System.out.println(list.get(4));
      }catch (IndexOutOfBoundsException f){
          f.printStackTrace();
          System.out.println(f);
      }
      System.out.println("后续代码");
  }
  ```

- 2.多个异常一次捕获，多次处理。

  try中如果出现了异常对像,会把异常对像抛出给cateh处理。

  抛出的异常对象,会从上到下依次赋值给catch中定义的异常变量。

  ```java
  public static void main(String[] args) {
      try {
          int[] arr={1,2,3};
          //System.out.println(arr[3]);
          //如果try中有一句语句有异常，则try中下面的语句则不会再执行。
          //因此只会显示出一个异常。
          List<Integer> list=List.of(1,2,3);
          System.out.println(list.get(4));
          //在jdk19中，这个List集合的异常也归并到ArrayList当中。
      }catch (ArrayIndexOutOfBoundsException e){//子类
          System.out.println(e);
      }catch (IndexOutOfBoundsException f){//父类
             System.out.println(f);
      }
      System.out.println("后续代码");
  }
  //若把上面这两个子父类调换位置，即Index在上Array在下，则try中的两个异常就都被最上方的（即父类）catch了，就不会轮到下方的（即子类）来catch了。因此子类定义的变量就没有用到，会报错。
  
  //若把父类放到上方，则运用到了多态。
  IndexOutOfBoundsException f=new ArrayIndexOutOfBoundsException("3");
  IndexOutOfBoundsException f=new IndexOutOfBoundsException("4");
  ```

  一个try多个catch注童事项:

  catch里边定义的异常变量,如果有子父类关系，那么子类的异常变量必须写在上边的catch,父类的异常变量必须写在下面的catch中，否则就会报错。

  例如：ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException。

- 3.多个异常一次捕获，一次处理。

  ```java
  try{
      
  }catch(这里写有可能出现的异常的父类异常){
      
  }
  ```

注意：

- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。
- 默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再来继续执行程序。

------

### 7.5.8 子父类异常

注意：

- 如果父类抛出了多个异常，子类重写父类方法时，可以抛出**和父类相同的异常**或者是**父类异常的子类异常**或者**不抛出异常**。
- 若父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能用try...catch捕获处理，不能声明抛出。
- 注意:

父类异常是什么样的，子类异常就是什么样的。

```java
public class Fu{
    public void method01() throws NullPointerException,ClassCastException{}
    public void method02() throws IndexOutOfBoundsException{}
    public void method03() throws IndexOutofBoundsException{}
    public void method04() {}
    //子类重写父类方法时,抛出和父类相同的异常
    public void method01() throws NullpointerException,ClassCastException()
    //子类重写父类方法时,抛出父类异常的子类异常
    public void method02() throws ArrayIndexOutofBoundsException{}
    //子类重写父类方法时，不抛出异常
    public void method03() {}
//若父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常
    //错误写法：
    public void method04() throws Exception(){}
    //此时子类产生该异常，只能捕获处理，不能声明抛出
    public void method04() {
        try {
            throw new Exception(“编译期异常”);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

------

### 7.5.9 自定义异常类

java提供的异常类,不够我们使用,需要自己定义一些异常类

格式:

```java
public class XXXException extends Exception | RuntimeException{
    //添加一个空参数的构造方法
    //添加一个带有异常信息的构造方法
}
//注意： |  的意思是  或
```

注意:

- 1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类
- 2.自定义异常类，必须继承Exception或者RuntimeException
  - 如果继承Exception：那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理这个异常，要么throws,要么try...catch
  - 如果继承RuntimeException：那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理)

```java
public class RegisterException extends Exception{
    //添加一个空参数的构造方法
    public RegisterException(){
        super();
    }
    //添加一个带异常信息的构造方法
    //查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息.
    public RegisterException(String message){
        super(message);
    }
}
```

---

# 一、多线程

## 1 并发与并行

- **并发** : 指两个或多个事件在同一个时问段内发生。
  - 交替进行，执行完一个任务再执行下一个任务。相当于一个人吃两个馒头。
- **并行**: 指两个或多个事件在同一时刻发生（同时发生）
  - 同时执行多个任务，相当于两个人吃两个馒头。速度更快。

------

## 2 线程与进程

### 2.1 进程的概念

- **进程**:是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，**一个**应用程序可以同时运行**多个**进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

  例如：腾讯电脑管家:点击运行,会进入到内存中,它就是一个进程。

- **线程：**线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。**一个**进程中是可以有**多个**线程的，这个应用程序也可以称之为多线程程序。

  简而言之:一个程序运行后至少有一个进程，一个进程中可以包含多个线程。

**硬盘**: 永久存储（ROM）

**内存** :所有的应用程序都需要进入到内存中执行，内存相当于临时存储（RAM）。

- 点击应用程序执行,进入到内存中，占用一些内存执行，进入到内存的程序叫进程。
- 在任务管理器中结束进程，那么就把进程从内存中清除了。

------

### 2.2 线程的概念

CPU的一些参数：4核心8线程

例如：点击功能(病毒查杀.清理垃圾,电脑加速)执行，就会开启一条应用程序到cpu的执行路径，cpu就可以通过这个路经去执行功能。这个路径有一个名字，叫**线程。**

**线程**属于**进程**，是进程中的一个执行单元，负责程序的执行。

- 单核心单线程cpu：
  - cpu在多个线程之问做高速的切换，轮流执行多个线程，效率低，切换的逐度慢(1/n毫秒)。
- 4核心8线程CPU：
  - 有8个线程，可以同时执行8个线程（任务）。
  - 8个线程在多个任务之问做高速的切换，速度是单线程cpu的8倍(每个任务被执行到的几率都被提高了8倍)

多线程好处:

- 1.效率高
- 2.多个线程之问互不影响

------

### 2.3 线程调度

- 分时调度

  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间

- 抢占式调度
  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为**抢占式调度**

  - 设置线程的优先级

    在任务管理器中的详细信息里面（win8以上），右键单击某个进程，可以看到设置优先级，根据自身的喜好去选择。

  - 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。

  - 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的**一个核**而言，某个时刻，只能执行**一个线程**，而 CPU在多个线程间切换速度非常快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。

------

### 2.4 主线程

主线程:执行主(main)方法的线程

单线程程序：在java程序中只有一个线程

执行从main方法开始,从上到下依次执行。

JVM执行main方法，main方法会进入到栈内存。

JVM会找操作系统开辟一条main方法通向cpu的执行路径

cpu就可以通过这个路径来执行main方法。

而这个路径有一个名字,叫main(主)线程。

单线程程序的**弊端**：从main方法开始,从上到下依次执行。如果中途有异常出现，则异常下方的代码将不会再继续执行。

------

## 3 创建线程类

### 3.1 第一种方式

**创建Thread类的子类**

java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类

Java使用`java.lang.Thread` 类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：

- 1.定义Thread类的子类，并重写该类的run()方法，设置线程任务(开启线程要做什么?)，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
- 2.创建Thread子类的实例，即创建了线程对象.
- 3.调用线程对象的start()方法（Thread类中的方法）来启动新的线程，执行run方法。
  - void start() 使该线程开始执行，Java 虚拟机调用该线程的 run 方法。
  - 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其 run 方法）。
  - 多次启动一个线程是非法的，会报错。特别是当线程已经结束执行后，就不能再重新启动。

java程序属于抢占式调度，哪个线程的优先级高，哪个线程就优先执行；同一个优先级，随机选择一个执行。

```java
public static void main(String[] args) {
    MyThread myThread=new MyThread();
    //如果这里换成run，则和单线程没有区别，即先进行run方法再进行main方法的for循环
    myThread.start();
    for (int j=0;j<100;j++){
        System.out.println("main"+j);
    }
}
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i=0;i<100;i++){
            System.out.println("run"+i);
        }
    }
}
//程序执行的结果:随机性打印
run0
main0
run1
main1
run2
main2
run3
//每次打印的结果都不一样，顺序不一样，run和main交替输出。
```

------

## 4 多线程原理

### 4.1 随机性打印结果

对于上面的代码，程序运行过程是这样的：

JVM执行main方法，找操作系统开辟一条main方法通向cpu的路径，这个路径叫main线程,即主线程。

cpu通过这个线程（路径）可以执行main方法。

```java
MyThread myThread=new MyThread();
//开辟一条通向cpu的新路径，用来执行run方法
    myThread.start();
//执行run方法
```

对于cpu而言,就有了两条执行的路径，cpu就有了选择的权利。

cpu喜欢谁，就会执行哪条路径，我们控制不了cpu。

所有就有了程序的随机打印结果。

两个线程,一个main线程，一个新线程一起抢cpu的执行权(执行时间)

谁抢到了谁就执行对应的代码。

------

### 4.2 多线程内存空间分配

```java
MyThread mt = new MyThread();
mt.run();
mt.start();
new MyThread.start();
```

- 基于以上代码，首先，main方法压栈执行，然后在堆内存中开辟了内存空间，new了一个MyThread对象。之后执行run方法，注意这是单线程（main线程）。
- 执行完run方法后，再执行start方法，此时会开辟新的栈空间，以执行run方法。
- 然后最后一行代码，开辟新的栈空间，以执行run方法。

基于上述步骤，cpu就有了选择的权利，可以执行main方法也可以执行两个run方法。

多比程的好处:多个线程之间互不影响(在不同的栈空间)。

------

## 5 Thread类

### 5.1 获取线程名称的方法

获取线程的名称:

- 方法1.使用Thread类中的方法getName()

  - String getName() 返回该线程的名称。

- 方法2.可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称。

  - static Thread currentThread()

    返回对当前正在执行的线程对象的引用。

```java
public static void main(String[] args) {
    MyThread01 myThread=new MyThread01();
    myThread.start();
    new MyThread01().start();
    new MyThread01().start();
 //链式编程
 System.out.println(Thread.currentThread().getName());
    //输出main
}
```

```java
public class MyThread01 extends Thread{//一定要写继承于Thread
    @Override
    public void run() {
        String name=getName();
        System.out.println(name);
        /*输出
        Thread-0
        Thread-1
        Thread-2
        */

        Thread t=Thread.currentThread();
        System.out.println(t);
        /*输出
        Thread[#33,Thread-2,5,main]
        Thread[#31,Thread-0,5,main]
        Thread[#32,Thread-1,5,main]
        */

        String name1=t.getName();
        System.out.println(name1);
        /*输出
        Thread-1
        Thread-0
        Thread-2
        */
        System.out.println(Thread.currentThread().getName());
        /*输出
        Thread-0
        Thread-2
        Thread-1
        */
    }
}
```

------

### 5.2 设置线程名称的方法

- 1.使用Thread类中的方法setName(名字)
  - void setName(String name) 改变线程名称，使之与参数 name 相同
- 2.创建一个带参数的构造方法,参数传递线程的名称；调用父类的带参构方法，把线程名称传递给父类,让父类(Thread)给子线程起一个名字。
  - Thread(string name) 分配新的 Thread 对象。

```java
public static void main(String[] args) {
    MyThread02 myThread=new MyThread02();
    myThread.setName("小强");
    myThread.start();
    new MyThread02("旺财").start();
}
```

```java
public class MyThread02 extends Thread{
    public MyThread02(){
    }
    public MyThread02(String name){
        super(name);//把线程名称传递给父类,让父类(Thread)给子线程起一个名字
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

------

### 5.6 sleep方法

`public static void sleep(long millis):`

使当前正在执行的线程以指定的秒数暂停(暂时停止执行)。

毫秒数结束之后，线程继续执行。

```java
public static void main(String[] args) {
    for (int i=0;i<100;i++){
        System.out.println(i);
        try {
            Thread.sleep(1000);
            //使用Thread类的sleep方法让程序睡眠1秒钟
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```

------

### 5.7  创建多线程程序的第二种方式

**实现Runnable借口**：

java. lang.Runnable（可以在实现类中设置线程任务）

Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。

java.lang.Thread类的构造方法

- Thread(Runnable target) 分配新的 Thread 对象。
- Thread(Runnable target，String name) 分配新的 Thread 对象。

实现步骤:

- 1.创建一个Runnable接口的实现类
- 2.在实现类中重写Runnable接口的run方法，设置线程任务
- 3.创建一个Runnable接口的实现类对象
- 4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象
- 5.调用Thread类中的start方法,开启新的线程执行run方法

```java
public static void main(String[] args) {
    RunnableImpl run=new RunnableImpl();
    Thread t=new Thread(run);
    t.start();//Runnable接口中没有start方法，因此要用到Thread对象
    for (int i=0;i<20;i++){
        System.out.println(Thread.currentThread().getName()+"-->"+i);
    }
}
```

```java
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        for (int i=0;i<20;i++){
            System.out.println(Thread.currentThread().getName()+"-->"+i);
        }
    }
}
```

执行结果：

```
Thread-0-->0
Thread-0-->1
main-->0
Thread-0-->2
main-->1
Thread-0-->3
main-->2
Thread-0-->4
main-->3
Thread-0-->5
main-->4
Thread-0-->6
main-->5
```

------

### 5.8 Thread和Runnable的区别

如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享，

实现Runnable接口创建多线程程序的好处:

- 1.避免了单继承的局限性
  - 一个类只能继承一个类(一个人只能有一个亲爸)，类继承了Thread类就不能继承其他的类。
  - 实现了Runnoble接口，还可以继承其他的类，实现其他的接口。
- 2.增强了程序的扩展性，降低了程序的耦合性(解耦)。代码可以被多个线程共享，代码和线程独立。
  - 实现Runnable接口的方式，把**设置线程任务**和**开启新线程**进行了分离(解耦)。
  - 在实现类中，重写了run方法: 用来设置线程任务。
  - 创建Thread类对象，调用start方法：用来开新线程。
- 3.适合多个相同的程序代码的线程去共享同一个资源。
- 4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类

> 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。

要多使用第二种方式，少使用第一种方式。

```java
public static void main(String[] args) {
    RunnableImpl run=new RunnableImpl();
    //Thread t=new Thread(run);
    Thread t=new Thread(new RunnableImpl2());
//传递不同的实现类，完成不同的任务
    t.start();
    for (int i=0;i<20;i++){
        System.out.println(Thread.currentThread().getName()+"-->"+i);
    }
}
```

```java
public class RunnableImpl2 implements Runnable{

    @Override
    public void run() {
        for (int i=0;i<20;i++){
            System.out.println("HelloWorld!"+"-->"+i);
        }
    }
}
```

------

### 5.9 匿名内部类方式实现线程的创建

匿名:没有名字

内部类:写在其他类内部的类

匿名内部类的作用:简化代码。

- 把子类继承父类、重写父类的方法、创建子类对象合成一步完成。
- 把实现实现类接口、重写接口中的方法、创建实现类对象合成一步完成。

匿名内部类的最终产物:子类/实现类对象，而这个类没有名字。

格式：

```java
new 父类/接口(){
    重写父类/接口中的方法
};
```

```java
public static void main(String[] args) {
    //线程的父类是Thread
    new MyThread().start();
    //避免创建一个新的子类去继承父类，而是直接用匿名内部类
    new Thread(){
        @Override
        public void run() {
            for (int i=0;i<10;i++){
                System.out.println("你好"+i);
            }
        }
    }.start();

    //接口方法
    //不需要创建实现类
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            for (int i=0;i<10;i++){
                System.out.println("吃了吗"+i);
            }
        }
    };
    new Thread(runnable).start();

    //直接合成写到一起,简化接口的
    new Thread(new Runnable() {
        @Override
        public void run() {
            for (int i=0;i<10;i++){
                System.out.println("你在哪里"+i);
            }
        }
    }).start();
}
```

------

## 6 线程安全

### 6.1 线程安全

#### 6.1.0 概述

单线程程序是不会出现线程安全问题的。

多线程程序，若没有访问共享数据，也不会产生问题。

多线程程序访问了共享的数据，可能会产生线程安全问题。

------

#### 6.1.1 线程安全问题的代码实现

```java
public class RunnableImpl3 implements Runnable{
    private int num=100;
    //设置线程任务:卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            //先判断票是否存在
            if (num>0){
                //提高安全问题出现的率,让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
                num--;
            }
        }
    }
}
```

```java
public class Demo07Ticket {
    public static void main(String[] args) {
        Runnable runnable=new RunnableImpl3();
        Thread t1=new Thread(runnable);
        Thread t0=new Thread(runnable);
        Thread t2=new Thread(runnable);
        Thread t3=new Thread(runnable);
        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
```

```
运行结果：
Thread-2-->正在卖第100张票
Thread-3-->正在卖第100张票
Thread-1-->正在卖第100张票
Thread-0-->正在卖第100张票
Thread-1-->正在卖第0张票
Thread-0-->正在卖第0张票
Thread-3-->正在卖第-2张票
```

注意：

线程安全问题是不能产生的，我们可以让一个线程在访问共享数据的时候,无论是否失去了cpu的执行权，都要让其他的线程只能等待，等待当前线程卖完票，其他线程再进行卖票，以此来保证使用一个线程在卖一张票，而不是使用多个线程来卖同一张票。

------

### 6.2 线程同步

当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题，要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票的问题，Java中提供了同步机制(**synchronized**)来解决。

有三种方式完成同步操作：

- 1.同步代码块
- 2.同步方法
- 3.锁机制

#### 6.2.0 同步代码块

注意：锁对象要创建在run方法之外，防止多个线程创建了多个锁对象，以保证锁对象的唯一性。

卖票案例出现了线程安全问题，卖出了不存在的票和重复的票。

解决线程安全问题的**第一种**方案:使用同步代码块

格式:

```java
synchronized(锁对象){
    可能会出现线程安全问题的代码(访问了共享数据的代码)
}
```

注意：

- 1.通过代码块中的锁对象，可以使用**任意的对象**
- 2.但是必须保证多个线程使用的锁对象是**同一个**
- 3.锁对象作用:把同步代码块锁住，只让一个线程在同步代码块中执行

```java
public class RunnableImpl3 implements Runnable{
    private int num=100;
    Object object=new Object();
    //设置线程任务:卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            synchronized (object){//新增的代码块
                //先判断票是否存在
                if (num>0){
                    //提高安全问题出现的率,让程序睡眠
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
                    num--;
                }else break;
            }
        }
    }
}
```

------

#### 6.2.1 同步技术的原理

**使用了一个锁对象，这个锁对象叫同步锁，也叫对象锁，也叫对象监视器。**

3个线程一起抢夺cpu的执行权，谁抢到了谁就执行run方法进行卖票。

t0抢到了cpu的执行权,执行run方法，遇到synchronized代码块。

这时t0会检查synchronized代码块中是否有锁对象。

发现**有**，就会**获取到锁对象，进入到同步代码块中执行**。

t1抢到了cpu的执行权，执行run方法，遇到synchronized代t码块。

这时t1会检查synchronized代码块中是否有锁对象。

发现没有，t1就会进入到阻塞状态，会一直等待t0线程归还锁对象（出了同步代码块，会自动归还锁对象）。

一直到t0线程执行完同步中的代码，会把锁对象归还给同步代码块。

之后t1才能获取到锁对象进入到同步中执行。

**总结:**同步中的线程,没有执行完毕则不会释放锁对象，同步外的线程没有锁对象则进不去同步。

**优点**：同步保证了只能有一个线程在同步中执行共享数据，保证了安全。

**缺点**：程序频繁的判断锁，获取锁，释放锁，程序的效率会降低。

------

#### 6.2.2 同步方法

解决线程安全问题的**第二种**方案:使用**同步方法**

使用步骤:

- 1.把访问了共享数据的代码抽取出来,放到一个方法中。
- 2.在方法上添加synchronized修饰符。

```java
格式:定义方法的格式
修饰符 synchronized 返回值类型 方法名(参数列表){
    可能会出现线程安全问题的代码(访了共享数据的代码)
}
```

```java
public synchronized void picket(){
    if (num>0){
        //提高安全问题出现的率,让程序睡眠
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
        num--;
    }
}

@Override
public void run() {
    System.out.println(this);
    while (true){
        picket();
    }
}
```

```java
public static void main(String[] args) {
    Runnable runnable=new RunnableImpl4();
    Thread t1=new Thread(runnable);
    Thread t0=new Thread(runnable);
    Thread t2=new Thread(runnable);
    Thread t3=new Thread(runnable);
    System.out.println(runnable);
    t0.start();
    t1.start();
    t2.start();
    t3.start();
}
```

定义一个同步方法

同步方法也会把方法内部的代码锁住，只让一个线程执行。

同步方法的锁对象就是实现类对象 new RunnableImpl()

也就是this。

------

##### 静态同步方法

锁对象不能是this。this是**创建对象之后**产生的，静态方法的执行优先于对象创建。静态方法在创建对象之前就已经进入到内存当中了。

静态方法的锁对象是本类的class属性-->class文件对象(反射)。

```java
public class RunnableImpl5 implements Runnable{
    private static int num=100;

    public static synchronized void picket(){
    //二者选其一即可，既可以用同步代码块+class文件对象，也可以用静态同步方法。
        synchronized (RunnableImpl5.class){
            //注意：这里是无法在static语句中引用this的
            if (num>0){
                //提高安全问题出现的率,让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
                num--;
            }
        }

    }

    @Override
    public void run() {
        System.out.println(this);
        while (true){
            picket();
        }
    }
}
```

------

#### 6.2.3 Lock锁

解决线程安全问题的**第三种**方案:使用**Lock锁**

java.util.concurrent.locks.Locks.Lock 接口

实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。

Lock接口中的方法:

- void lock() 获取锁。
- void unlock() 释放锁。

java.util.concurrent.locks.Reentrantlock implements Lock接口

使用步骤:

- 1.在成员位置创建一个ReentrantLock对象。
- 2.在可能会出现安全问题的代码**前**调用Lock接口中的方法lock获取锁
- 3.在可能会出现安全问题的代码**后**调用Lock接口中的方法unlock释放锁。

方法1：

```java
public class RunnableImpl6 implements Runnable{
    private static int num=100;
    Lock l=new ReentrantLock();
//1.在成员位置创建一个ReentrantLock对象。
    public void picket(){
        l.lock();//获取锁
        if (num>0){
            //提高安全问题出现的率,让程序睡眠
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
            num--;
        }
        l.unlock();//释放锁
    }

    @Override
    public void run() {
        System.out.println(this);
        while (true){
            picket();
        }
    }
}
```

方法2：

```java
public void picket(){
    l.lock();
    if (num>0){
        //提高安全问题出现的率,让程序睡眠
        try {
            Thread.sleep(10);
            System.out.println(Thread.currentThread().getName()+"-->正在卖第"+num+"张票");
            num--;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }finally {
            l.unlock();//无论程序是否异常,都会把锁释放
        }
    }
    //l.unlock();
}
```

------

## 7 线程状态

### 7.1 概述

线程状态。线程可以处于下列状态之一：

- NEW

  - 新建状态

  - 至今尚未启动的线程处于这种状态。

  - 例如：

  - new Therad();
    new Thread子类();

  - 在NEW状态下执行start()方法后，如果有cpu执行时间（cpu有空闲）则进入运行状态(Runnable)；

    若cpu没有执行时间，则进入阻塞状态(BLOCKED)。

- RUNNABLE

  - 正在 Java 虚拟机中执行的线程处于这种状态。
  - 运行状态。
  - 在RUNNABLE状态下，调用Object.wait()方法（**空参数**），可以使线程进入WAITING状态；若有参数(long)，则进入TIMED_WAITING状态。
  - 在RUNNABLE状态下，调用sleep(long)方法，可以是线程进入TIMED_WAITING状态。
  - 在RUNNABLE状态下，当run()方法结束后或者使用stop()方法后，线程会自动进入TERMINATED状态，

- BLOCKED（锁阻塞状态）

  - 受阻塞并等待某个监视器锁的线程处于这种状态。
  - 阻塞状态:具有cpu的执行资格,等待cpu空闲时执行。
  - 若获取到了锁对象则进入RUNNABLE状态；若没有获取到锁对象，则进入BLOCKED状态。

- WAITING

  - 无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。
  - 无限(永久)等待状态
  - 在该状态下调用Object.notify()方法，若cpu不空闲，则进入阻塞状态BLOCKED；若cpu空闲，则进入运行状态RUNNABLE。
  - 需要调用方法来唤醒，不能自动唤醒。

- TIMED_WAITING

  - 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。
  - 休眠（睡眠）状态:放弃cpu的执行资格，即使cpu空闲，也不执行
  - 计时等待，可以自动唤醒，不需要调用其他方法来唤醒。
  - 休眠结束后，若cpu不空闲，则线程进入BLOCKED状态；若cpu空闲，则线程进入RUNNABLE状态。

- TERMINATED

  - 已退出的线程处于这种状态（被终止的状态）。
  - 死亡状态。

在给定时间点上，**一个线程只能处于一种状态**。这些状态是虚拟机状态，它们并没有反映所有操作系统线程状态。

注意：

- 处于**运行状态**(Runnable)和阻塞状态(BLOCKED)的多个线程之间相互抢夺cpu的执行时间。
- 冻结状态：
  - TIMED WAITING休眠(睡眠)状态
  - WAITING无限(永久)等待状态

------

### 7.2 等待唤醒案例代码实现

等待唤醒案例:线程之间的通信。

- 创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法，放弃cpu的执行时间，进入到WAITING状态(无限等待)
- 创建一个老板线程(生产者):花了5秒做包子，做好包子之后,调用notify方法,唤醒顾客吃包子。

注意:

顾客和老板线程必须使用同步代码块包裹起来，保证处于等待或唤醒的线程只能有一个在执行。

同步使用的锁对象必须保证唯一。

**只有锁对象**才能调用wait和notify方法。

Obejct类中的方法

void wait()：

- 在其他线程调用此对象的 notify() 方法或 notfyAll() 方法前，导致当前线程等待。

void notify()

- 唤醒在此对象监视器上等待的单个线程。会继续执行wait方法之后的代码。

注意：

Object类对象可以调用wait方法，无论有无参数都可以。

但是前提条件是，wait方法一定要在同步代码块中执行，如果没有同步代码块，没有锁对象，则会报错。

Exception in thread "Thread-1" java.lang.IllegalMonitorStateException: current thread is not owner

与此不同的是，sleep方法可以在任何位置调用，无需在同步代码块中执行，直接用Thread类名调用即可。

```java
public static void main(String[] args) {
    //创建锁对象，保证唯一
    Object obj=new Object();
    //创建一个顾客线程(消费者)
    new Thread(){
        @Override
        public void run() {
            while (true){
                //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
                synchronized (obj){
                    System.out.println("告知老板想要的包子的种类和数量");
                    //调用wait方法，放弃cpu的执行，进入到WAITING状态(无限等待)
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    //唤醒之后的代码
                    System.out.println("真好吃");
                }
            }
        }
    }.start();

    //创建一个老板线程(生产者)
    new Thread(){
        @Override
        public void run() {
            while (true){
                //花了5秒做包子
                try {
                    Thread.sleep(5000);
                    //obj.wait(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
                synchronized (obj){
                    System.out.println("老板5秒钟后做好了包子，告知顾客可以吃包子了。");
                    obj.notify();
                }
            }
        }
    }.start();
}
```

------

### 7.3  Object类中notify方法和notifyAll方法

进入到TimeWaiting(计时等待)有两种方式

- 1.使用sleep(long m)方法,在毫秒值结束之后,线程被唤醒然后进入到Runnable/BLocked状态
- 2.使用wait(long m)方法,wait方法加果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable或Blocked状态。

唤醒的方法:

- void notify() 唤醒在此对象监视器上等待的**单个**线程。
- void notifyAll() 唤醒在此对象监视器上等待的**所有**线程。

```java
public static void main(String[] args) {
    //创建锁对象，保证唯一
    Object obj=new Object();
    //创建一个顾客线程(消费者)
    new Thread(){
        @Override
        public void run() {
            while (true){
                //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
                synchronized (obj){
                    System.out.println("顾客1告知老板想要的包子的种类和数量");
                    //调用wait方法，放弃cpu的执行，进入到WAITING状态(无限等待)
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    //唤醒之后的代码
                    System.out.println("顾客1说真好吃");
                    System.out.println("----------------------");
                }
            }
        }
    }.start();

    //创建一个顾客线程(消费者)
    new Thread(){
        @Override
        public void run() {
            while (true){
                //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
                synchronized (obj){
                    System.out.println("顾客2告知老板想要的包子的种类和数量");
                    //调用wait方法，放弃cpu的执行，进入到WAITING状态(无限等待)
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    //唤醒之后的代码
                    System.out.println("顾客2说真好吃");
                    System.out.println("----------------------");
                }
            }
        }
    }.start();

    //创建一个老板线程(生产者)
    new Thread(){
        @Override
        public void run() {
            while (true){
                //花了5秒做包子
                try {
                    Thread.sleep(2000);
                    //obj.wait(5000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
                synchronized (obj){
                    System.out.println("老板5秒钟后做好了包子，告知顾客可以吃包子了。");
                    obj.notify();//如果有多个等待线程,随机唤醒一个
                    //obj.notifyAll();//唤醒所有等待的线程
                }
            }
        }
    }.start();
}
```

------

## 8 等待唤醒机制

### 8.1 线程间通信

概念:多个线程在处理同一个资源，但是处理的动作（线程的任务 ）却不相同。

比如:线程A用来生产包子的，线程B用来吃包子的，包子可以理解为**同一资源**，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

**为什么要处理线程间通信** :

多个线程并发执行时,在默认情况下CPU是**随机切换线程**的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。

**如何保证线程间通信有效利用资源**:

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，邀免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— **等待唤醒机制**。

------

### 8.2 等待唤醒机制

等待唤醒机制是多个线程间的一种”**协作**”机制。谈到线程我们经常想到的是线程间的**竞争**(race)，比如去争夺锁。线程间也会有**协作**机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。

在一个线程进行了规定操作后，就进入等待状态( wait )，等待其他线程执行完他们的指定代码过后，再将其唤醒( notify());在有多个线程进行等待时，如果需要，可以使用 notifyAll()来唤醒所有的等待线程。

wait/notify 就是线程间的一种协作机制。

等待唤醒中的方法

等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下:

- 1.wait:线程不再活动，不再参与调度，进入 wait set （一个集合）中，因此不会浪费 CPU 资源，也不会去竞争锁了。这时的线程状态即是 WAITING，它还要等着别的线程执行一个**特别的动作**，也即是“**通知**(notify)"在这个对象上等待的线程从walt set 中释放出来，重新进入到调度队列( ready queue)中。
- 2.notify : 选取所通知对象的 wait set 中的一个线程释放:例如，餐馆有空位置后，等候就最久的顾客最先入座。
- 3.notifyAll : 释放所通知对象的 wait set 上的全部线程

> 注意：
>
> 哪怕只通知了一个等待的线程，被通知线程也**不能立即恢复执行**，因为它当初中断的地方是在同步块内，而此刻它已经**不持有锁**，所以她需夏再次尝试去**获取锁**( 很可能面临与其它线程的竟争 )，成功后才能在当初调用wait方法之后的地方恢复执行。
>
> 总结如下：
>
> - 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态
> - 否则，从 wait set 出来，又进入 entry set，线程就从WAITING 状态又变成 BLOCKED 状态

调用wait和notify方法需要注意的细节

- 1.wait方法与notify方法必须要**由同一个锁对象调用**。

  因为:对应的锁对象可以通过notify唤醒使用同一个锁对象 调用wait方法后的线程。

- 2.wait方法与notify方法是属于Object类的方法的。因为:锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。

- 3.wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为:必须要通过锁对象调用这2个方法。

**重点：有效利用资源。**

------

### 8.3 等待唤醒机制需求分析

等待唤醒机制：线程之间的通信

重点:有效利用资源(生产一个包子,吃一个包子,再生产一个包子,再吃一个包子····)

通信:对包子的状态进行判断

没有包子-->吃货线程唤醒包子铺线程-->吃货线程等待-->包子铺线程做包子-->做好包子-->修改包子的状态为**有**。

**有包子**-->包子铺线程唤醒吃货线程-->包子铺线程等待-->吃货吃包子-->吃完包子-->修改包子的状态为**没有**。

**没有包子**-->吃贷线程唤醒包子铺线程-->吃货线程等待-->包子铺线程做包子-->做好包子-->修改包子的状态为**有**。

------

- 资源类：包子类

  设置包子的属性

  - 皮
  - 陷
  - 包子的状态: 有 true,没有 false

- 生产者(包子铺)类:是一个线程类,可以继承Thread

  设置线程任务(run):生产包子

  对包子的状态进行判断

  true:有包子

  - 包子铺调用wait方法进入等待状态。

  false:没有包子

  - 包子铺生产包子。
  - 增加加一些趣味性:交替生产两种包子。
    - 有两种状态(i%2==0)
  - 包子铺生产好了包子
  - 修改包子的状态为true有
  - 唤醒吃货线程，让吃货线程吃包子。

- 消费者(吃货)类：是一个线程类，可以继承Thread

  设置线程任务(run):吃包子

  对包子的状态进行判断

  false:没有包子

  - 吃货线程调用wait方法进入等待状态

  true:有包子

  - 吃贷吃包子
  - 吃货吃完包子
  - 修改包子的状态为false没有
  - 吃货唤醒包子铺线程,生产包子。

- 测试类：

  - 包念main方法，程序执行的入口，启动程序。
  - 创建包子对象: 创建包子铺线程，开启: 创建吃货线程，开启。

------

### 8.4 等待唤醒机制代码实现

注意：

- 包子铺线程和包子线程关系-->通信(互斥)

  必须同时使用同步技术保证两个线程只能有一个在执行

  锁对象必须保证唯一,可以使用包子对象作为锁对象

  包子铺类和吃货的类就需要把包子对象作为参数传递进来

  - 1.需要在成员位置创建一个包子变量
  - 2.使用带参数构造方法,为这个包子变量赋值

包子类：

```java
public class Baozi {
    String pi;//皮
    String xian;//馅
    boolean flag=false;//有没有包子
}
```

吃货类：

```java
public class ChiHuo extends Thread{
    //1.需更在成员位置创建一个包子变量
    private Baozi baozi;
    public ChiHuo(Baozi baozi){
        this.baozi=baozi;
    }
    //设置线程任务(run):吃包子

    @Override
    public void run() {
        //使用死循环，让吃货一直吃包子
        while (true){
            //必须同时使用同步技术保证两个线程只能有一个在执行
            synchronized (baozi){
                //对包子的状态进行判断
                if (!baozi.flag){
                    //吃货调用wait方法进入等待状态
                    try {
                        baozi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //被唤醒之后执行的代码,吃包子
                System.out.println("吃货正在吃:"+baozi.pi+baozi.xian+"包子");
                //吃货吃完包子
                // 修改包子的状态为false没有
                baozi.flag =false;
                //吃货唤醒包子铺线程，生产包子
                baozi.notify();
                System.out.println("吃货已经把:"+baozi.pi+baozi.xian+"包子吃完了,包子铺开始生产包子");
                System.out.println("-------------------------------");

            }
        }
    }
}
```

包子铺类：

```java
public class BaoZiPu extends Thread{
    //1.满要在成员位贫创建一个包子变量
    private Baozi baozi;

    //2.使用带参数构造方法,为这个包子变量赋值
    public BaoZiPu(Baozi baozi){
        this.baozi=baozi;
    }
    //设置线程任务(run):生产包子

    @Override
    public void run() {
        //定义一个变量
        int count=0;
        //让包子铺一直生产包子
        while (true){
            synchronized (baozi){
                //对包子的状杰进行判斯
                if (baozi.flag){
                    //包子铺调用wit方法进入等待状态
                    try {
                        baozi.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //被唤醒之后执行，包子铺生产包子
                // 增加一些趣味性:交替生产两种包子
                if (count%2==0){
                    //生产 薄皮三鲜馆包子
                    baozi.pi="薄皮";
                    baozi.xian="三鲜";
                }else {
                    baozi.pi="冰皮";
                    baozi.xian="牛肉大葱";
                }
                count++;
                System.out.println("包子铺正在生产:"+baozi.pi+baozi.xian+"包子");
                //生产包子需要3秒钟
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //包子铺位生产好了包子
                // 修改包子的状态为true有
                baozi.flag=true;
                //唤醒吃货线程，让吃贷线程吃包子
                baozi.notify();
                System.out.println("包子铺已经生产好了"+baozi.pi+baozi.xian+"包子");
            }
        }
    }
}

```

测试类：

```java
public class Test {
    public static void main(String[] args) {
        //创建包子对象
        Baozi baozi=new Baozi();
        //创建包子铺线程，开启，生产包子。
        new BaoZiPu(baozi).start();
        //创建吃货线程，开启，吃包子。
        new ChiHuo(baozi).start();
    }
}
```

------

## 9 线程池

### 9.1 线程池思想概述

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

在Java中可以通过线程池可以使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务。

------

### 9.2 线程池概念

**线程池**：其实就是一个容纳多个线程的容器（相当于一个集合），其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

线程池中有很多操作都是与优化资源相关的。

```java
LinkedList<Thread> list=new LinkedList();
list.add(new Thread(xxx));
list.add(new Thread(xxx));
list.add(new Thread(xxx));
//这是一个队列
```

当程序第一次启动的时候，要创建多个线程，保存到一个集合中。

当我们想要使用线程的时候，就可以从集合中取出线程来使用。

`Thread t = list.remove(0);`返回的是被移除的(0号)元素(线程只能被一个任务使用)

`Thread t = list.removeFist();`

当我们使用完毕线程，需要把线程归还给线程池。

`list.add(t);`

`list.addLast(t);`

在JDK1.5之后，JDK内置了线程池，我们可以直接使用。

合理利用线程池能够带来三个好处:

- 1.降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
- 2.提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 3.提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

若线程池中已无空闲线程，任务等待执行，等待其他某个任劳执行完毕后，归还线程到线程池，再从线程池中获取线程，执行任务。

------

### 9.3 线程池的代码实现

java里面线程池的顶级接口是 `java.util.concurrent.Executor` ，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。

真正的线程池接口是 `java.util.concurrent.ExecutorService`。

要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在 `java.util.concurrent.Executors` 线程工厂类用面提供了一些静态工厂，用来生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。

Executors类中有个创建线程池的方法如下 :

`public static ExecutorService newFixedThreadPool(int nThreads)` :

- 创建一个可重复使用的固定线程数的线程池，返回线程池对象。(创建的是有界线程池，也就是池中的线程个数可以指定最大数量)
- 参数：int nThreads:创建线程池中包含的线程数量
- 返回值：ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程)

java.util.concurrent .ExecutorService:线程池接口，用来从线程池中获取线程,调用start方法,执行线程任务。

 submit(Runnable task) 提交一个 Runnable 任务用于执行。

关闭/销线程池的方法：

`void shutdown();`

获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：

`public Future<?> submit(Runnable task)` :获取线程池中的某一个线程对象，并执行。

> Future接口: 用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤:

- 1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池，创建线程池对象。
- 2.创建一个类,实现Runnable接口,重写run方法,创建Runnable接口子类对象。设置线程任务(task)
- 3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法。(take task)
- 4.调用ExecutorService中的方法shutdown销毁线程池(一般不建议执行)。

```java
public static void main(String[] args) {
    ExecutorService es= Executors.newFixedThreadPool(2);
    es.submit(new RunnableImpl());
    //线程池会一直开启，使用完了线程，会自动把线程归还给线程池,线程可以继续使用
    es.submit(new RunnableImpl());
    es.submit(new RunnableImpl());
    es.submit(new RunnableImpl());
    es.shutdown();
    es.submit(new RunnableImpl());//抛异常,线程池都没有了,就不能获取线程了
}
```

```java
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"创建了一个新的线程");
    }
}
```

------

# 二、 Lambda表达式

## 1 函数式编程思想概述

在数学中，**函数**就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象**过分强调**”必须**通过对象的形式**来做事情”，而函数式思想则尽量**忽略面向对象**的复杂语法一一强调做什么，而不是以什么形式做。

面向对象的思想:

做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.

函数式编程思想:

只要能获取到结果,谁去做的,怎么做的都不重要,**重视的是结果,不重视过程**。

------

## 2 冗余的Runnable代码

对于 Runnable 的匿名内部类用法，可以分析出几点内容 :

- Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的**核心**;
- 为了指定 run 的方法体，**不得不**需要 Runnable 接口的实现类；
- 为了省去定义一个 RunnableImpl 实现类的麻烦，**不得不**使用匿名内部类;
- 必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；
- 而实际上，**只有方法体才是关键所在**。

------

## 3 编程思想的转换——Lambda的更优写法

我们为了完成某件事情而不得不创建一个对象。我们真正希望做的事情是:将 run 方法体内的代码传递给 Thread 类知晓。

**传递一段代码**一一这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。

如果我们将关注点从“怎么做”回归到”做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。

Runnable 接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效:

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"新线程创建了");
    }
}).start();
```

```java
new Thread(()->{
        System.out.println(Thread.currentThread().getName()+"新线程创建了");
    }
).start();
```

这段代码和刚才的执行效果是完全一样的，可以在jdk1.8或更高的编译级别下通过。从代码的语义中可以看出:我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。

不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担。

------

### 3.1 Lambda的标准格式

Lambda表达式的标准格式:

由三部分组成:

- 一些参数
- 一个箭头
- 一段代码

格式:

(参数列表) ->(一些重写方法的代码)；

解释说明格式:

- ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔
- ->:传递的意思,把前面参数传递给方法体{}
- {}:重写接口的抽象方法的方法体, 该方案的具体执行步骤。

------

####  练习（无参数无返回值）

给定一个厨子cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦!“字样

```java
public static void main(String[] args) {
    //参数是Cook接口,传递Cook接口的匿名内部类对象
    cooking(new Cook(){
        @Override
        public void makeFood() {
            System.out.println("吃饭了");
        }
    });
    //Lambda
    cooking(()->{
        System.out.println("吃饭了");
    });
}

public static void cooking(Cook cook){
    cook.makeFood();
}
```

```java
public interface Cook {
    void makeFood();
}
```

------

#### 练习（有参数有返回值）

使用数组存储多个Person对象

对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序

```java
public static void main(String[] args) {
    Person[] arr={
            new Person("jim",18),
            new Person("bobby",19),
            new Person("jane",17)
    };
    Arrays.sort(arr, new Comparator<Person>() {
        @Override
        public int compare(Person o1, Person o2) {
            return o2.getAge()-o1.getAge();
        }
    });
    for (Person person:arr){
        System.out.println(person);
    }
    Arrays.sort(arr,(Person o1,Person o2)->{
        return o1.getAge()-o2.getAge();
    });
    for (Person person:arr){
        System.out.println(person);
    }
}
```

------

Lambda表达式有参数有返回值的练习要求:

给定一个计算器calculator接口，内含抽象方法calc，可以将两个int数字相加得到和值。使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算。

```java
public static void main(String[] args) {
    invokeCalc(20, 30, new Calculator() {
        @Override
        public int calc(int a, int b) {
            return a+b;
        }
    });
    
    invokeCalc(120,130,(int a,int b)->{
        return a+b;
    });
}
public static void invokeCalc(int a,int b,Calculator calculator){
    System.out.println(calculator.calc(a,b));
}
```

```java
public interface Calculator {
    public abstract int calc(int a, int b);
}
```

------

## 4 Lambda省略格式

Lambda表达式:是可以推导,可以省略的。

凡是根据上下文推导出来的内容，都可以省略书写。

可以省略的内容:

- 1.(参数列表):括号中参数列表的数据类型,可以省略不写

- 2.(参数列表):括号中的参数如果只有一个，那么类型和()都可以省略。

- 3.(一些代码)：如果()中的代码**只有一行**,无论是否有返回值,都可以省略({},return,分号)

  注意:要省略(),return,分号必须一起同时省略。

```java
//JDK1.7版本之前,创建集合对象必须把前后的泛型都写上
ArrayList<String> list =new ArrayList<String>();

//JDK1.7版本之后，=号后边的泛型可以省略。后边的泛型可以根据前边的泛型推导出来
ArrayList<String> list2  =new ArrayList<>();
```

```java
new Thread(()->{
    System.out.println();
}).start();
//优化省略Lambda
new Thread(()->System.out.println()).start();

Arrays.sort(arr,(Person o1，Person o2)->{
    return o1.getage()-02.getage();
});
//优化省略Lambda
Arrays.sort(arr,(o1,o2)->o1.getage()-02.getage());

invokeCalc(120,130,(int a,int b)->{
    return a+b;
});
//优化省略Lambda
invokeCalc(120,130,(a,b)->a+b);
```



------

## 5 Lambda使用前提

Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意:

- 1.使用Lambda**必须具有接口**，且要求接口中**有且仅有一个抽象方法**。

  无论是JDK内置的 Runnable、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法**存在且唯一**时，才可以使用Lambda.

- 2.使用Lambda必须具有**上下文推断**。

  也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例.

> 备注:有且仅有一个抽象方法的接口，称为“函数式接口”