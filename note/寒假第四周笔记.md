# 一、File类

## 1  概述

`java.io.Files`类

文件和目录路径名的抽象表示形式。

java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作。

我们可以使用File类的方法来完成以下功能：

* 创建一个文件/文件夹
* 删除文件/文件夹
* 获取文件/文件夹
* 判断文件/文件夹是否存在
* 对文件夹进行遍历
* 获取文件的大小

File类是一个与系统无关的类,任何的操作系统（如Windows或Linux）都可以使用这个类中的方法。

**重点**:记住这三个单词：

file:文件

directory:文件夹/目录

path;路径

---

## 2 File类的静态成员变量

`static String pathSeparator` 

与系统有关的路径分隔符，为了方便，它被表示为一个字符串。

---

`static char pathSeparatorChar` 

与系统有关的**路径分隔符**。

Windows为分号;

Linux为冒号:

---

`static String separator` 

与系统有关的默认名称分隔符，为了方便，他被表示为一个字符串。

这其实也是文件（夹）名称分隔符

Windows为反斜杠\

* **注意**：反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠

Linux为正斜杠/

---

`stattc char separatorChar` 

与系统有关的默认名称分隔符。

---

注意：操作路径不能写死了

在Windows下： C:\develop\a\a.txt

在Linux下：C:/develop/a/a.txt

正确的写法应该是：

`"C:"+File.separator+"develop"+File.separator+"a"+File.separator+"a.txt"`

---

## 3 绝对路径和相对路径

绝对路径:是一个完整的路径，是以盘符(c:,D: )开始的路径。

`c:\\a.txt`

`C:\\Users\\itcast\\ideaprojects\\shungyuan\\123.txt`

`D:\\demo\\b.txt`

相对路径:是一个简化的路径

* 相对，指的是相对于**当前项目的根目录**

  如`C: \\users\\itcastl\\IdeaProjects\\shungyuan`

  如果使用当前项目的根目录,路径可以简化书写

* `C:\\Users\\itcast\\IdeaProjects\\shungyuan\\123.txt`-->简化为: 

  123.txt(可以省略项目的根目录)

注意：

* 1.路径是不区分大小写的。

---

## 4 File类的构造方法

* `File(String pathname)`

  通过将给定路径名字符串转换为抽象路径名来创建一个新File 实例。

* 参数：

  * String pathname:字符串的路经名称
  * 路径可以是以文件结尾，也可以是以文件夹结尾
  * 路径可以是相对路径,也可以是绝对路径
  * 路径可以是存在的，也可以是不存在的。
  * 创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况。

* 例如：

  ```java
  public static void method01(){
      File file1=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt");
      System.out.println(file1);
      File file2=new File("c:\\Users\\itcast\\IdeaProjects\\shungyuan");
      System.out.println(file2);
      File file3=new File("b.txt");
      System.out.println(file3);
  }
  //注意：输出时是只有一个反斜杠的。
  ```

  ----

* `File(String parent，string child)` 

  根据 parent 路径名字和 child 路经名字行串创建一个新 File 实例。

  参数:把路径分成了两部分

  * String parent:父路径
  * String child:子路径

  好处:

  父路径和子路径可以单独书写,使用起来非常灵活;

  父路径和子路径都可以变化。

  ```java
  public static void main(String[] args) {
      method02("C:\\","a.txt");
  }
  ```

  ```java
  public static void method02(String parent,String child){
      File file=new File(parent,child);
      System.out.println(file);
  }
  ```

  ---

* File(File parent，String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。

* 参数:把路径分成了两部分

  File parent:父路径

  String child:子路经

* 好处:

  父路径和子路径,可以单独书写,使用起来非常灵活。

  父路径和子路径都可以变化。

  父路径是File类型，可以使用File的方法对路径进行一些操作,再使用路径创建对象。

* ```java
  public static void method03(){
      File parent=new File("C:\\");
      File file=new File(parent,"hello");
      System.out.println(file);
  }
  ```

---

## 5 File类的常用方法

### 5.1 File类获取功能的方法

`public String getAbsolutePath()` : 

返回此File的绝对路径名字符串。

获取的是构造方法中传递的路径。

无论传入的路径是绝对的还是相对的，getAbsolutePath方法返回的都是绝对路径。

传入的是相对路径，则输出的绝对路径默认为当前项目的根目录+相对路径。

```java
private static void method01() {
    File file=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt");
    String file1=file.getAbsolutePath();
    System.out.println(file1);
    File file2=new File("a.txt");
    String file3=file2.getAbsolutePath();
    System.out.println(file3);
}
```

输出结果：

```
C:\Users\itcast\IdeaProjects\shungyuan\a.txt
C:\Users\Wingfung Hung\Desktop\debug\computer\java\hello world\a.txt
```

a.txt位于hello world项目的根目录下。

---

`public String getPath()` :将此File转换为路径名字符串。获取的是构造方法中传递的路径。

File类对象的toString方法调用的就是getPath方法源码:

```java
public String tostring() {
    return getPath();
}
```

getPath方法返回的就是new一个File类对象时传入File类的参数，传入的是绝对路径，返回的就是绝对路径；传入的是相对路径，返回的就是相对路径。

```java
private static void method02() {
    File file=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt");
    String file1=file.getPath();
    System.out.println(file1);
    File file3=new File("a.txt");
    String file2=file3.getPath();
    System.out.println(file2);
}
```

运行结果：

```
C:\Users\itcast\IdeaProjects\shungyuan\a.txt
a.txt
```

---

`public String getName()` :

返回由此File表示的文件或目录的名称。

获取的就是构造方法传递路径的结尾部分(文件/文件夹)

```java
private static void method03() {
    File file=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt");
    String file1=file.getName();
    System.out.println(file1);
    File file2=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan");
    String file3=file2.getName();
    System.out.println(file3);
}
```

运行结果：

```
a.txt
shungyuan
```

---

`public long length()`：返回由此File表示的文件的长度。

获取的是构造方法指定的文件的大小，以字节为单位。

注意:

* 文件夹是没有大小概念的,不能获取文件夹的大小。
* 如果构造方法中给出的路径不存在,那么length方法返回0

```java
private static void method04() {
    File file=new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt");
    long file1=file.length();
    System.out.println(file1);
    File file2=new File("G:\\3122004946\\1");
    long file3=file2.length();
    System.out.println(file3);
    File file4=new File("G:\\3122004946\\book.txt");
    long file5=file4.length();
    System.out.println(file5);
}
```

运行结果：

```
0//不存在的文件
0//传入文件夹名
180//传入存在的文件名
```

注意：传入文件夹名时可能输出结果有几种情况。

* 1.输出4096。
  * 可能的原因1：文件夹也要记录本身的信息和自身下面的文件和文件夹的信息，4096应该是划分硬盘时最小扇区大小。
  * 可能的原因2：操作系统文件有最小单位的簇，你的操作系统1簇就是4096， 所以当你文件小于等于4096的时候大小就是4096。
* 2.输出0。

---

### 5.2 File类判断功能的方法

`public boolean exists()` : 此File表示的文件或目录（文件夹）是否实际存在。用于判断构造方法中的路径是否存在。

* 存在:true
* 不存在:false

用法：直接在newFile类对象时传入路径，再用对象名.exists()即可。

---

`public boolean isDirectory()` :

此File表示的是否为目录。

用于判断构造方法中给定的路径是否以**文件夹**结尾

* 是:返回true
* 否:返回false

---

`public boolean isFile()` : 此FiLe表示的是否为文件。

用于判断构造方法中给定的路径是否以**文件名**结尾。

* 是:返回true
* 否:false

注意:

电脑的硬盘中只有文件/文件来，这两个方法（isDirectory和isFile）是互斥的，前提是：这两个方法使用的路径必须是存在的，否则都返回false。

建议：

可以使用if语句搭配exists方法，然后在if语句中加上上述两个方法，就可以体现出互斥了，一个输出true，另一个输出false。

---

### 5.3 File类创建删除功能的方法

public boolean createNewFile() : 当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。

创建文件的路径和名称在构造方法中给出(构造方法的参数)（可以是绝对路径，也可以是相对路径）

返回值:布尔值

* true:文件不存在，创建文件,返回true
* false:文件存在，不会创建，返回false

注意:

* 1.此方法只能创建文件，不能创建文件夹
* 2.创建文件的路径必须存在,否则会抛出异常。不要尝试用这个方法去创建一个不存在的文件夹。

`public boolean createNewFile() throws IOException`

createNewFile声明批出了IOException,我们调用这个方法,就必须的处理这个异常,要么throws,要么try...catch

```java
private static void method01() throws IOException {
    File file=new File("1\\a.txt");//1这个文件夹不存在，抛出异常，改成a.txt就对了。
    boolean b1=file.createNewFile();
    System.out.println(b1);
}
```

注意：

```java
File file=new File("c:\\新建文件夹");
//不要被文件名迷惑，要看其真实的类型。
//这样也只是新建一个名为“新建文件夹”的文件，没有文件类型（后缀），但其实他是一个文件而不是一个文件夹。
```

---

`public boolean mkdir()` :

创建单级空文件夹。

返回值:布尔值

- true:文件夹不存在,创建文件夹,返回true
- false:文件夹存在,不会创建,返回false;构造方法中给出的路径不存在也返回false。如果输入多级文件夹也返回false。

---

`public boolean mkdirs()` : 

既可以创建单级空文件夹也可以创建多级文件夹。

创建文件夹的路径和名称在构造方法中给出(构造方法的参数)

返回值:布尔值

* true:文件夹不存在,创建文件夹,返回true
* false:文件夹存在,不会创建,返回false;构造方法中给出的路径不存在也返回false

注意:

* 1.此方法只能创建文件夹，不能创建文件

```java
private static void method02() {
    File file=new File("aaa");
    boolean b1=file.mkdir();//建立单级文件夹
    System.out.println(b1);

    File file1=new File("aaa\\111\\222\\333");
    boolean b2=file1.mkdir();//不能建立多级文件夹
    System.out.println(b2);

    boolean b3=file1.mkdirs();//建立多级文件夹
    System.out.println(b3);

    File file2=new File("aaa\\1.txt");//建立一个名为1.txt的文件夹
    boolean b4=file2.mkdir();//看后缀名好像是一个文件，实际上是一个文件夹
    System.out.println(b4);

    File file3=new File("a\\abc");//建立一个名为1.txt的文件夹
    boolean b5=file3.mkdir();//这个方法不能创建多级文件夹
    boolean b6=file3.mkdirs();//加上s就可以了
    System.out.println(b5);
}
```

---

`public boolean delete()` :除由此File表示的文件或目录

此方法,可以删除构造方法路径中给出的文件/文件夹

返回值:布尔值t

* rue:文件/文件夹删除成功,返回true
* false:文件夹中有内容,不会删除，返回false;构造方法中的路径不存在，返回false。

注意：

delete方法是直接在硬盘删除文件/文件夹，不会放进回收站，删除要谨慎。

```java
private static void method03() {
    File file=new File("aa\\abc");
    boolean b1=file.delete();
    System.out.println(b1);
    File file1=new File("a.txt");
    boolean b2=file1.delete();
    System.out.println(b2);
}
```

---

### 5.4 File类遍历

`public String[] list()` : 

返回一个String数组，表示该File目录中的所有子文件或目录。

遍历构造方法中给出的目录，会获取目录中所有文件/文件夹的名称,把获取到的多个名称存储到一个String类型的数组中。

```java
private static void method() {
    File file=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world");
    File file1=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello");//NullPointerException
    File file2=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world\\test.txt");//NullPointerException
    String[] strings1=file2.list();
    for (String str:strings1){
        System.out.println(str);
    }
}
```

---

`public File[] listFiles()` : 

返回一个File数组，表示该File目录中的所有的子文件或目录。

遍历构造方法中给出的目录,会获取目录中所有的文件/文件夹,把文件/文件夹封装为File对象,多个File对象存储到File数组中。

```java
private static void method01() {
    File file=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world");
    File[] files=file.listFiles();
    for (File f:files){
        System.out.println(f);
    }
}
```

注意:

* List方法和ListFlles方法遍历的是构造方法中给出的目录。
* 如果构造方法中给出的目录的路径不存在，会抛出空指针异常
* 如果构造方法中给出的路径不是一个目录，也会抛出空指针异常。
* 即使是隐藏了的文件或文件夹，也会被输出。

---

### 5.5 递归打印多级目录

练习:

递归打印多级目录

需求:

遍历当前项目的根目录文件夹，以及根目录下的所有子文件夹和文件。

```java
public static void main(String[] args) {
    File file=new File("");
    File str=file.getAbsoluteFile();
    getALLFiLe(str);
}

private static void getALLFiLe(File dir) {
    System.out.println(dir);
    File[] files=dir.listFiles();
    for (File file:files){
        //对遍历得到的File对象f进行判断，判断是否是文件央
        if (file.isDirectory()){
            //file是一个文件夹，则继续遍历这个文件央
            //我们发现getALLFiLe方法就是传遇文件来，遍历文件夹的方法
            //所以直接调用getALLFiLe方法即可:递归(自己调用自己)
            getALLFiLe(file);
        }
        else {
            //file是一个文件，直接打印即可
            System.out.println(file);
        }
    }
}
```

---

### 5.6 文件搜索

```java
//将上述代码的“System.out.println(dir);”删除，且只改变else代码块中的内容。

else {
    //只要.java结尾的文件
    // 1.把File对象file,转为字符串对象
    //string name =f.getName();//abc.java
    //string path =f.getPath();//c:\\abc\\abc.java
    String s = file.toString();//c:\\abc\\abc.java

    //把字符串,转换为小写。如果后缀名有大写则会忽略大写的文件。
    s=s.toLowerCase();

    //2.调用String类中的方法endsWith判断字符串是否是以.java结尾
    boolean b=s.endsWith(".java");

    //3.如果是以.java结尾的文件,则输出
    if (b){
        //file是一个文件，直接打印即可
        System.out.println(file);
    }
    
    //链式编程
    if (file.toString().toLowerCase().endsWith(".java")) System.out.println(file);
}
//最终可以得到所有.java后缀的文件。
```

---

### 5.7 FileFilter过滤器的原理和使用

查找所有.java后缀的文件，可以使用过滤器来实现

在FiLe类中有两个和ListFiles重载的方法，方法的参数传递的就是过滤器。

`File[ ] listFiles(FileFilter filter)`

java.io.FileFilter接口:

* 用于抽象路径名(File对象)的过滤器

  * 作用:用来过滤文件(FiLe对象)

    抽象方法:用来过滤文件的方法

    `boolean accept(File pathname)` 测试指定抽象路径名是否应该包含在某个路径名列表中

    * 参数:

      `File pathname`:使用ListFiles方法遍历目录，得到的是每一个文件对象。

`File[ ] listFiles(FilenameFilter filter)`

javo.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。

* 作用: 用于过滤文件名称

  抽象方法:用来过滤文件的方法

  * `boolean accept(File dir，String name)` 测试指定文件是否应该包含在某一文件列表中

    * 参数:

      `File dir`:构造方法中传递的被遍历的目录

      dir就是new File()时传递的参数：文件的路径

      `String name`:使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称

      目录中文件的名称。

注意:

* 两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中自己定义过滤的规则。



过滤的规则:

* 在accept方法中，判断File对象是否是以.java结尾
  * 是就返回true
    * 把传递过去的File对象保存到File数组中
  * 不是就返回false
    * 不会把传递过去的File对象保存到File数组中

必须明确的两件事情:

* 1.过滤器中的accept方法是谁调用的
  * listFiles()方法调用的
* 2.accept方法的参数pathname是什么?

listFiles方法一共做了3件事情:

* 1.listFiles方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹-->封装为File对象
* 2.listFiles方法会调用参数传递的过滤器中的方法accept
* 3.listFiles方法会把遍历得到的每一个File对象,传递给accept方法的参数pathname

代码实现：

```java
public class FileFilterImpl implements FileFilter {
    @Override
    public boolean accept(File pathname) {
        //如果pathname是一个文件夹,则返回true,继续遍历这个文件夹，将该文件夹存入File数组中
        if (pathname.isDirectory()){
            return true;
        }
        return pathname.getName().toLowerCase().endsWith(".java");
    }
}
```

```java
public class Demo04File {
    public static void main(String[] args) {
        //method();
        //method01();
        File file=new File("");
        File str=file.getAbsoluteFile();
        getALLFiLe(str);
    }

    private static void getALLFiLe(File dir) {
        //System.out.println(dir);
        File[] files=dir.listFiles(new FileFilterImpl());//传递过滤器对象
        for (File file:files){
            //对遍历得到的File对象f进行判断，判断是否是文件央
            if (file.isDirectory()){
                //file是一个文件夹，则继续遍历这个文件央
                //我们发现getALLFiLe方法就是传遇文件来，遍历文件夹的方法
                //所以直接调用getALLFiLe方法即可:递归(自己调用自己)
                getALLFiLe(file);
            }
            else {
                //file是一个文件，直接打印即可
                System.out.println(file);
            }

        }

    }

    private static void method01() {
        File file=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world");
        File[] files=file.listFiles();
        for (File f:files){
            System.out.println(f);
        }
    }

    private static void method() {
        File file=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world");
        File file1=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello");//NullPointerException
        File file2=new File("C:\\Users\\Wingfung Hung\\Desktop\\debug\\computer\\java\\hello world\\test.txt");//NullPointerException
        String[] strings1=file2.list();
        for (String str:strings1){
            System.out.println(str);
        }
    }

}
```

---

### 5.8 FileNameFilter过滤器的使用和Lambda优化程序

```java
private static void getALLFiLe(File dir) {
    //传递过滤器对象 使用匿名内部类.使用FileFilter接口

    File[] files2=dir.listFiles(new FileFilter(){
        @Override
        public boolean accept(File pathname) {
            //过滤规则,pathname是文件失或者是.java结尾的文件返回true
            return pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(".txt");
        }
    });//传递过滤器对象

    //使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法)
    File[] files4=dir.listFiles((File pathname)->{
        return pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(".txt");
    });

    //简化Lambda表达式
    File[] files=dir.listFiles(pathname -> pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(".txt"));


    //使用FilenameFilter接口
    File[] files1=dir.listFiles(new FilenameFilter() {
        @Override
        public boolean accept(File dir, String name) {
            return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(".txt");
        }
    });

    ////使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法)
    File[] files3=dir.listFiles((File d,String name)->{
        return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(".txt");
    });

    //简化Lambda表达式
    File[] files5=dir.listFiles((d,name)->new File(dir,name).isDirectory()||name.toLowerCase().endsWith(".txt"));

    for (File file:files){
        //对遍历得到的File对象file进行判断，判断是否是文件央
        if (file.isDirectory()){
            //file是一个文件夹，则继续遍历这个文件央
            //我们发现getALLFiLe方法就是传遇文件来，遍历文件夹的方法
            //所以直接调用getALLFiLe方法即可:递归(自己调用自己)
            getALLFiLe(file);
        }
        else {
            //file是一个文件，直接打印即可
            System.out.println(file);
        }
    }
}
```

---

# IO

## 1 IO的概述

将数据的传输可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为 **输入input** 和 **输出output**，即流向内存是输入流，流出内存的输出流。

Java中IO操作主要是指使用 **java.io** 包下的内容，进行输入、输出操作。

输入也叫做读取数据，把硬盘中的数据,读取到内存中使用。

输出也叫做作写入数据，把内存中的数据,写入到硬盘中保存。

流:数据(字符，字节) 1个字符=2个字节 ，1个字节=8个二进制位

## 2 IO的分类

根据数据的流向分为:输入流和输出流

* 输入流 : 把数据从 其他设备 上读取到 内存 中的流
* 输出流 : 把数据从 内存 中写出到 其他设备 上的流

根据数据的类型分为:字节流和字符流。

|        | 输入流                | 输出流                 |
| ------ | --------------------- | ---------------------- |
| 字节流 | 字节输入流InputStream | 字节输出流OutputStream |
| 字符流 | 字符输入流Reader      | 字符输出流Writer       |

---

## 3 字节输出流写入数据到文件

`javo.io.OutputStream`:字节输出流

* 此抽象类是表示输出字节流的所有类的超类。

定义了一些子类共性的成员方法:

* public void close() : 关闭此输出流并放与此液相关联的任何系统资源。

  * 小贴士:

    close方法，当完成流的操作时，必须调用此方法，释放系统资源

* public void flush() :刷新此输出流并强制任何缓冲的输出字节被写出。

* public void write(byte[] b): 将 b.length字节从指定的字节数组写入此输出流。

* public void write(byte[] b, int off,int len) : 从指定的宇节数组写入 len字节，从偏移量 off开始输出到此输出流.

* public abstract void write(int b) :将指定的字节输出流。

`java.io.FileOutputStream extends Outputstream`

`FileOutputStream`:文件字节输出流

* 作用:把内存中的数据写入到硬盘的文件中
* 构造方法:
  * FileOutputStream(String name)创建一个向具有指定名称的文件中写入数据的输出文件流。
    * 可以传入绝对路径或者相对路径
  * FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
    * 可以在参数中直接new一个File类对象，File类构造方法的参数可以是绝对路径或者相对路径。
  * 参数:写入数据的目的
    * String name:目的地是一个文件的路径
    * File file:目的地是一个文件
  * 构造方法的作用:
  * 1.创建一个FileOutputStream对象
  * 2.会根据构造方法中传递的文件/文件路径,创建一个空的文件
  * 3.会把FileOutputStream对象指向创建好的文件

---

写入数据的原理（内存-->硬盘）

* java程序-->JVM(java虚拟机)-->OS(操作系统)-->OS调用写数据的方法-->把数据写入到文件中

字节输出流的使用步骤(重点):

* 1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
* 2.调用FileOutputStream对象中的方法write,把数据写入到文件中
* 3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)

```java
public static void main(String[] args) throws IOException {
    //1.创建一个FileOutputStream对象构造方法中传递写入数据的目的地
    FileOutputStream fos=new FileOutputStream("a.txt");//创建一个文件
    //2.调用FileOutputStream对象中的方法write,把数据写入到文件中
    fos.write(97);
    //3.释放资源(流使用会占用一定的内存，使用完毕要把内存清空,提高程序的效率)
    fos.close();
}
```



写数据的时候，会把10进制的整数97，转换为二进制整数97

```java
fos.write(1100001);97-->1100001
```

硬盘中存储的数据都是字节，1个字节=8个比特位

注意：

任意的文本编辑器(记事本,notepad++...在打开文件的时候，都会查询编码表,把字节转换为字符表示。

* 0~127:查询ASCII表
  * 97->a
* 其他值:查询系统默认码表(中文系统GBK32)

---

## 4 字节输出流写多个字节的方法

`public void write(byte[] b)`: 将 b.length字节从指定的字节数组写入此输出演。一次写多个字节:

* 如果写的第一个字节是正数(0~127)那么显示的时候会查询ASCII表

* 如果写的第一个字节是负,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK).

* ```java
  public static void main(String[] args) throws IOException {
      //1.创建一个FileOutputStream对象构造方法中传递写入数据的目的地
      FileOutputStream fos=new FileOutputStream(new File("b.txt"));
      //2.调用FileOutputStream对象中的方法write,把数据写入到文件中
      byte[] b={-65,-66,-67,-68,69};//烤郊E,这不是乱码
      fos.write(b);
      //3.释放资源(流使用会占用一定的内存，使用完毕要把内存清空,提高程序的效率)
      fos.close();
  }
  ```

`public void write(byte[]_b，int off，int len)`把字节数组的一部分写入到文件中

* int off:数组的开始素引

* int len:写几个字节

* ```java
  byte[] bytes={65,66,67,68,69};
  fos.write(bytes,1,2);//BC
  ```

编码问题：

* UTF-8：1个中文是3个字节。在记事本中打开时要选择UTF-8编码
* JDK中：1个中文是2个字节

```java
byte[] bytes1="你好".getBytes();//[-28, -67, -96, -27, -91, -67]
fos.write(bytes1);//一个中文对应3个字节，你好
System.out.println(Arrays.toString(bytes1));//[-28, -67, -96, -27, -91, -67]
```

---

## 5 字节输出流的续写和换行

追加写/续写:使用两个参数的构造方法

* FileOutputStream(Strng name， boolean append)创建一个向具有指定 name 的文件中写入数据的输出文件流。
* FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
* 参数:String name,File file:写入数据的目的地boolean append:追加写开关
  * true:创建对象不会要盖源文件，继续在文件的末尾尾追加写数据
  * false:创建一个新文件，覆盖源文件
* 换行:写换行符号
  * windows :\r\n
  * Linux:/n
  * mac:/r

```java
FileOutputStream fos=new FileOutputStream(new File("c.txt"),true);
byte[] bytes1="你好".getBytes();

for (int i = 0; i < 10; i++) {
    fos.write(bytes1);
    fos.write("\r\n".getBytes());
}
```

---

# 二、IDEA中Git的使用方法

1. 配置Git环境

   * 下载并安装Git，设置好path环境变量。

2. 在IDEA的设置中选择git.exe的路径

   * IDEA左上角文件-->设置-->版本控制-->Git
   * 在最上方可以选择Git可执行文件路径，选择Git安装目录下的bin文件夹里面的git.exe，点击右边的测试，即可显示当前Git的版本，成功显示则为设置成功。

3. 创建Git本地仓库

   * 方法一：在IDEA项目根目录下运行Git Bash，输入命令`git init`来创建本地仓库，自动生成.git文件夹。
   * 方法二：在IDEA菜单栏中，选择VCS，里面有个创建Git仓库，点击进入，选择路径为项目根目录，自动生成.git文件夹。

4. 连接到远程仓库

   * 在IDEA菜单栏中，点击Git，选择里面的管理远程。
   * 点击+号，定义远程，输入你喜欢的名称，输入远程仓库的URL，点击确定，初次连接则需要输入远程仓库所属 账号的账户名和密码。

5. 将远程仓库中的文件同步到本地（新建的远程仓库如果没有文件则跳过这一步）

   * 方法一：克隆仓库（首次）

     * 在IDEA菜单栏中，点击Git，选择里面的克隆。
     * 输入远程仓库的URL。选择仓库的目录。点击确定即可。

   * 方法二：更新项目（无论是否首次）

     * ```bash
       git fetch
       ```

       

     * 选择在传入变更上变基当前分支，点击确定。

6. 提交

   * 选择你需要提交到暂存区的文件，写上message。

7. 推送

   * 选择已存放到暂存区的文件，并推送到远程仓库。

注意：如果远程仓库中有文件，且与本地仓库中的文件不一样，此时需要将远程仓库中的文件复制一份到本地文件中，之后将本地仓库中的文件才能推送到远程仓库中。



---

# 三、JavaWeb

## 1. Junit单元测试 :

### 1.1 概述

测试分类 :

* 1.黑盒测试 : 不需要写代码，给输入值，看程序是否能够输出期望的值。
* 白盒测试: 是需要写代码的。关注程序具体的执行流程。

注意：

**Junit单元测试** 是**白盒测试**的一种。

---

### 1.2 Junit 的使用步骤

* 1.定义一个测试类(测试用例)
  * 建议：
    * 测试类名 : 被测试的类名+Test，如：CalculatorTest
    * 包名 : xxx.xxx.xx.test，如：cn.itcast.test，以test结尾
* 2.定义测试方法:可以独立运行
  * 建议 :
    * 方法名 : test测试的方法名，如testAdd()
    * 返回值 : void
    * 参数列表:空参
* 3.给方法加@Test
* 4.导入junit依赖环境

---

* 判定结果 :
  * 红色 :失败
  * 绿色:成功
  * 一般我们会使用断言来操作处理结果 
    * Assert.assertEquals(期望的结果,运算的结果);

注意：需要将JUnit4添加到类路径中。

```java
public class Calculator {
    public int add(int a,int b){
        return a+b;
    }
    public int sub(int a,int b){
        return a-b;
    }
}
```

```java
import org.junit.Assert;
import org.junit.Test;
public class CalculatorTest {
    @Test
    public void testAdd(){
        System.out.println("执行成功");
        //1.创建计算器对象
        Calculator c=new Calculator();
        //2.调用add方法
        int result=c.add(1,2);
        //3.断言 我断言这个结果是3
        Assert.assertEquals(3,result);
    }

    @Test
    public void testSub(){
        Calculator c=new Calculator();
        int result=c.sub(1,2);
        Assert.assertEquals(-1,result);
    }
}
```

---

### 1.3 注解Before和After

* @Before
  * 修饰的方法会在测试某个方法执行**之前**被自动执行。
* @After
  * 修饰的方法会在测试某个方法执行**之后**自动被执行。

```java
@Before
public void before(){
    System.out.println("before");
}
@After
public void after(){
    System.out.println("after");
}
```

**注意**：

即使被测试的那个方法抛出了异常，被@Before和@After修饰的方法还是会执行的。

---

## 2. 反射

### 2.1 概述

反射：框架设计的灵魂

* 框架:半成品软件。可以在框架的基础上进行软件开发，简化编码
* 反射:将类的各个组成部分封装为其他对象，这就是反射机制
  * 好处:
    1. 可以在程序运行过程中，操作这些对象。
    2. 可以解耦，提高程序的可扩展性。

Java代码 在计算机中 经历的阶段 : 

* Source 源代码阶段（位于硬盘）

  * 将.java源文件通过javac去编译，生产.class字节码文件。
  * .class字节码文件中包含了三个部分
    * 成员变量
    * 成员方法
    * 构造方法

* Class 类对象阶段（位于内存）

  * .class字节码文件通过类加载器（ClassLoader）后，就进入了Class 类对象阶段。
  * 将成员变量封装为Field对象，并存放于Field数组中(Field[] fields)
  * 将构造方法封装为Constructor对象，并存放于Constructor数组中(Constructor[] cons)
  * 将成员方法封装为Method对象，并存放于Method数组中(Method[] methods)
  * 以上三个对象构成了Class类对象

* Runtime运行时阶段

  * 创建对象

    例如：Person对象，new Person();

---

### 2.2 获取字节码Class对象的三种方式

获取class对象的方式:

* 1.static class.forName("全类名”): 将字节码文件加载进内存，返回Class对象。（源代码阶段）（可以直接通过类名调用）（全类名指的是：包名.类名）
  * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类。
* 2.类名.class: 通过类名的属性class获取。（类对象阶段）
  * 多用于参数的传递
* 3.对象.getClass(): getClass()方法在Object类中定义着。（Runtime运行时阶段）
  * 多用于对象的获取字节码的方式

结论 :

* 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。

```java
public static void main(String[] args) throws ClassNotFoundException {
    //1.Class.forName("全类名")
    Class cls1= Class.forName("winter_holiday_training_camp.day22.Person");
    System.out.println(cls1);

    //2.类名.class
    Class cls2= Person.class;
    System.out.println(cls2);

    //3.对象.getClass()
    Person p=new Person();
    Class cls3=p.getClass();
    System.out.println(cls3);

    //== 比较三个对象
    System.out.println(cls1==cls2);
    System.out.println(cls3==cls2);
}
```

运行结果：

```
class winter_holiday_training_camp.day22.Person
class winter_holiday_training_camp.day22.Person
class winter_holiday_training_camp.day22.Person
true
true
```

注意：不同字节码文件用==来判断的结果肯定是false的。

---

### 2.3 Class对象功能:

**获取功能**:

* 1.获取成员变量们
  * Field[] getFields() : 获取所有**public**修饰的成员变量，其他的不行。
  * Field getField(String name)获取指定名称的 public修饰的成员变量。
  * Field[] getDeclaredFields()获取所有的成员变量，不考虑修饰符（无论是不是public/protected/(default)/private）
  * Field getDeclaredField(String name)

* 2.获取构造方法们
  * constructor<?>[] getConstructors()
  * Constructor<T> getConstructor(类<?>... parameterTypes)
  * Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)
  * Constructor<?>[] getDeclaredconstructors()
* 3.获取成员方法们:
  * Method[] getMethods()
    * 获取  调用该方法的类对象  所属的类  里面的方法和其父类中所有的方法。
  * Method getMethod(String name, 类<?>... parameterTypes)
    * 注意：没有参数则不用写参数
  * Method[] getDeclaredMethods()
  * Method getDeclaredMethod(String name， 类<?>... parameterTypes)
* 4.获取类名
  * String getName()

注意：

获取成员方法们中的**String name**指的是方法名次，要用双引号输入，而 **类<?>... parameterTypes**指的是参数列表，如果参数是String food，则要在逗号后面输入String.class。

---

#### 2.3.1 获取成员变量

Field:成员变量

* 操作 :
  * 1.设置值
    * void set(Object obj, Object value)
  * 2.获取值
    * get(Object obj)
  * 3.忽略访问权限修饰符的安全检查
    * setAccessible(true):暴力反射（无论是上述哪个方法，都可以用这个方法进行暴力反射）

```java
public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
    //0.获取Person的Class对家
    Class personClass=Person.class;
    //1.Field[] getFields()获取所有public修饰的成员变量
    Field[] fields=personClass.getFields();
    for (Field field:fields){
        System.out.println(field);
    }
    System.out.println("-----------");
    Field a=personClass.getField("a");
    //获职成员变量a的值
    Person p=new Person();
    Object value=a.get(p);
    System.out.println(value);
    //设置a的值
    a.set(p,123);
    System.out.println(p);
    System.out.println("==================");
    Field[] declaredFields=personClass.getDeclaredFields();
    for (Field field:declaredFields){
        System.out.println(field);
    }
    Field d=personClass.getDeclaredField("name");
    //忽略访问权限修饰符的安全检查
    d.setAccessible(true);
    Object value2=d.get(p);
    System.out.println(value2);
}
```

```java
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age, int a) {
        this.name = name;
        this.age = age;
        this.a = a;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", a=" + a +
                '}';
    }

    public int a;

}
```



#### 2.3.2 获取构造方法

使用此 constructor对象表示的构造的数，使用指定的初始化邻数来创建和切始化构造团数的声明类的新实例。

Constructor:构造方法

* 创建对象 :
  * T newInstance(Object... initargs)
  * 如果使用空参数构造方法创建对象，操作可以简化。直接使用Class对象的newInstance方法

```java
public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    //获取Person的class对象
    Class personClass= Person.class;
    Constructor constructor=personClass.getConstructor(String.class,int.class,int.class);
    System.out.println(constructor);
    //创建对象
    Object person=constructor.newInstance("张三",23,1);
    System.out.println(person);

    Constructor constructor1=personClass.getConstructor();
    System.out.println(constructor1);
    //创建对象
    Object person1=constructor1.newInstance();
    System.out.println(person1);
    //如果使用空参数构造方法创建对象，操作可以简化。
    Object o=personClass.newInstance();
    System.out.println(o);
}
```

---

#### 2.3.3 获取成员方法

Method:方法对象

* 执行方法:

  * Object invoke(Object obj, Object... args)

    在具有指定参数的方法对象上调用此方法对象表示的底层方法。

* 获取方法名称:

  * String getName:获取方法名

```java
public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class personClass= Person.class;
        //获取类名
        String className=personClass.getName();
        System.out.println(className);

        //获取指定名称的方法
        Method eatMethod=personClass.getMethod("eat");
        Person p=new Person();
        //执行方法
        eatMethod.invoke(p);

        Method eatMethod01=personClass.getMethod("eat",String.class);
        //执行方法
        eatMethod01.invoke(p,"饭");
        System.out.println("-----------------");
        //获职所有public修饰的方法
        Method[] methods=personClass.getMethods();
        for (Method method:methods){
            System.out.println(method);
            String name=method.getName();
            System.out.println(name);
//            method.setAccessible(true);
        }
    }
```

---

### 2.4 案例

获取字节码文件的方法：类名.class

获取某字节码文件对应的类加载器的方法：类名.class.getClassLoader()

案例 :

* 需求:写一个“框架类"，在不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。
* 实现 :
  * 1.配置文件
  * 2.反射
* 步骤：
  * 1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中
  * 2.在程序中加载读取配置文件
  * 3.使用**反射技术**来加载类文件进内存（即配置文件里面那两行代码加上导入配置文件的代码）
  * 4.创建对象
  * 5.执行方法

注意：(链接数据库)的配置文件位置不在src下面而是在其他文件夹下 就会抛出inStream parameter is null异常。一定要把配置文件放在src文件夹之下。

```java
public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    //如果需要修改调用其中的方法，就需要改变测试类中的代码，对于大型项目来说，这是很不方便的
    Person person=new Person();
    person.sleep();
    person.eat();
    Student student=new Student();
    student.sleep();

    //1.加载配置文件
    //1.1创建Properties对象
    Properties pro=new Properties();
    //1.2加载配置文件，转换为一个集合
    //1.2.1获取class目录下的配置文件
    ClassLoader classLoader=ReflectTest.class.getClassLoader();
    InputStream inputStream=classLoader.getResourceAsStream("pro.properties");
    pro.load(inputStream);

    //2.获取配置文件中定义的数据
    String className=pro.getProperty("className");
    String methodName=pro.getProperty("methodName");

    //3.加载该类进内存
    Class cls= Class.forName(className);
    //4.创建对象
    Object obj=cls.newInstance();
    //5.获取方法对象
    Method method=cls.getMethod(methodName);
    //6.执行方法
    method.invoke(obj);
}
```

Person类：

```java
package winter_holiday_training_camp.day22;

public class Person {
    public void eat(){
        System.out.println("eat");
    }
       
    public void sleep(){
        System.out.println("sleep");
    }
}
```

Student类：

```java
public class Student {
    public void sleep(){
        System.out.println("sleep");
    }
}
```

pro.properties配置文件：

```java
className=winter_holiday_training_camp.day22.Person
methodName=eat
```

---

## 3. 注解

### 3.1 概念

* 概念:说明程序的。给计算机看的
* 注释:用文字描述程序的。给程序员看的
* 定义:注解(Annotation)，也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、妆举在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
* 概念描述:
  * JDK1.5之后的新特性
  * 说明程序的
  * 使用注解: @注解名称
* 作用分类:
  * 1.编写文档 : 通过代码里标识的注解生成文档【生成文档doc文档】
  * 2.代码分析 : 通过代码里标识的注解对代码进行分析【使用反射】
  * 3.编译检查 : 通过代码里标识的注解让编译器能够实现基本的编译检查【override】

### 3.2 JDK中预定义的一些注解

* @Override : 检测被该注解标注的方法是否是继承（覆盖重写）自父类(接口)的

* @Deprecated : 该注解标注的内容，表示已过时

* @Suppresswarnings : 压制警告，例如该方法从未被使用

  * 一般传递参数all ，例如@Suppresswarnings("all”)

  ```java
  @Override
  public String toString(){
      return super.toString();
  }
  @Deprecated
  public void show1(){
      //会画一条横线在show1上面
  }
  @SuppressWarnings("all")
  public void show2(){
  
  }
  public void demo(){
      show1();
  }
  ```

### 3.3 自定义注解

* 格式:

  元注解

  ```java
  public @interface 注解名称{
      属性列表;
  }
  ```

  ```java
  public @interface MyAnno {
      public String show();
  }
  ```

* 本质:注解本质上就是一个接口，该接口默认继承Annotation接口

  * public interface 注解名称 extends java.lang.annotation.Annotation ()

* 属性 : 接口中可以定义的成员方法（也就是抽象方法）

  * 要求：
    * 1.属性的返回值类型不能是void，可以是以下几种类型
      * 基本数据类型
      * String
      * 枚举
      * 注解
      * 以上类型的数组
    * 2.定义了属性，在使用时需要给属性赋值
      * 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
      * 2.如果只有一个属性需要赋值，**并且属性的名称是value**，则**value=**可以省略，直接定义值即可。
      * 3.数组赋值时，值使用{ }包裹。如果数组中只有一个值，则{}可以省略。

* 用法：

  ```java
  public @interface MyAnno {
      public String show() default "jim";
      int age();
      String name();
      Person person();
      MyAnno02 anno02();
      String[] str();
  }
  ```

  ```java
  @MyAnno(age=1,name = "jane",person =Person.p1,anno02 = @MyAnno02,str = {"123","321"})//赋值的顺序没有要求，可以改变
      public void demo(){
          show1();
      }
  //枚举类型数据的赋值：
  //抽象方法名=枚举类名.枚举变量名
  ```

* 在程序使用(解析)注解（下文有更详细的说明）

```java
/**
 *  javadoc 
 * @author Wingfung Hung
 * @version 1.8
 * @since 1.5
 */
public class Demo10 {
    /**
     *
     * @param a lala    
     * @param b haha
     * @return  the sum of a and b
     */
    public int add(int a,int b){
        return a+b;
    }
}
```

---

#### 补充：

对.class字节码文件用javap命令可以反编译，进而得到其源码。

对注解源文件.java用javadoc命令可以获得对应的java的api文档。

在使用javadoc命令前，一定要把.java文件转换成ANSI编码，如果使用UTF-8编码会出现问题。

在使用javadoc命令前，要把环境变量CLASSPATH删除，否则会抛出java.lang.IllegalArgumentException异常。原因：是classpath里面字符冲突引起的。

切换JDK版本时，一定要把`C:\Program Files\Common Files\Oracle\Java`目录下的两个文件夹删掉。

---

### 3.4 元注解

元注解: 用于描述注解的注解

* @Target : 描述注解能够作用的位置

  * ElementType**数组**取值 :
    * TYPE : 可以作用于类上
    * METHOD:可以作用于方法上
    * FIELD : 可以作用于成员变量上

* @Retention : 描述注解被保留的阶段

  * @Retention(RetentionPolicy.RUNTIME):当前被描述的注解，会保留到class字节码文件中，并被JVM读取到

    自己定义的注解一般都取RUNTIME这个值。

  * @Retention(RetentionPolicy.CLASS):当前被描述的注解，会保留到class字节码文件中，但不会被JVM读取到。

  * @Retention(RetentionPolicy.SOURCE):当前被描述的注解，不会保存到class字节码文件中，更不会被JVM读取到。

* @Documented :描述注解是否被抽取到api文档中

* @Inherited : 描述注解是否被子类继承

  ```java
  @MyAnno02
  public class Worker {
      @MyAnno02
      String name="aaa";
      
      @MyAnno02
      void show(){
  
      }
  }
  ```

```java
//此处自动继承了Worker中的注解MyAnno02
public class Teacher extends Worker{
}
```

```java
@Target({ElementType.FIELD,ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface MyAnno02 {
}
```

---

### 3.5 解析注解

在程序使用(解析)注解: 获取注解中定义的属性值

* 1.获取注解定义的位置的对象(Class，Method，Field)
* 2.获取指定的注解
  * getAnnotation(Class)
  * //其实就是在内存中生成了一个该注解接口的子类实现对象
* 3.调用注解中的抽象方法获取配置的属性值

```java
@Pro(className = "winter_holiday_training_camp.day24.Demo02",methodName ="show")
public class ReflectTest02 {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        //1.解析注解
        //1.1获取该类的字节码文件对象
        Class<ReflectTest02> reflectTestClass= ReflectTest02.class;
        //2.获取上边的注解对象
        //其实就是在内存中生成了一个该注解接口的子类实现对象
        /*
        public class ProImpl implements Pro{
            public String className(){
                return "winter_holiday_training_camp.day24.Demo01";
            }
            public String methodName(){
                return "show";
            }
        }
         */
        Pro an=reflectTestClass.getAnnotation(Pro.class);
        //3.调用注解对象中定义的抽象方法，获取返回值
        String className=an.className();
        String methodName= an.methodName();
        System.out.println(className);
        System.out.println(methodName);

        //以下内容与前面的反射案例相同
        //4.加载该类进内存
        Class cls= Class.forName(className);
        //5.创建对象
        Object obj=cls.newInstance();
        //6.获取方法对象
        Method method=cls.getMethod(methodName);
        //7.执行方法
        method.invoke(obj);
    }

}
```

注解Pro：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Pro {
    String className();
    String methodName();
}
```

Demo01：

```java
public class Demo01 {
    public void show(){
        System.out.println("Demo01....show");
    }
}
```

Demo02：

```java
public class Demo02 {
    public void show(){
        System.out.println("Demo02....show");
    }
}
```

---

### 3.6 简单的测试框架

Calculator类

```java
public class Calculator {
    //加法
    @Check
    public void add(){
        String str=null;
        str.toString();
        System.out.println("1+0="+(1+0));
    }
    @Check
    public void sub(){
        System.out.println("1-0="+(1-0));
    }
    @Check
    public void mul(){
        System.out.println("1*0="+(1*0));
    }
    @Check
    public void div(){
        System.out.println("1/0="+(1/0));
    }
    public void show(){
        System.out.println("没有bug");
    }
}
```

Check注解：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Check {
}
```

TestCheck类：

```java
public class TestCheck {
    public static void main(String[] args) throws IOException {
        //1.创建计算器对象
        Calculator c=new Calculator();
        //2.获取字节码文件对象
        Class cls=c.getClass();
        //3.获取所有方法
        Method[] methods=cls.getMethods();
        //出现异常的次数
        int number=0;
        BufferedWriter bw=new BufferedWriter(new FileWriter("bug.txt"));

        for (Method method:methods){
            //4.判断方法上是否有Check注解
            if (method.isAnnotationPresent(Check.class)){
                //5.有，执行
                try {
                    method.invoke(c);
                } catch (Exception e) {
                    //6.捕获异常
                    //记录到文件中
                    number++;
                    bw.write(method.getName()+"方法出异常了");
                    bw.newLine();
                    bw.write("异常的名称："+e.getCause().getClass().getSimpleName());
                    bw.newLine();
                    bw.write("异常的原因："+e.getCause().getMessage());
                    bw.newLine();
                    bw.write("-------------------------");
                    bw.newLine();
                }
            }
        }
        bw.write("本次测试一共出现"+number+"次异常");
        bw.flush();
        bw.close();
    }
}
```

#### 运行结果：

控制台输出：

```
1-0=1
1*0=0
```

bug.txt文件：

```
add方法出异常了
异常的名称：NullPointerException
异常的原因：Cannot invoke "String.toString()" because "str" is null
-------------------------
div方法出异常了
异常的名称：ArithmeticException
异常的原因：/ by zero
-------------------------
本次测试一共出现2次异常
```

---

# 四、数据库

## 1. 数据库的基本概念

* 数据库的英文单词: DataBase 简称 : DB
* 数据库 是用于存储和管理数据的仓库。
* 数据库的特点 :
  * 1.持久化存储数据。其实数据库就是一个文件系统
  * 2.方便存储和管理数据
  * 3.使用了统一的方式操作数据库 —— SQL
* SQLite: 嵌入式的小型数据库，应用在手机端

---

## 2. 数据库的登录

```
在cmd中输入：
mysql -u用户名 -r密码
但这种直接输入密码的方法是不安全的
可以输入：
mysql -u用户名 -r
然后系统会提示你输入密码
这时候输入密码就安全很多了，因为输入的密码是隐藏的，看不见的
```









----

# 五、picgo搭配coding图床使用(已废弃，该插件有bug)

## 1. 安装picgo.exe

在GitHub上下载并安装。

安装成功后还要下载Node.js，之后安装coding插件要用到。

在左侧最后一行插件设置中搜索coding，安装最新版本的插件。如果没有安装Node.js则会报错，提示需要安装Node.js。

## 2. 设置好Coding图床

[代码浏览 - 3122004946-HongYongfeng - 2023android训练营 - TopView2023Android训练营 (coding.net)](https://topviewxunlianying2023.coding.net/p/2023androidxunlianying/d/3122004946-HongYongfeng/git) 

```
例如这个网址：
https://topviewxunlianying2023.coding.net/p/2023androidxunlianying/d/3122004946-HongYongfeng/git
最前面的topviewxunlianying2023是团队名称。
2023androidxunlianying是项目名称。
3122004946-HongYongfeng是仓库名称。
存储结构就是你想把图片放在哪个文件夹里。
```

未完成，目前遇到的问题是：

```
2023-02-04 21:28:25 [PicGo ERROR] 
------Error Stack Begin------
TypeError: Cannot read properties of undefined (reading 'ProjectList')
    at getProjectId (C:\Users\Wingfung Hung\AppData\Roaming\picgo\node_modules\picgo-plugin-coding\src\index.js:32:33)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Object.handle (C:\Users\Wingfung Hung\AppData\Roaming\picgo\node_modules\picgo-plugin-coding\src\index.js:166:23)
    at async $e.doUpload (G:\Program Files\PicGo\resources\app.asar\node_modules\picgo\dist\index.cjs.js:1:17198)
    at async $e.start (G:\Program Files\PicGo\resources\app.asar\node_modules\picgo\dist\index.cjs.js:1:15969)
    at async Tt.upload (G:\Program Files\PicGo\resources\app.asar\node_modules\picgo\dist\index.cjs.js:1:71270)
    at async Object.upload (G:\Program Files\PicGo\resources\app.asar\background.js:2:653584)
    at async jn (G:\Program Files\PicGo\resources\app.asar\background.js:2:656251)
    at async G:\Program Files\PicGo\resources\app.asar\background.js:2:657340
-------Error Stack End------- 
2023-02-04 21:28:25 [PicGo INFO] [PicGo Server] upload result  
2023-02-04 21:28:25 [PicGo WARN] [PicGo Server] upload failed, see picgo.log for more detail ↑ 
2023-02-04 21:28:38 [PicGo INFO] [PicGo Server] shutdown 

```

----

# 六、picgo搭配Github图床使用

## 1. picgo的设置

### 仓库名

picgo中设定的仓库名=GitHub的用户名/仓库名

### 设定分支名

main（默认分支，改版后就不是master了）

### 设定Token

右上角头像-->settings-->Develop Settings-->里面有个Token的

### 设定存储路径

不填则默认为根目录

填**test/**则表示保存在仓库根目录下的test文件夹中

### 设定自定义域名

https://cdn.jsdelivr.net/gh/2002Wingfung/Android@main

**一定要加上@main**

---

## 2. md中添加图片

先打开保存在仓库的图片

在地址栏复制该图片的地址

```
https://github.com/2002Wingfung/Android/blob/main/202302151937870.png
```

将**blob**改为**raw**，然后复制进.md文件中

格式：

```
![](https://github.com/2002Wingfung/Android/raw/main/202302151937870.png)
```

这样就可以了。在仓库的.md文件中就能正确显示了

![](https://github.com/2002Wingfung/Android/raw/main/202302160013974.jpg)

注意：

保存在GitHub仓库的图片需要翻墙才能正确显示。

---

# 1 SQL的概述

SQL全称: Structured Query Language，是结构化查询语言，用于**访问和处理数据库的标准的计算机语言**。

SQL语言1974年由Boyce和Chamberlin提出，并首先在IBM公司研制的关系数据库系统SystemR上实现。

---

# 2 SQL的特点

## 语言特点

* 具有综合统一性，不同数据库的支持的SQL稍有不同
* 非过程化语言
* 语言简捷，用户容易接受
* 以一种语法结构提供两种使用方式，既可以单独使用SQL，也可以和其他语言搭配使用。

## 语法特点

* SQL对关键字的大小写不敏感

  * select/SELECT/Select都行
  * 关键字建议使用大写

* SQL语句可以以单行或者多行书写，以分号结束

  * ```sql
    SELECT 
    * 
    from 
    emp;
    -- 以上相当于：
    SELECT * FROM emp;
    ```

    

* SQL的注释

  * -- 单行注释 ，**-- 后面一定要加一个空格**

  * #单行注释，**#后面可加可不加空格**

  * ```sql
    SELECT * FROM emp;-- 这里是注释
    ```

  * ```sql
    /*
    多行注释 
    多行注释
    */
    ```

---

# 3 数据库系统

## 1、数据库

数据库(DataBase)是一个以某种组织方式存储在磁盘上的数据的集合.

## 2、数据库应用

数据库应用系统是指基于数据库的应用软件.

## 3、数据库管理系统(数据库软件)

### 关系型数据库(RDBMS)

* Oracle数据库
* MysQL数据库
* SQL server数据库 
* PostgreSQL
* SQLite

### 非关系型数据库(NoSQL)

* Redis
* MongoDB
* Elasticsearch 
* Cassandra
* HBase

### SQL和数据库管理系统的关系

* SQL是一种用于操作数据库的语言，SQL适用于所有关系型数据库。
* MysQL、Oracle、SQLServer是一个数据库软件，这些数据库软件支持标准SQL，也就是通过SQL可以使用这些软件，不过每一个数据库系统会在标准SQL的基础上扩展自己的SQL语法。
* 大部分的NoSQL数据库有自己的操作语言，对SQL支持的并不好。

### 关系型数据数据库管理系统组成

数据库管理系统(DBMS) 主要由数据库和表组成，一个数据库系统可以有很多数据库，每个数据库可以有很多表。

---

# 4 MySQL

## 4.1 MySQL的特点

* MySQL数据库是用C和C++语言编写的，以保证源码的**可移植性**
* 支持多个操作系统，例如: Windows、Linux、Mac OS等等
* 支持多线程，可以充分的利用**CPU资源**
* 为多种编程语言提供API，包括C语言，Java，PHP，Python语言等
* MySQL优化了SQL算法，有效的**提高了查询速度**
* MySQL**开放源代码且无版权制约**，自主性强、使用成本低。
* MySQL历史悠久、社区及用户非常活跃，遇到问题，可以很快获取到帮助。

## 4.1 MySQL的版本

MySQL的命名机制：使用由3个数字和一个后缀组成的版本号。

例如，像mysql-8.0.26的版本号这样解释：

* 第1个数字(8)是主版本号，描述了文件格式。所有版本的发行都有相同的文件格式
* 第2个数字(0)是发行级别，主版本号和发行级别组合到一起便构成了发行序列号
* 第3个数字(26)是在此发行系列的版本号，随每个新分发版递增。

## 4.2 卸载MySQL

* 停止服务
  * 方式1: 打开DOS，使用net stop mysql命令
  * 方式2:[win+R快捷键]-->输入 services.msc -->进入服务窗口关闭mysql服务
* 卸载程序 (可选)(通过安装包安装的就用这个方法卸载，如果是直接解压安装的就不需要执行此方法)
  * 使用360卸载mysql程序或[控制面板]-->[程序和功能]-->右键卸载程序
* 删除项目根文件夹:
  * 进入mysql安装位置，删除mysql的解压(安装)文件夹
* 删除C盘隐藏文件夹 (可选)(通过安装包安装的就执行此步骤，解压安装则不需要执行此步骤)
  * 显示隐藏文件后，删除C盘下的“C:\ProgramData\MySQL”所有文件;
* 删除注册表信息:
  * [win+R快捷键]-->输入regedit 命令打开注册表窗口，删除以下文件:
    * HKEY_LOCAL_ MACHINE/SYSTEM/ControlSet001/ Services/Eventlog/Applications/MySQL
    * HKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Applications/MySQL
    * HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Applications/MySQL
* 删除环境变量里的配置:
  * 如果更改了环境变量，那么进入[环境变量]中删除系统变量中的MYSQL_HOME变量和删除Path变量中的mysql路径
* 删除MYSQL服务
  * 管理员权限cmd-->sc delete MySQL的服务名，在任务管理器中可以查看。

---

# 5 SQL的分类

- DDL数据定义语言，用来定义数据库对象：数据库，表，列
- DML数据操作语言，用来对数据库中表的数据进行增删改查
- DQL数据查询语言，用来查询数据库中表的记录
- DCL数据控制语言，用来定义数据库的访问权限和安全级别以及创建用户

---

## 5.1 DDL解释

DDL(Data Definition Language)，数据定义语言，该语言部分包括以下内容：

* 对数据库的常用操作
* 对表结构的常用操作
* 修改表结构

## 5.2 对数据库的常用操作

| 功能                                            | SQL代码                                                    |
| ----------------------------------------------- | ---------------------------------------------------------- |
| 查看所有的数据库                                | show databases;                                            |
| 创建数据库                                      | create database [if not exists] 数据库名字 [charset=utf8]; |
| 切换 (选择要操作的/选择使用哪一个数据库) 数据库 | use 数据库名字;                                            |
| 删除数据库                                      | drop database [if exists] 数据库名字;                      |
| 修改数据库编码                                  | alter database 数据库名字 character set utf8;              |

```SQL
select database();//查询当前使用的数据库
```

注意：

创建数据库时，如果创建一个重名的数据库，则会报错，加上if not exists语句则不会报错。

删除数据库时同理。

* `show databases;`

  查询后可以看到这四个数据库，是MySQL自带的数据库

  * information_schema是记录MySQL有哪些库和表的信息，是一种视图.
  * mysql是存储这个MySQL数据库中最核心的信息，权限，安全等等
  * performance_schema是存储性能相关信息
  * sys是存储系统相关的信息

---

## 5.3 MySQL数据库基本操作-DDL

### 5.3.1 对表结构的常用操作--创建表

**[ ]内的内容可以省略。**

* 创建表格式

  ```sql
  create table [if not exists]表名(
  	字段名1 类型[(宽度)][约束条件][comment '字段说明'],
      字段名2 类型[(宽度)][约束条件][comment '字段说明'],
      字段名3 类型[(宽度)][约束条件][comment '字段说明']
  )[表的一些设置];
  ```

  

* 创建表是构建一张空表，指定这个表的名字，这个表有几列，每一列叫什么名字(字段名)，以及每一列存储的数据类型。

注意：只要不是数字、日期，就算是字符串，属于varchar类型。

整数是int类型，日期是date类型，小数是double类型。

```sql
name varchar(20)
-- 20就是20个字符串的意思
```

#### 数值类型

| 类型         | 大小    | 范围（有符号）     | 范围（无符号） |
| ------------ | ------- | ------------------ | -------------- |
| TINYINT      | 1 byte  | (-128,127)         | (0,255)        |
| SMALLINT     | 2 bytes | (-32768,32767)     | (0,65535)      |
| MEDIUMINT    | 3 bytes | (-8388608,8388607) | (0,16777215)   |
| INT或INTEGER | 4 bytes | ...                | ...            |
| BIGINT       | 8 bytes | ...                | ...            |
| FLOAT        | 4 bytes | ...                | ...            |
| DOUBLE       | 8 bytes | ...                | ...            |
| DECIMAL      | 无      | 依赖于M和D的值     | 依赖于M和D的值 |

注意：

* decimal(M,D)有效位数为M位，小数点保留D位。
  * decimal也是小数的一种
* 无符号数则在数据类型后面加一个**unsigned**即可。

---

#### 字符串类型

| 类型       | 大小         | 用途                          |
| ---------- | ------------ | ----------------------------- |
| CHAR       | 0-255bytes   | 定长字符串                    |
| VARCHAR    | 0-65535bytes | 变长字符串                    |
| TINYBLOB   | 0-255bytes   | 不超过255个字符的二进制字符串 |
| TINYTEXT   | 0-255bytes   | 短文本字符串                  |
| BLOB       | 0-65535bytes | 二进制形式的长文本数据        |
| TEXT       | 0-65535bytes | 长文本数据                    |
| MEDIUMBLOB | 更大         | 二进制形式的中等长度文本数据  |
| MEDIUMTEXT | 更大         | 中等长度文本数据              |
| LONGBLOB   | 最大         | 二进制形式的极大文本数据      |
| LONGTEXT   | 最大         | 极大文本数据                  |



注意：

* 赋值时一般用单引号引用要存入的内容。
* 这并不是一个数组，即使存入的字符少于自己设定的字符，也不会浪费空间。
* 一个汉字也算是一个字符，与英文字符一样。

---

#### 日期类型

| 类型      | 大小(bytes) | 范围                                    | 格式                | 用途                     |
| --------- | ----------- | --------------------------------------- | ------------------- | ------------------------ |
| DATE      | 3           | 1000-01-01/9999-12-31                   | YYYY-MM-DD          | 日期值                   |
| TIME      | 3           | '-838:59:59'/'838:59:59'                | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1           | 1901/2155                               | YYYY                | 年份值                   |
| DATETIME  | 8           | 1000-01-01 00:00:00/9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4           | 1000-01-01 00:00:00/2038                | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

注意：

* TIMESTAMP 的结束时间是：

  第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 03:14:07

* 日期类型也要用单引号引用，易错！

---

### 5.3.2 对表结构的常用操作一其他操作

| 功能                       | SQL                          |
| -------------------------- | ---------------------------- |
| 查看当前数据库的所有表名称 | show tables;                 |
| 查看指定某个表的创建语句   | show create table 表名;      |
| 查看表结构                 | desc 表名;                   |
| 删除表                     | drop table [if exists] 表名; |

`desc 表名;`通过查询可以查看到该表的结构信息而不是具体的数据。

---

### 5.3.3 修改表结构

* 添加列

  语法格式

  ```sql
  alter table 表名 add 列名 类型(长度) [约束];
  #为student表添加一个新的字段为:系别 dept 类型为 varchar(20)
  alter table student add dept varchar(20);
  ```

* 修改列明和类型

  语法格式

  ```sql
  alter table 表名 change 旧列名 新列名 类型(长度)[约束];
  -- 为student表的dept字段更换为department varchar(30)
  alter table student change dept department varchar(30);
  ```

  注意：

  在DataGrip中右键点击左侧的表名，里面有一个修改表（旧UI），点进去可以看到详细的表结构（列名、数据类型等等）

* 删除列

  语法格式

  ```sql
  alter table 表名 drop 列名;
  #删除student表中department这列
  alter table student drop department;
  ```

* 修改表名

  语法格式

  ```sql
  rename table 表名 to 新表名;
  #例如:将表student改名成 stu
  rename table student to stu;
  ```

## 5.4 MySQL数据库基本操作-DML

### 5.4.1 基本介绍

DML是指数据操作语言，英文全称是Data Manipulation Language，用来对数据库中表的数据记录进行更新。

关键字:

* 插入insert
* 删除delete
* 更新update

#### 数据插入

列的类型和值的类型要一致，第一列要对应第一个值。

前面写了多少列，后面就写多少个值，且要一一对应。

若没有指定哪一列，则默认给所有列赋值。

* 格式1: 

  ```sql
  insert into 表 (列名1,列名2,列名3...) values (值1,值2,值3...);
  -- 或者：
  insert into 表 (列名1,列名2,列名3...) values (值1,值2,值3...),
  (值1,值2,值3...),
  (值1,值2,值3...);
  -- 相当于增加了3行数据，但是只用了一条语句，用逗号间隔开。
  
  insert into stu (sid, name, birth, gender, age, score) VALUES (1000,'洪永峰','2002-10-24','男',21,99.9);
  
  insert into stu (sid, name, birth, gender, age, score)
  VALUES (1001,'jim','2004-12-29','男',19,66.9),
         (1002,'marry','2001-1-23','男',22,88.9),
         (1003,'jane','2003-11-21','男',20,77.9);
         
  -- 只插入部分数据
  insert into stu (sid,score)values (1006,88.8);
  ```

* 格式2：

  ```sql
  insert into 表 values(值1,值2,值3...);
  -- 向表中插入一行数据（默认所有列都要插入）
  
  insert into stu values (1007,'booby','2000-5-31','女',23,55.5),
                         (1008,'bob','2006-2-3','女',17,55.5);
  ```

---

#### 数据修改

语法格式

```sql
-- 修改同一列的所有行的数据
update 表名 set 字段名(列名)=值,字段名=值...;
-- 将所有学生的性别改为男
update stu set gender ='男';

-- 修改同一列的所有符合条件的行的数据
update 表名 set 字段名=值,字段名=值...where 条件;
-- 将性别为女的学生的sid改为666
update stu set sid=666 where gender='女';
-- 将sid小于1000的学生的sid改为888
update stu set sid=888 where sid<1000;
-- 将sid为1006的学生的姓名改为tom，生日改为1999-10-10
update stu set name='tom',birth='1999-10-10' where sid=1006;
```

---

#### 数据删除

```SQL
delete from 表名 [where 条件];-- 不加条件则会把整个表的数据都删除。
-- 以下两行代码是一样的。
truncate table 表名;
truncate 表名;
```

注意: delete和truncate原理不同，delete只删除内容，而truncate类似于drop table，可以理解为是将整个表删除,然后再创建该表:

---

#### 查询所有数据

```SQL
select * from 表名;
-- “*”意思是：指查询表或视图中的所有字段。
-- 查询单个字段
select 字段名 from 表名;

-- 查询多个字段
select 字段1,字段2.... from 表名;

-- 条件查询
select 字段1,字段2,... from 表名 where 条件;
```

---

### 练习

```sql
-- 1.创建表
/*
创建员工表employee,字段如下:
id (员工编号)，name (员工名字)，gender(员工性别)，salary(员工薪资)
 */
-- use mysql_test1;
-- 这里可以直接用数据库名.表名的方法
-- 但下文所涉及表名employee的代码前都要加上mysql_test1.
create table if not exists mysql_test1.employee(
    id int,
    name varchar(20),
    gender varchar(2),
    salary double
);

-- 2.插入数据
/*
1，'张三'，'男',2000
2，'李四'，'男',1000
3，'王五'，'女',4000
 */
insert into employee (id, name, gender, salary)
values (1,'张三','男',2000),
       (2,'李四','男',1000),
       (3,'王五','女',4000);


-- 3.修改表数据
-- 3.1 将所有员工薪水修改为5000元。
update employee set salary=5000;
-- 3.2 将姓名为’张三’的员工薪水修改为3000元。
update employee set salary=3000 where name='张三';
-- 3.3 将姓名为'李四’的员工薪水修改为4900元,gender改为女
update employee set salary=4900,gender='女' where  name='李四';
-- 3.4 将王五的薪水在原有基础上增加1099元。
update employee set salary=salary+1000 where name='王五';
```

如果没有使用`use 数据库名;`来运行数据库，且又想更改数据库的表里面的数据，可以用`数据库名.表名`的方法修改表的数据。

---

## 5.5 MySQL约束

**概念**

* 约束英文:constraint
* 约束实际上就是表中数据的限制条件
* 创建表的时候可以用到约束

**作用**

* 表在设计的时候加入约束的目的就是为了保证表中的记录完整性和有效性，比如用户表有些列的值(手机号)不能为空，有些列的值(身份证号)不能重复。

**分类**

* **主键约束**(primary key) PK
  * 限定列的值唯一，而且不能为空
* **自增长约束**(auto increment)
  * 与主键约束搭配使用
  * 加上了这个约束后，这一列的值会自动增长，不用手动操作。
* 非空约束(not null)
  * 这一列的值不能为空
  * 用法和主键约束的方法1一样。
* 唯一性约束(unique)
  * 这一列的值不能重复
* 默认约束(default)
  * 没有人为给这一列赋值的话，会自动赋一个默认值。
* 零填充约束(zerofill)
  * 不赋值时，自动填充值为0
* 外键约束(foreign key) FK

---

### 5.5.1 MySQL约束--主键约束

#### 概念

* MySQL主键约束是**一个列或者多个列**的组合，其值能**唯一**地标识表中的每一行，方便在RDBMS中尽快的找到某一行。
* 主键约束相当于 **唯一约束**+**非空约束** 的组合，主键约束列不允许重复，也不允许出现空值。
* 每个表最多只允许**一个**主键
* 主键约束的关键字是: **primary key**
* 当创建主键的约束时，系统默认会在所在的列和列组合上建立**对应的唯一索引**。

#### 操作

##### 创建单列主键

* 方法1：在定义字段的同时指定主键

  * ```sql
    -- 在 create table 语句中，通过 PRIMARY KEY 关键字来指定主键
    create table 表名(
    	字段名 数据类型 primary key,
        -- 例如：
        id int primary key
    );
    
    ```

    

* 方法2：定义完字段之后指定主键

  * ```sql
    -- 在定义字段之后再指定主键，语法格式如下:
    create table 表名(
    	[constraint 约束名(自己定的)] primary key [字段名]
    );
    
    create table emp2(
    	constraint pk1 primary key(id)
    );
    ```

注意：不能在有主键标记的列中插入重复的数据，也不能插入以null为值的数据。

---

##### 添加多列联合主键

所谓的联合主键，就是这个主键是由一张表中多个字段组成的。

**注意**:

* 1.当主键是由多个字段组成时，**不能直接**在字段名后面声明主键约束（即单列主键的方法1不适用）
* 2.一张表只能有一个主键，联合主键也是一个主键。
* 3.只要联合主键标记的字段不同时相同则可以写入该行数据。
* 4.SQL代码是一行一行执行的，即使下面的代码有错误，他也会执行完上面没有错误的代码。
* 5.联合主键的每一列都不能为空

**语法**：

```sql
create table 表名(
	[constraint 约束名] primary key(字段1,字段2,...,字段n)
);

create table emp3(
    name varchar(20),
    deptid int,
    salary double,
	primary key(name,deptid)
);
```

---

##### 通过修改表结构添加主键

主键约束不仅可以在创建表的同时创建，也可以在修改表时添加。

语法:

```sql
create table 表名(
	....
);
alter table 表名 add primary key(字段列表);
```

字段列表可以是一列也可以是多列.

```sql
alter table emp4 add primary key(eid);
alter table emp5 add primary key(eid,name);
```

---

##### 删除主键约束

一个表中不需要主键约束时，就需要从表中将其删除。删除主键约束的方法要比创建主键约束容易的多。

格式:

```sql
alter table 表名 drop primary key;
```

无论是单列主键还是联合主键都是用这行代码来删除的。

---

### 5.5.2 MySQL约束-自增长约束(auto increment)

#### 概念

在 MySQL中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值每增加一条记录，主键会自动以相同的步长进行增长。

通过给字段添加auto_increment 属性来实现主键自增长。

#### 语法

```sql
字段名 数据类型 auto_increment;
-- 例：
create table t_user1(
	id int primary key auto_increment,
    name varchar(20)
);
```

#### 特点

* 默认情况下，auto_increment的初始值是 1，每新增一条记录，字段值自动加1。
* 一个表中只能有一个字段使用 auto_increment约束(相当于只能有一个主键约束)，且该字段必须有唯一索引，以避免序号重复(即为主键或主键的一部分)。
* auto_increment约束的字段必须具备 NOT NULL 属性。
  * 如果人为给该受约束的字段赋值，则该行存储的数据就是人为赋值的数据；如果没有为该受约束的字段赋值或给该受约束的字段赋NULL值，则给该受约束的字段赋的值默认为上一行的值+1.
* auto_increment约束的字段只能是整数类型 ，如TINYINT、SMALLINT、INT、BIGINT等。一开始可以赋值为NULL，即使用户输入进去的是NULL，该列第一行的数据默认值为1，且从1开始增加。
* auto_increment约束字段的最大值受该字段的数据类型约束，如果达到上限，auto_increment就会失效。

#### 指定自增长的初始值

方式一：创建表时创建

```sql
create table t_user3(
	id int primary key auto_increment,
    name varchar(20)
)auto_increment=100;
-- 初始值设定为100
```

方式二：创建表之后指定

```sql
create table t_user3(
	id int primary key auto_increment,
    name varchar(20)
);
alter table t_user2 auto_increment=100;
-- 初始值设定为100
```

---

#### delete和truncate在删除后自增列的变化

* delete数据之后自动增长从断点开始（自增长会保留上一次的数据，上一次增长到多少这次就是多少）
  * delete删除数据（可以是删除整个表的数据，也可以删除其中一行或几行的数据）之后，自增长还是在最后一个值基础上加1。
* truncate删除数据之后自动增长**从默认起始值1**开始，无论你有没有设定起始值。

---

### 5.5.3 MySQL约束-非空约束(not null)

#### 概念

MySQL非空约束(not null)指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。

#### 语法

```sql
-- 方式1：创建表时指定
字段名 数据类型 not null;
name varchar(20) not null;
-- 方式2：创建表之后指定
alter table 表名 modify 字段 类型 not null;
alter table t_user7 modify name varchar(20) not null;

-- 删除非空约束
alter table 表名 modify 字段 类型;
alter table t_user7 modify name varchar(20);
-- 即创建的方式2不加后面的not null。
```

注意：

一个语句是从左到右执行的。多个语句是从上到下执行的。

如果有一处有错误，则不会往后继续执行。

null是空的意思，与'null'不同，与''也不同。

'null'是一个字符串null。

''是空串，引号之间没有内容。

---

### 5.5.4 MySQL约束-唯一约束(unique)

#### 概念

唯一约束(Unique Key) 是指所有记录中字段的值不能重复出现。例如，为id 字段加上唯一性约束后，每条记录的id 值都是唯一的，不能出现重复的情况。

#### 语法

```sql
-- 方式1：
字段名 数据类型 unique;
phone_number varchar(20) unique;

-- 方式2：
alter table 表名 add constraint 约束名 unique(列名);
alter table t_user9 add constraint unique_pn unique(phone_number);

-- 删除唯一约束
alter table 表名 drop index 唯一约束名;
alter table t_user9 drop index unique_pn;
-- 如果没有约束名（使用方式1创建唯一约束），则该约束名默认为该列的名字。
```

注意：

在MySQL中NULL和任何值都不相同，甚至和自己都不相同。

唯一约束修饰的字段可以有重复的null，但除了null外，输入其他重复的数据则会报错。

---

### 5.5.5 MySQL约束-默认约束(default)

#### 概念

MysQL默认值约束用来指定某列的默认值。

#### 语法

```sql
-- 方式1：
字段名 数据类型 default 默认值;
address varchar(20) default '北京';

-- 方式2：
alter table 表名 modify 列名 类型 default 默认值;
alter table t_user11 modify address varchar(20) default '深圳';

-- 删除默认约束
alter table 表名 modify 列名 类型 default null;
alter table t_user11 modify address varchar(20) default null;
```

#### 特点

如果指定了默认值后，还对该字段赋值，那么存储的则是自己人为赋的值（可以赋值null值），该行的默认值失效；没有人为地对该字段赋值的话，则存储的是默认值。

---

### 5.5.6 MySQL约束- 零填充约束(zerofill)

#### 概念

* 1、插入数据时，当该字段的值的长度**小于**定义的长度时，会在该值的前面补上相应的0
* 2、zerofill默认为int(10)，整数的长度为10位数。
* 3、当使用zerofill 时，默认会自动加unsigned(无符号)属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128~+127，无符号为0~256。
* 注意：
  * 补0的操作并不是把0存储进相应的位置，而是看起来数值的前面多了几个0，实际上的数值还是原来没有补0的数值.

#### 操作

```sql
create table t_user12(
	id int zerofill,
    name varchar(20)
);

-- 删除
alter table t_user12 modify id int;
```

---

### 5.5.7 外键约束

外键用来让两个表数据之间建立链接，保证数据的一致性和完整性

#### 语法

```sql
-- 创建表时添加外键约束
create table 表名(
	列名 数据类型,
    ...........
    [constraint] [外键名称] foreign key(外键列名) references 主表(主表列名)
); 
```

外键约束之后，两张表链接之后无法删除已经连接的键

#### 删除表

```SQL
alter table 表名 drop foreign key (键);
```

---

## 5.6 MySQL数据库基本操作-DQL-基本查询

### 概念

* 数据库管理系统一个重要功能就是数据查询，数据查询不应只是简单返回数据库中存储的数据，还应该根据需要对数据进行筛选以及确定数据以什么样的格式显示。
* MySQL提供了功能强大、灵活的语句来实现这些操作。
* MySQL数据库使用select语句来查询数据。

### 语法格式

```sql
select
[all|distinct]
	<目标列的表达式1> [别名],
	<目标列的表达式2> [别名]...
from <表名或视图名>[别名],<表名或视图名> [别名]...
[where<条件表达式>]
[group by <列名>
[having <条件表达式>]]
[order by <列名> [asc|desc]]-- 升序还是降序
[limit <数字或者列表>];
```

### 简化版语法

```sql
select * 列名 from 表 where 条件;
```

---

### 简单查询

```sql
-- 1.查询所有的商品.
select * from product;
select 列名1,列名2,....,所有列名 from product;
-- product是表名

-- 2.查询商品名和商品价格.
select pname,price from product;

-- 3.别名查询,使用的关键字是as (as是可以省略的)
-- 3.1表别名:
select * from product as p;
-- 给表product取了个别名p

select e.salary from employee e;
-- 给表employee取了个别名e，可以直接用e来调用该表的列名salary。

-- 3.2列别名:
select pname as pn from product;
select pname as '商品名',price '商品价格' from product;

-- 4.去掉重复值.
select distinct price from product;

-- 去除所有列都重复了的那一行的值。
-- 如果某一行和另外一行的数据全部一样，则把这一行去掉，只留下一行不重复的数据。
select distinct * from product;

-- 5.查询结果是表达式(运算查询) : 将所有商品的价格+10元进行显示
select pname,price+10 new_price from product;
-- 其中new_price是别名，如果不起别名，这里就会显示该列列名为price+10
```

注意：

*号表示所有的列

---

### 运算符

数据库中的表结构确立后，表中的数据代表的意义就已经确定。通过MySQL运算符进行运算，就可以获取到表结构以外的另一种数据。

例如，学生表中存在一个birth字段，这个字段表示学生的出生年份。而运用MySQL的算术运算符用当前的年份减学生出生的年份，那么得到的就是这个学生的实际年龄数据。

MySQL支持4种运算符

* 算术运算符

  * ```sql
    select name,price*1.1 as new_price from product;
    ```

    将所有商品的价格上调10%，这只会在控制台输出对应的表格，不会将上调后的数据写入原来的表格product中。

  * 除以可以是/，也可以是div；取余可以是%，也可以是mod。

* 比较运算符

* 逻辑运算符

* 位运算符

#### 比较运算符

| 比较运算符       | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| =                | 等于                                                         |
| <和<=            | 小于和小于等于                                               |
| >和>=            | 大于和大于等于                                               |
| <=>              | 安全的等于，两个操作码均为NULL时，其所得值为1;而当一个操作码为NULL时，其所得值为0 |
| <>或!=           | 不等于                                                       |
| IS NULL 或ISNULL | 判断一个值是否为 NULL                                        |
| IS NOT NULL      | 判断一个值是否不为 NULL                                      |
| LEAST            | 当有两个或多个参数时，返回最小值                             |
| GREATEST         | 当有两个或多个参数时，返回最大值                             |
| BETWEEN AND      | 判断一个值是否落在两个值之间                                 |
| IN               | 判断一个值是IN列表中的任意一个值                             |
| NOT IN           | 判断一个值不是IN列表中的任意一个值                           |
| LIKE             | 通配符匹配                                                   |
| REGEXP           | 正则表达式匹配                                               |

<=>是完全等于，用于比较null值。

---

#### 逻辑运算符

| 逻辑运算符  | 说明     |
| ----------- | -------- |
| NOT 或者!   | 逻辑非   |
| AND 或者 && | 逻辑与   |
| OR 或者\|\| | 逻辑或   |
| XOR         | 逻辑异或 |

  逻辑异或:不同为真，相同为假。

---

#### 位运算符

| 位运算符 | 说明                   |
| -------- | ---------------------- |
| \|       | 按位或                 |
| &        | 按位与                 |
| ^        | 按位异或               |
| <<       | 按位左移               |
| >>       | 按位右移               |
| ~        | 按位取反，反转所有比特 |

位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。

然后再将计算结果从二进制数变回十进制数。

---

#### 练习

```sql
-- 查询价格不是800的所有产品
select * from product where price != 800;
select * from product where price <> 800;
select * from product where not (price= 800);
```

```sql
-- 查询商品价格大于等于60元的所有商品信息
select * from product where price>=60;

-- 查询商品价格在200到1000之间所有商品
select * from product where price>=200 and price<=1000;
select * from product where between 200 and 1000;
select * from product where price>=200 && price<=1000;

-- 查询商品价格是200或800的所有商品
select * from product where price in(200,800);
select * from product where price =200 or price=800;
select * from product where price =200 || price=800;
```

```sql
-- 查询含有'裤'字的所有商品
select * from product where pname like '%裤%';-- %用来匹配任意字符

-- 查询以'海'开头的所有商品
select * from product where pname like '海%';-- %用来匹配任意(可以是多个)字符

-- 查询以'海'结尾的所有商品
select * from product where pname like '%海';

-- 查询第二个字为'澜'的所有商品
select * from product where pname like '_澜%';-- 下划线匹配单个字符
```

```sql
-- 查询category_id为null的商品
select * from product where category_id is null;

-- 查询category_id不为null分类的商品
select * from product where category_id is not null;

-- 使用least求最小植
select least(10,5,20) as small_number;
select least(10,null,20) as small_number;-- 如果求最小值时，有个值为null，则不会进行比较，结果直接为null;

-- 使用greatest求最大值
select greatest(10,30,20) as big_number;
select greatest(10,null,20) as big_number;-- 如果求最大值时，有个值为null，则不会进行比较，结果直接为null;
```

##### 位运算练习

```sql
select 3&5; -- 位与
3-- 0011
5-- 0101
1-- 0001
-- 有0就是0，全1才为1

select 3|5;-- 位或
3-- 0011
5-- 0101
7-- 0111
-- 有1则为1，全0则为0

select 3^5;-- 位异或
3-- 0011
5-- 0101
6-- 0110
-- 相同为0，不同为1

select m>>n;-- 将十进制数m的二进制位向右移n位，最高位补0.（正数）
select 3>>1;-- 位右移
-- 0011>>向右移1位----------->0001
select 8>>2;-- 2

select 3<<1;-- 位左移
-- 0011<<1 --->0110--->6

select -3;-- 位取反
-- 将32位二进制位全部取反，0变成1，1变成0。
```

---

### 排序查询

#### 介绍

如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 **order by** 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果

```sql
select
字段名1，字段名2，.....
from 表名
order by 字段名1 [asc|desc]，字段名2[asc|desc]...........;
-- 先对字段名1进行排序，如果字段1的值有相同的再按字段2来排序
-- 字段名1是排序的主要条件，字段名2是排序的次要条件。
```

#### 特点

* 1.asc代表升序，desc代表降序，如果**不写默认升序**
* 2.order by用于子句中可以支持单个字段，多个字段，表达式，函数，别名
* 3.order by子句，放在查询语句的最后面。LIMIT子句除外。

```sql
-- 1.使用价格排序(降序)
select * from product order by price desc ;

-- 2.在价格排序(降序) 的基础上，以分类排序(降序)
select * from product order by price desc ,category_id;

-- 3.显示商品的价格(去重复)，并排序(降序)
select distinct price from product order by price desc ;
-- 注意：去重排序只能显示一个字段，下面这种是错的。
select pname,distinct price from product order by price desc;
```

---



### 聚合查询

#### 简介

之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值;另外聚合函数会忽略空值。

| 聚合函数 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| count()  | 统计指定列不为NULL的**记录行数**;如果是null，则不会统计进去。 |
| sum()    | 计算指定列的**数值和**，如果指定列类型不是数值类型，那么计算结果为0。如果是null，则不会统计进去。 |
| max()    | 计算指定列的**最大值**，如果指定列是字符串类型，那么使用字符串排序运算。如果是null，则不会统计进去。 |
| min()    | 计算指定列的**最小值**，如果指定列是字符串类型，那么使用字符串排序运算。如果是null，则不会统计进去。 |
| avg()    | 计算指定列的**平均值**，如果指定列类型不是数值类型，那么计算结果为0。如果是null，则不会统计进去。 |

```sql
-- 1 查询商品的总条数
select count(pid) from product;
select count(*) from product;

-- 2 查询价格大于200商品的总条数
select count(pid) from product where price>200;

-- 3 查询分类为'c001'的所有商品的总和
select * from product where category_id='c001';

-- 4 查询商品的最大价格
select max(price) from product;

-- 5 查询商品的最小价格
select max(price) ,min(price) from product;
select max(price) max_price,min(price) min_price from product;
-- select max(price) （别名1）,min(price) （别名2） from product;

-- 6 查询分类为'c002'所有商品的平均价格
select avg(price) from product where category_id='c002';
```

---

#### NULL值的处理

```sql
insert into test values('aaa',3);
insert into test values('bbb',3);
insert into test values('ccc',null);
insert into test values('ddd',6);

select count(*),count(1),count(c) from test;-- 4 4 3
-- count(*)等价于count(1)

select sum(c2),max(c2),min(c2),avg(c2) from test;-- 12 6 3 4
-- 平均值为4==12/3，忽略了null值。
-- 如果将null改为0，则平均值为3.
```

---

### 分组查询

分组查询是指使用**group by**字句对查询信息进行分组

```sql
select 字段1,字段2... from 表名 group by 分组字段 having 分组条件;
```

注意；分组之后，select的后边只能写**分组字段**和**聚合函数（统计函数）**

```sql
-- 统计各个分类商品的个数
select category_id,count(pid) from product group by category_id;
```

group by后面的字段的顺序可以随机。

`select ... from product group by 市，省，县;`

group by后面的所有字段相同才能分到同一组。

#### 分组之后的条件筛选-having

* 分组之后对统计结果进行筛选的话必须使用having，不能使用where。

* where子句用来筛选FROM子句中指定的操作所产生的行，where肯定是加在from的后面

* group by 子句用来分组WHERE子句的输出。

* having 子句用来从分组的结果中筛选行

* 格式：

  ```sql
  select 字段1,字段2... from 表名 where 条件 group by 分组字段 having 分组条件;
  ```

* 操作：

  * 统计各个分类商品的个数，且只显示个数大于4的信息

  * ```sql
    select category_id,count(pid) cnt from product group by  category_id having  cnt>4 order by cnt;
    ```

注意：

**SQL执行顺序;from -> group by -> count(pid) -> select -> having -> order by**

---

### 分页查询-limit

#### 简介

分页查询在项目开发中常见，由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条。

#### 格式

```sql
-- 方式1->显示前n条
select 字段1，字段2... from 表名 limit n;
-- 方式2-分页显示
select 字段1，字段2... from 表名 limit m,n;
-- m:整数，表示从第几条索引开始，计算方式 (当前页-1) *每页显示条数
-- n:整数，表示查询多少条数据
```

注意：

* m是索引编号，第一条的编号是0。
* limit语句一般放在一条语句的最后。

#### 操作

```sql
-- 分页查询-limit
-- 1.查询product表的前5条记录
select * from product limit 5;

-- 2.从第4条开始显示，显示5条
select * from product limit 3,5;

-- 3.分页显示
select * from product limit 0,60;       -- 第1页-->m=(1-1)*60
select * from product limit 60,60;      -- 第2页-->m=(2-1)*60
select * from product limit 120,60;     -- 第3页-->m=(3-1)*60
-- select * from product limit (n-1),60;-- 第n页-->m=(n-1)*60
```

---

### insert into select语句

#### 简介

将一张表的数据导入到另一张表中，可以使用INSERT INTO SELECT语句。

格式

```sql
insert into Table2(field1,field2,...) select valuel.value2... from Table1;
或者:
insert into Table2 select * from Tablel;
```

注意：

* 要求目标表Table2必须存在
* 字段field1、field2可以不写，但是select后面的字段一定要和Table2表的列的数据类型匹配。

```sql
create table product2(
    pname varchar(20) not null ,-- 商品名字
    price double
);

insert into product2(pname, price) select pname,price from product;
select * from product2;
```

```sql
create table product3(
    category_id varchar(20) ,-- 商品类型
    sum int
);

insert into product3 select category_id,count(*) from product group by category_id;
select * from product3;
```

---

## 5.7 多表查询

```SQL
select * from 表1,表2;
```

但是这种简单的多表查询会查询到两表的笛卡尔积，而不能对应原本设置的连接去查询，我们需要消除无效数据

可以通过给表中数据添加条件去消除无效数据。

```SQL
select * from 表1,表2 where 条件;
```

---

## 5.8 连接查询

### 内连接

相当于查询A B交集数据

隐式内连接

```SQL
select 字段列表 from 表1, 表2……where 条件
```

显式内连接

```SQL
select 字段列表 from 表1 inner join 表2 on 条件;
```

### 外连接

#### 左外连接

查询A表所有数据和交集部分的数据

```SQL
select 字段列表 from 表1 left outer join 表2 on 条件;
```

#### 右外连接

查询B表所有数据和交集部分数据

```SQL
select 字段列表 from 表1 right outer join 表2 on 条件;
```

## 5.9 子查询

查询中嵌套查询

```SQL
select …… from …… where(select……);
```

子查询根据查询结果不同，作用不同:

* 单行单列:作为条件值，使用 =  != >  <  等进行条件判断

  ```sql
  select 字段列表 from 表 where 字段名 = (子查询);
  ```

* 多行单列:作为条件值，使用 in 等关键字进行条件判断

  ```sql
  select 字段列表 from 表 where 字段名 in (子查询);
  ```

* 多行多列:作为虚拟表

  ```sql
  select 字段列表 from (子查询) where 条件;
  ```

---

# 6 MySQL的JDBC操作

## 6.1 JDBC概述

JDBC(Java DataBase Connectivity，java数据库连接)是一种用于执行SQL语句的Java API。

**JDBC是Java访问数据库的标准规范**，可以为不同的关系型数据库提供统一访问，**它由一组用Java语言编写的接口和类组成**。

JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。

---

## 6.2 JDBC核心类和接口

* DriverManager:用于注册驱动
* Connection:表示与数据库创建的连接
* Statement/PrepareStatement:操作数据库sql语句的对象
* ResultSet:]结果集或一张虚拟表

## 6.3 执行流程

* 1.在java程序中**注册驱动**
  * DriverManager .registerDriver(驱动);
* 2:建立与数据库服务器的连接
  * DriverManager.getConnection(ip,端口,数据库,用户名，密码) ;
* 3:将sql指令发送给数据库服务器执行
  * statement/Preparedstatement
  * executeUpdate()
    * 增删改
  * executeQuery ()
    * 查询
* 4:处理数据库服务器返回的结果
  * 返回行数rows
  * 返回一张表（结果集）ResultSet
* 5:释放资源
  * close();

---

## 6.4 代码实现--jdbc查找操作

把驱动文件（.jar）添加进idea的某个项目的lib文件夹中

右键该jar包，选择add as library，添加为库。

本机的IP地址就直接写localhost

如果是网络服务器则写对应的ip地址

```java
import java.sql.*;

public class MySQLConnection {
    public static void main(String[] args) throws SQLException {
        //1: 注册驱动
        //DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        //这个驱动已经过时了，已经弃用了，其实早就集成了。所以不需要执行这句话了

        //2: 获取连接
        Connection connection=DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql_test","root","root");

        //3: 执行sql
        Statement statement=connection.createStatement();
        ResultSet resultSet=statement.executeQuery("select * from signIn");

        //4: 处理结果集
        while (resultSet.next()){//获取每一行数据
            //获取每一列数据
            int id=resultSet.getInt(1);
            String userName=resultSet.getNString(2);
            //索引编号为1，则为第一列，而不是从0开始，从0开始是错的。
            String password=resultSet.getNString("password");
            long phoneNumber=resultSet.getLong("phoneNumber");
            String email=resultSet.getNString(5);
            System.out.println(id+"\t"+userName+"\t"+password+"\t"+phoneNumber+"\t"+email);
        }

        //5:关闭连接
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

url的写法：

```java
getConnection(String url,String user,String password);
//url:连接路径
url="jdbc:mysql://localhost:3306/mysql_test";
url="jdbc:mysql://IP地址（域名）:端口号/数据库名称?参数键值对1&参数键值对2...";
//user:用户名
//password:密码
```

如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为: 

```
jdbc:mysql:///数据库名称?参数键值对
```

配置useSSL=false 参数，禁用安全连接方式，解决警告提示.

---

### 获取执行SQL的对象

* 普通执行SQL对象

  ```java
  Statement createStatement()
  ```

* 预编译SQL的执行SQL对象: 防止SQL注入

  ```java
  PreparedStatement prepareStatement(sql)
  ```

* 执行存储过程的对象

  ```java
  CallableStatement prepareCall(sql)
  ```


---

### Statement作用

1. 执行SQL语句

```java
int executeUpdate(sql);//: 执行DML、DDL语句
//返回值:(1) DML语句影响的行数(2) DDL语句执行后，执行成功也可能返回 0

ResultSet executeQuery(sql);// 执行DQL 语句
//返回值:ResultSet 结果集对象

```

---

### ResultSet(结果集对象)作用

封装了DQL查询语句的结果

```java
ResultSet statement对象.executeQuery(sql);// 执行DQL 语句，返回 ResultSet 对象
```

* 获取查询结果

* ```java
  boolean next(); //(1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行
  /*返回值:
  true: 有效行，当前行有数据
  false: 无效行，当前行没有数据
  ```

  ```java
  XXX getXxx(参数);//获取数据
  xxx:数据类型，如: 
  int getInt(参数);
  String getString(参数);
  //参数:
  int: 列的编号，从1开始
  String: 列的名称
  ```

* 使用步骤

  * 1.游标向下移动一行，并判断该行否有数据:next()

  * 2.获取数据:getXxx(参数)

    ```java
    //循环判断游标是否是最后一行末尾
    while(resultSet.next()){
        //获取数据
        resultSet.getXxx(参数)
    }
    ```

    

---

结果集优化

getColumnCount()获取表的列数

getColumnName()获取表的列名

```java
//3: 执行sql
Statement statement=connection.createStatement();
ResultSet resultSet=statement.executeQuery("select * from stu");

//获取表的列数
ResultSetMetaData metaData= resultSet.getMetaData();
int columnCount= metaData.getColumnCount();

//4: 处理结果集
while (resultSet.next()){//获取每一行数据
    //获取每一列数据
    for (int i=1;i<columnCount;i++){
        System.out.print(resultSet.getObject(i)+"\t");
    }
    System.out.println();
}
```

---

## 6.5 jdbc增删改操作

```java
//3: 执行sql
        Statement statement=connection.createStatement();
        //3.1：增加数据
        row表示收到影响的行数
        int rows1= statement.executeUpdate("insert into signIn values (null,'tom','888',122,'123asd')");

        //3.2：删除数据
        int rows2= statement.executeUpdate("delete from signIn where userName='tom'");
        System.out.println(rows2);

        //3.3：修改数据
        int rows3= statement.executeUpdate("update signIn set phoneNumber =555 where id=3");

        //4:关闭连接
        statement.close();
        connection.close();
```

---

## 6.6 错误代码

```
ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost:3306' (10061)
```

可能是MySQL的服务没有启动，用完jdbc之后，MySQL的服务可能会停止了。所以需要手动开启。

---

## 6.7 事务管理

数据库的**事务** (Transaction)是一种机制、一个操作序列，包含了**一组数据库操作命令**.

事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令**要么同时成功，要么同时失败**。

事务是一个不可分割的工作逻辑单元.

事务的四大特征：

* 原子性(Atomicity):事务是不可分割的最小操作单位，要么同时成功，要么同时失败
* 一致性(Consistency) :事务完成时，必须使所有的数据都保持一致状态
* 隔离性 (lsolation) :多个事务之间，操作的可见性
* 持久性(Durability) :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

* MySQL事务管理

  * 开启事务: BEGIN;/START TRANSACTION;
  * 提交事务: COMMIT;
  * 回滚事务: ROLLBACK;
  * MySQL默认自动提交事务

* MySQL事务默认自动提交

  ```sql
  -- 查看事务的默认提交方式
  select @@autocommit;
  -- 1 自动提交  0 手动提交
  -- 修改事务提交方式
  set @@autocommit = 0;
  ```

  

* JDBC事务管理: Connection接口中定义了3个对应的方法

  * 开启事务: 
    * setAutoCommit(boolean autoCommit): true为自动提交事务；
  * false为手动提交事务，即为开启事务
  * 提交事务: commit()
  * 回滚事务: rollback()

