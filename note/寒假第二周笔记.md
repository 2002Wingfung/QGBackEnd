# 1 面向对象

## 1.0 只有一个对象的内存分配过程

```java
//两个类位于同一个package
public class Phone {

    // 成员变量
    String brand; // 品牌
    double price; // 价格
    String color; // 颜色

    // 成员方法
    public void call(String who) {
        System.out.println("给" + who + "打电话");
    }

    public void sendMessage() {
        System.out.println("群发短信");
    }
}

public class Demo01PhoneOne {

    public static void main(String[] args) {
        // 根据Phone类，创建一个名为one的对象
        // 格式：类名称 对象名 = new 类名称();
        Phone one = new Phone();
        System.out.println(one.brand); // null
        System.out.println(one.price); // 0.0
        System.out.println(one.color); // null
        System.out.println("=========");

        one.brand = "苹果";
        one.price = 8388.0;
        one.color = "黑色";
        System.out.println(one.brand); // 苹果
        System.out.println(one.price); // 8388.0
        System.out.println(one.color); // 黑色
        System.out.println("=========");

        one.call("乔布斯"); // 给乔布斯打电话
        one.sendMessage(); // 群发短信
    }

}

```

## 具体步骤

- 先将Phone.class类存入方法区(Method Area)

  - 注意：成员变量的具体内容（未赋值）、成员方法的信息都存放于此区内。

- 然后将main(String[] args)存入栈内

  - 随后再new一个对象one

- 将Phone的具体内容存入堆中

  - 对成员变量赋默认值

    `String brand=null;`

    `double price=0.0;`

    `String color=null;`

  - 对成员方法的地址赋值

    将方法区中的成员方法的地址值赋值给堆中的成员方法

- 将Phone类的地址赋值给main方法中的对象one

- 接着可以使用对象及其成员变量或成员方法了

  - `one.brand = "苹果";`
  - `one.call("乔布斯");` // 给乔布斯打电话
    `one.sendMessage();` // 群发短信

- 注意：先进入栈的方法就相当于是沉到栈的底部，后进入栈的方法就放置在先进入栈的方法的上方，这也叫压栈。

- 执行one.call("乔布斯")时，先将call(String who)存入栈中。

  - 输出“给who打电话”
  - 执行完后call方法自动从栈中消失。

- 然后继续存入下一个方法one.sendMessage()

  - 输出“群发短信”。
  - 执行完sendMessage方法后，其自动从栈中消失。

- 此时main方法也执行完了，其也自动从栈中消失。

- 注意：执行除了main以外的任何一种方法的话，都要通过对象找到堆区中对应方法的地址，再根据该地址找到方法区中对应的方法，然后将该方法存入栈区。这就好像C语言中函数的嵌套。而main方法是直接在栈中执行，堆中没有存放main方法。

------

## 1.1 两个对象使用同一个方法

```java
//其他代码同上
		Phone two = new Phone();
        System.out.println(two.brand); // null
        System.out.println(two.price); // 0.0
        System.out.println(two.color); // null
        System.out.println("=========");

        two.brand = "三星";
        two.price = 5999.0;
        two.color = "蓝色";
        System.out.println(two.brand); // 三星
        System.out.println(two.price); // 5999.0
        System.out.println(two.color); // 蓝色
        System.out.println("=========");

        two.call("欧巴"); // 给欧巴打电话
        two.sendMessage(); // 群发短信
```

其中对象one和two都使用了Phone类的同一个方法call和sendMessage。

而方法区中成员方法的地址值只有一个，因此堆中new Phone()里面的成员方法都是同一个地址值的。

但对象one和two他们的地址值是肯定不同的。

------

## 1.2 两个引用指向同一个对象

```java
//其他代码同上  
// 将one当中保存的对象地址值赋值给two
        Phone two = one;//特别的地方
        System.out.println(two.brand); // 苹果
        System.out.println(two.price); // 8388.0
        System.out.println(two.color); // 黑色
        System.out.println("=========");

        two.brand = "三星";
        two.price = 5999.0;
        two.color = "蓝色";
        System.out.println(two.brand); // 三星
        System.out.println(two.price); // 5999.0
        System.out.println(two.color); // 蓝色
        System.out.println("=========");

        two.call("欧巴"); // 给欧巴打电话
        two.sendMessage(); // 群发短信
```

------

## 1.3 对象名的作为地址值的使用

带有static的方法就是一个普通的方法，他不需要对象，直接就能调用。

注意：任何数据类型都能作为参数，数组名也行，如`public static void method(int[] array)`

自定义类型Phone也能作为参数，如`public static void method(Phone param)`

作为参数传递进去的是对象param的地址值

用法：`method(one);`//one是对象名

------

## 1.4 使用对象类型作为方法的返回值

```java
public class Phone {//注意这里没有static
    int price;
    String brand,color;
}
public class demo01_address_of_duixiang {
    public static void main(String[] args) {
        Phone two=getaddress();
        System.out.println(two.color);
        System.out.println(two.price);
        System.out.println(two.brand);
    }
    public static Phone getaddress(){//注意这个static不能漏。Phone类的getaddress方法。这类似于一个指针函数，但有些不同
        Phone one=new Phone();
        one.color="蓝色";
        one.brand="三星";
        one.price=123;
        return one;//返回的是地址
    }
}

```

- 其实返回值是一个**地址值**。

- 注意，在同一个源文件中，如果在有static的方法之中调用没有static的方法则会报错。错误原因是：无法从静态上下文中引用非静态。

  如果是不同源文件的话，有没有static都不会报错。

  这是JDK新版本的特性，前面的版本好像没这个问题。

------

## 1.5 成员变量和局部变量的区别

局部变量和成员变量

- 定义的位置不一样
  - 局部变量:在方法的内部
  - 成员变量:在方法的外部，直接写在类当中
- 作用范围不一样
  - 局部变量，只有方法当中才可以使用，出了方法就不能再用
  - 成员变量，在整个类中全都可以通用。
- 默认值不一样
  - 局部变量:没有默认值，如果要想使用，必须手动进行赋值，不赋值而直接使用就会报错。
  - 成员变量:如果没有赋值，会有默认值，规则和数组一样
- 内存的位置不一样(了解)
  - 局部变量，位于栈内存
    - 方法的参数就是局部变量，不用赋初始值，也不会报错，因为在调用方法的时候，必然会被赋值的。
  - 成员变量，位于堆内存
- 生命周期不一样(了解)
  - 局部变量，随着方法进栈而诞生，随着方法出栈而消失
  - 成员变量:随着对象创建而诞生，随着对象被回收而消失，这个被回收的时间是不确定的，当这个对象再也没用到的时候，JVM会在合适的时候将这块内存清除掉。

------

## 1.6 面向对象三大特征之封装性

面向对象三大持征:封装(最简单)、继承、多态

封装性在Java当中的体现：

1.**方法**就是一种封装

2.关键字**private**也是一种封装

封装就是将一些**细节信息**或**具体步骤**隐藏起来，对于外界不可见，调用**被封装的方法**的方法不需要知道被封装的方法里面是怎么执行的。

------

## 1.7 private关键字的作用及使用

问题描述，定义Person的年龄时，无法阻止不合理的数值被设置进来。

解决方案：用private关键字将需要保护的成员变量进行修饰。

一旦使用了private进行修饰，那么在本类当中仍然可以随意访问。

但是，超出了本类范围之外就不能再**直接访问**了。但可以**间接访问**。

间接访问private成员变量，就是定义一对儿LGetter/Setter方法

必须叫setXxx或者是getXxx（命名规则）。

对于Getter来说，不能有参数，返回值类型和成员变量对应

对于Setter来说，不能有返回值，参数类型和成员变量对应

java中字符串可以直接赋值。

```java
public class Person {
    private int age;
    String name;
    public void setAge(int num) {
        if (num <= 100 && num >= 0) {
            age = num;
        } else {
            System.out.println("数据有误");
        }
    }
    public int getAge(){
        return age;
    }
    public void show(){
        System.out.println(age);
        System.out.println(name);
    }
}
```

```java
public class demo02Person {
    public static void main(String[] args) {
        Person person=new Person();
        person.setAge(20);
        //person.age=20;//错误写法,private的成员变量不能直接访问
        person.name="洪永峰";
        int age1;
        age1=person.getAge();
        //System.out.println(age1);
        person.show();
    }
}

```

------

## 1.8 this关键字的作用

this在重名的情况下起区分的效果

当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，

优先使用局部变量。

如果需要访问本类当中的成员变量，需要使用格式：

`this.成员变量名`

注意：通过谁调用的方法，谁就是this。

```java
public class Person {
    String name;
    public void setName(String name){
        System.out.println(name+"你好，我是"+this.name);
        System.out.println(this);
    }
}
```

```java
public class demo01_Person {
    public static void main(String[] args) {
        Person person=new Person();
        person.name="洪永峰";
        person.setName("Jim");
        System.out.println(person);
    }
}
```

------

## 1.9 构造方法

构造方法是专门用来创建对象的方法，当我们通过关键字new来

创建对象时，其实就是在调用构造方法。

### 格式

```
public 类名称(参数类型 参数名称){

方法体

}
```

注意事项

- 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样

- 构造方法不要写返回值类型，连void都不写

- 构造方法不能return一个具体的返回值

- 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，这个默认的构造方法没有参数，其方法体什么事情都不做。

  `public Student() {}`

- 一旦编写了至少一个构造方法，那么编译器将不再赠送默认的构造方法。

- 构造方法也是可以进行重载的。

  重载:方法名称相同，参数列表不同。

- 通过形参传入数据可以省去setXxx()方法的设置，如果之后需要改变对象当中的成员变量数据内容，仍然还需要使用setXxx方法。

------

## 1.10 定义一个标准的类

一个标准的类通常要拥有下面四个组成部分:

- 所有的成员变量都要使用private关键字修饰
- 为每一个成员变量编写一对儿Getter/Setter方法
- 编写一个无参数的构造方法
- 编写一个全参数的构造方法

这样标准的类也叫做Java Bean

快捷键编写Getter/Setter方法和无参/全参构造方法：

`alt+insert`

```java
public class Student02 {

    private String name;

    private int age;

    public Student02() {
    }

    public Student02(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

```java
public class demo01_Student {
    public static void main(String[] args) {
        Student02 stu1=new Student02();
        stu1.setAge(18);
        stu1.setName("洪永峰");
        System.out.println("姓名："+stu1.getName()+"，年龄："+stu1.getAge());
        Student02 stu2=new Student02("fung",20);
        System.out.println("姓名："+stu2.getName()+"，年龄："+stu2.getAge());
        stu2.setAge(21);
        System.out.println("姓名："+stu2.getName()+"，年龄："+stu2.getAge());

    }
}
```



------

# 2 API概述和使用步骤

## 2.1 API的概述

API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 **字典** ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。API相当于成千上万个现成的类和现成的方法，都可以供我们使用。

------

## 2.2 Scanner概述及其API文档的使用

### Scanner的概述

Scanner类的功能，可以实现键盘输入数据，到程序当中。

### 引用类型的一般使用步骤：

（除了基本类型以外的都是引用类型）

- 1. 导包，也就是指出需要使用的类，在什么位置。

     `import 包名称.类名称;`

     `import cn.itcast.daye6.demo01.Student;`

     **如果需要使用的目标类和当前类属于同一个包的情况下，可以省略导包语句不写。**

     **注意：只有java.lang包下的内容不需要导包，其他的包都需要import语句。**

     **注意：导包语句要在package语句后、public class语句之前写。**

- 1. 创建。格式:

     类名称 对象名 = new 类名称();

     `Student stu = new Student(参数列表):`

- 1. 使用，分为两种情况。

     - 使用成员变量。对象名.成员变量名
     - 使用成员方法。对象名.成员方法名(参数)

     也就是，想用谁，就用对象名点儿谁。

### API文档的使用

- 首先左上角按显示，里面有个索引，输入你想搜索的类，按两次回车
- 第一先看该方法或类位于哪个包（路径）
- 第二看构造方法
- 第三看普通的成员方法

### Scanner的使用方法

```java
import java.util.Scanner;
public class Scan {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        //备注：System.in代表从键盘进行输入
        int num=sc.nextInt();
        String str=sc.next();
        System.out.println("字符串是："+str);
        System.out.println("数字是："+num);
    }
}

```

注意：

输入数字的时候输入非数字字符会报错。

java的输入不会读入回车，两次输入之间不需要像C语言一样清除缓冲区。

`Scanner sc=new Scanner(System.in);`这句话记住就行。

------

## 2.3 匿名对象的说明

创建对象的标准格式:

`类名称 对象名 new 类名称();`

匿名对象就是只有右边的对象，没有左边的名字和赋值运算符

`new 类名称();`

**注意事项:匿名对象只能使用唯一的一次，下次如果想再用，就不得不再创建一个新对象**。

使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。

```java
public class Person {
    String name;
    public void setName(String name){
        System.out.println(name+"你好，我是"+this.name);
    }
}
```

```java
public class niming {
    public static void main(String[] args) {
        Person pe=new Person();
        pe.name="洪永峰";
        pe.setName("jim");
        new Person().name="lily";
        new Person().setName("mary");
    }
}
```

最后一句代码的结果是:

`marry你好，我是null`

倒数第二句代码的“lily”是属于某个匿名对象的。

而最后一句代码的marry是属于另外一个匿名对象的，此时该对象的成员变量name并没有赋初始值，默认为null，并不是“lily”，而参数marry则是局部变量。

------

## 2.4 匿名对象作为方法的参数和返回值

普通使用方式

```java
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
```

匿名对象的方式

```java
int num = new Scanner(System.in).nextInt();

System.out.println(“输入的是:”+ num);
```

使用一般写法传入参数

```java
Scanner sc = new Scanner(System.in);

methodParam(sc);
```

使用匿名对象来进行传参

```java
methodParam(new Scanner(System.in));
```

具体代码

```java
import java.util.Scanner;
public class Anonymous {
    public static void main(String[] args) {
        //普通使用方式
        Scanner sc=new Scanner(System.in);
        int num=sc.nextInt();
        System.out.println(num);
        //匿名对象的方式
        int num2=new Scanner(System.in).nextInt();
        System.out.println(num2);
        //使用一般写法传入参数
        methodParam(sc);
        //使用匿名对象来进行传参
        methodParam(new Scanner(System.in));
        //利用匿名对象作为返回值
        Scanner sc2=methodReturn();
        methodParam(sc2);
    }
    public static void methodParam(Scanner sc){
        int num3= sc.nextInt();
        System.out.println(num3);
    }
    public static Scanner methodReturn(){
        return new Scanner(System.in);
    }
}
```

------

## 2.5 Random概述和基本使用

Random类用来生成随机数字。使用起来也是三个步骤:

- 1.导包

  `import java.util.Random;`

- 2.创建

  `Random r= new Random();` // 小括号当中留空即可

  或者`Random r= new Random(n);`//有参数n的意思是，从0（包括）到n（不包括）中随机生成一个数。左闭右开区间。[0,n)

- 3.使用

  获取一个随机的int数字(范围是int所有范围，有正负两种):

  `int num = r.nextInt();`

------

# 3 对象数组

数组有一个缺点，一旦创建，程序运行期间长度不可以发生改变

```java
public class demo03_Person {
    public static void main(String[] args) {
        Person1[] array=new Person1[3];// 首先创建一个长度为3的数组，里面用来存放Person类型的对象
        Person1 one=new Person1("洪永峰",18);
        Person1 two=new Person1("jim",20);
        Person1 three=new Person1("Lily",19);
        array[0]=one;// one当中的地址值赋值到数组的e号元素位置
        array[1]=two; // 地址值
        array[2]=three; // 地址值
        System.out.println(array[0].getName()+array[0].getAge()+"岁");
        System.out.println(array[1].getName()+array[1].getAge()+"岁");
        System.out.println(array[2].getName()+array[2].getAge()+"岁");

    }
}
```

```java
public class Person1 {
    private String name;
    private int age;
    public Person1(String name,int age){
        this.name=name;
        this.age=age;
    }
    public void setName(String name){
        this.name=name;
    }
    public void setAge(int age){
        this.age=age;
    }
    public int getAge(){
        return this.age;
    }
    public String getName(){
        return this.name;
    }
}
```

------

# 4 ArrayList集合

## 4.1 ArrayList集合的概念及用法

类ArrayList<E>

<E>*占位*符 ，表示**泛型**，E只能是一种引用类型

ArrayList集合中所有数据都是统一的泛型，这个类型在<>里面表示

数组的长度不可以发生改变，但是ArrayList集合的长度是可以随意变化的。

对于ArrayList来说，有一个尖括号<E>代表泛型。

泛型，也就是装在集合当中的所有元素，全都是统一的什么类型

注意：泛型只能是引用类型，不能是基本类型。

注意事项，对于ArrayList集合来说，直接打印**对象名**，得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号:[]

有多个内容，则直接打印会输出[内容1，内容2，........]

```java
import java.util.ArrayList;
public class demo_ArrayList {
    public static void main(String[] args) {
        //创建了一个ArrayList集合，集合的名称是List，里面装的全都是string字符串类型的数据
        // 备注:从JDK 1.74开始，右侧的尖括号内部可以不写内容，但是<>本身还是要写的。
        ArrayList<String> list=new ArrayList<>();
        System.out.println(list);
        // 向集合当中添加一些数据，需要用到add方法
        list.add("hyf");
        list.add("jim");
        list.add("lily");
        System.out.println(list);
    }
}
```

在以上代码的条件下，如果加入一句

`list.add(100);` 

这是错误写法! 因为创建的时候尖括号泛型已经说了是字符串，添加进去的元素就必须都是字符串才行。

------

## 4.2 ArrayList集合的常用方法和遍历

### ArrayList当中的常用方法:

`public boolean add(E e);`

//向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功

备注:对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合来说，add添加动作不一定成功。

`public E get(int index);` 

从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素,索引编号从0开始。

`public E remove(int index);`

从集合当中删除元素，参数是索引编号，返回值就是被册除掉的元素

`public int size();`

获取集合的尺寸长度，返回值是集合中包含的元素个数。

删除了某个元素之后，输出该集合list，则该元素就看不到了，且少了一个逗号。注意：删除一个元素，集合的长度就减1。删除那个元素之后，排在他后面的元素的索引编号全部减1，相当于是前移了一位。

```java
import java.util.ArrayList;
public class demo_ArrayListEach {
    public static void main(String[] args) {
        ArrayList<String> list=new ArrayList<>();
        list.add("jim");
        list.add("lily");
        boolean success=list.add("bobby");
        list.add("locus");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        System.out.println("添加的操作是否成功："+success);
        String whoRemoved=list.remove(2);
        System.out.println("被删除的是："+whoRemoved);
        System.out.println(list);
        System.out.println(list.size());
    }
}

```



### 遍历集合的快捷方法

集合名.fori

如`list.fori`

```java
import java.util.ArrayList;
public class demo_ArrayListEach {
    public static void main(String[] args) {
        ArrayList<String> list=new ArrayList<>();
        list.add("jim");
        list.add("lily");
        list.add("bobby");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}
```

注意：

数组的长度是array.length

而集合的长度用`list.size();`来表示

`list.get(i)`的返回值是集合中某个单元的元素

------

## 4.3 ArrayList集合存储基本数据类型

如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。

包装类：引用类型。包装类都位于java.lang包下

| 基本类型 | 包装类          |
| -------- | --------------- |
| byte     | Byte            |
| short    | Short           |
| int      | Integer[特殊]   |
| long     | Long            |
| float    | Float           |
| double   | Double          |
| char     | Character[特殊] |
| boolean  | Boolean         |

从JDK 1.5+开始，支持自动装箱、自动拆箱。意思是自动转换。

自动装箱：基本类型-->包装类型

自动拆箱：包装类型 -->基本类型

泛型只能是引用类型，不能是基本类型。

错误写法：

`ArrayList<int> listB = new Arraylist<>();`

正确写法：

```java
import java.util.ArrayList;

public class demo_ArrayListBasic {
    public static void main(String[] args) {
        ArrayList<Integer> list=new ArrayList<>();
        list.add(100);
        list.add(300);
        list.add(444);
        System.out.println(list);
    }
}
```

------

## 4.4 ArrayList集合练习题

### 1.自定义4个学生对象，添加到集合，并遍历集合元素。

#### 思路：

- 自定义student学生类，四个部分。
- 创建一个集合，用来存储学生对象。泛型:<E>
- 根据类，创建4个学生对象。
- 将4个学生对象添加到集合中:add
- 遍历集合：for、size、get

#### 代码:

```java
public class demo04_Student {
    String name;
    int age;

    public demo04_Student() {

    }

    public demo04_Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
import java.util.ArrayList;

public class demo01_ArrayListStudent {
    public static void main(String[] args) {
        ArrayList<demo04_Student> list=new ArrayList<>();
        demo04_Student one=new demo04_Student("洪永峰",20);
        demo04_Student two=new demo04_Student("jim",18);
        demo04_Student three=new demo04_Student("lily",21);
        demo04_Student four=new demo04_Student("marry",25);
        list.add(one);
        list.add(two);
        list.add(three);
        list.add(four);
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i).getName()+list.get(i).getAge()+"岁");
        }//原来的for
        System.out.println("===========");
        //或者可以写成
        for (int i = 0; i < list.size(); i++) {
            demo04_Student stu=list.get(i);
            System.out.println(stu.getName()+stu.getAge()+"岁");
        }
        System.out.println("===========");
        //或者可以写成
        for (demo04_Student demo04_student : list) {
            System.out.println(demo04_student.getName() + demo04_student.getAge() + "岁");
        }//增强for
    }
}
```

------

### 2.筛选集合当中的随机数

用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中要求使用自定义的方法来实现筛选。

分析:

- 需要创建一个大集合，用来存储int数字:<Integer>

- 随机数字就用Random nextInt

- 循环20次，把随机数字放入大集合:for循环、add方法

- 定义一个方法，用来进行筛选。

  筛选:根据大集合，筛选符合要求的元素，得到小集合。

- 三要素:

  - 返回值类型，ArrayList小集合(里面元素个数不确定)
  - 方法名称，getSmallList
  - 参数列表:ArrayList大集合(装着20个随机数字)

- 判断(if)是偶数:num %2 == 0

- 如果是偶数，就放到小集合当中，否则不放。

```java
import java.util.ArrayList;
import java.util.Random;

public class demo01_ArrayListReturn {
    public static void main(String[] args) {
        ArrayList<Integer> biglist=new ArrayList<>();
        Random r=new Random();
        for (int i = 0; i < 20; i++) {
            int num=r.nextInt(100)+1;
            biglist.add(num);
        }
        System.out.println(biglist);
        System.out.println(get(biglist));
    }
    public static ArrayList<Integer> get(ArrayList<Integer> list){
        ArrayList<Integer> smalllist=new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i)%2==0)smalllist.add(list.get(i));
        }
        return smalllist;
    }
}
```

------

# 5 字符串

## 5.1 概述

java.lang.String类代表字符串。

API当中说:Java 程序中的所有字符串字面值(如“abc”)都作为此类的实例实现。

其实就是说，程序当中所有的双引号字符串，都是String类的对象。 (就算没有new，也照样是String类的对象。)

## 5.2 特点

- 字符串的特点:字符串的内容永不可变。[重点]
- 字符串是常量。
- 正是因为字符串不可改变，所以字符串是可以共享使用的。
  - 如果有代码中运用了多个字符串"abc"，其实他们用的都是同一个"abc"字符串。
- 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。

## 5.3 字符串的构造方法和直接创建

创建字符串的常见3+1种方式

### 三种构造方法:

- `public string();`创建一个空白字符串，不含有任何内容。
- `public string(char[] array);`根据字符数组的内容，来创建对应的字符串。
- `public string(byte[] array);`根据字节数组的内容，来创建对应的字符串。

### 一种直接创建

- String str =“Hello”; // 右边直接用双引号

**注意**:直接写上双引号，就是字符串对象，不管你有没有new。

```java
public class demo02_String {
    public static void main(String[] args) {
        String str=new String();
        System.out.println("第一个字符串："+str);//不是null
        String str1=new String("abc");
        System.out.println(str1);
        char[] ch={'A','B','C'};
        String str2=new String(ch);
        System.out.println(str2);
        byte[] ch1={65,66,67};
        String str3=new String(ch1);
        System.out.println(str3);
        String str4="hello";
        System.out.println(str4);
    }
}
```

## 5.4 字符串的常量池

字符串常量池:程序当中直接写上的双引号字符串，就在字符串常量池中。new的字符串不在池当中。

对于基本类型来说，==是进行**数值**的比较。

对于引用类型来说，==是进行**地址值**的比较。

注意：直接用双引号写的字符串是常量。如果多个字符串的内容一样，且都是用双引号直接生成的，那么他们都是同一个字符串，地址值是一样的(例如str1和str3)，用==来判断也是true的。

```java
public class demo03_StringPool {
    public static void main(String[] args) {
        String str1="abc";
        String str2="ABC";
        String str3="abc";
        char[] ch1={'a','b','c'};
        String str4=new String(ch1);
        byte[] by1={97,98,99};
        String str5=new String(by1);
        System.out.println(str1==str2);
        System.out.println(str1==str3);
        System.out.println(str1==str4);
        System.out.println(str1==str5);
        System.out.println(str4==str5);
    }
}
```

具体存储的步骤：

先在堆中的字符串常量池中生成一个字符串对象String，并将位于常量池外、堆中的byte[]数组的首地址赋值给该对象String。

`String str1="abc";`就相当于`byte[]={97,98,99};`

栈中存储了String str1，其值等于字符串对象String的地址值。

而栈中的另一个引用类型String str3的值也等于str1的值，也就是说堆中不需要再为另一个byte[]字节数组开辟空间了。

而`char[] ch1={'a','b','c'};`则需要在堆中开辟存储空间，然后将字符数组转化为字节数组，该字节数组与str1的字符串对象所指向的字节数组的内容是相同的，都是`byte[]={97,98,99};`，但他们的首地址不一样，因此不是同一个字节数组。此时堆中、常量池外new了一个字符串对象，该对象指向该转化而来的字节数组，对象的值等于该字节数组的首地址，str3的值就等于字符串对象的值。

## 5.5 字符串比较的相关方法

==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法:

`public boolean equals(Object obj);`

参数可以是任何对象，只有参数是一个字符串并且内容与对象本身相同的才会返回true； 否则返回false

该方法严格区分大小写

注意事项:

- 任何对象都能用object进行接收。

- equals方法具有对称性，`a.equals(b)`和`b.equals(a)`效果一样。

- 如果比较双方是一个常量和一个变量，推荐把常量字符串写在前面。

- 推荐:"abc”.equals(str)//常量在前，变量在后

  不推荐:str.equals("abc”)

  原因：如果字符串变量为null，且放在前面，则会报错：空指针异常NullPointerException，空字符串变量放在后面，虽然会输出false，但不会报错。

- 注意，双引号内的字符串为常量，但是用String str1=“字符串”，则str1为字符串变量，其中存放的是字符串的地址值。

```java
public class demo04_StringEquals {
    public static void main(String[] args) {
        String str1="ABC";
        String str2="abc";
        String str3="abcd";
        String str4="ABC";
        char[] ch1={'a','b','c'};
        String str5=new String(ch1);
        System.out.println(str1.equals(str2));
        System.out.println(str3.equals(str2));
        System.out.println(str1.equals(str4));
        System.out.println(str5.equals(str2));
        String str6=null;
        //System.out.println(str6.equals(str2));
        System.out.println(str1.equals(str6));
        System.out.println(str1.equalsIgnoreCase(str2));
        System.out.println(str3.equalsIgnoreCase(str2));
    }
}
```

`public boolean equalsIgnoreCase(String str);`

忽略大小写，进行内容比较

注意：只有英文字符区分大小写，其他字符不区分大小写，特别是中文字符。这里的忽略大小写是指忽略英文字符的大小写。

## 5.6 字符串获取的相关方法

String当中与获取相关的常用方法有:

`public int length();`

获取字符串当中含有的字符个数，拿到字符串长度。

------

`public String concat(String str);`

将当前字符串和参数字符串拼接成为返回值新的字符串。

注意：原来的字符串和参数字符串都保持原封不动，拼接之后的字符串是新建的，因为字符串是常量，不可被改变。

拼接字符串也可以用加号运算符，如：

`str=str1+str2;`

------

`public char charAt(int index);`

获取指定索引位置的单个字符。(索引从0开始。)

------

`int indexOf(String str);`

查找参数字符串在本字符串当中**首次**出现的索引位置，如果没有找到参数字符串则返回-1值。

```java
public class demo05_StringGet {
    public static void main(String[] args) {
        String str1="hello";
        String str2="world";
        System.out.println(str2.length());
        String str3=str1.concat(str2);
        System.out.println(str3);
        System.out.println(str1);
        System.out.println(str2);
        System.out.println(str3.charAt(2));
        System.out.println("nihao".charAt(3));
        System.out.println(str3.indexOf("l"));
        System.out.println("jimandmarry".indexOf("bc"));
    }
}
```

## 5.7 字符串的截取方法

字符串的截取方法

`public String substring(int index);`

截取从参数位置(包括该参数)一直到字符串末尾，返回新字符串。`[index,length-1)`

`public String substring(int begin，int end);`

截取从begin开始，一直到end结束，中间的字符串

备注:`[begin,end)`，包含左边，不包含右边。

```java
public class demo06_Substring {
    public static void main(String[] args) {
        String str1="HelloWorld";
        String str2=str1.substring(5);
        System.out.println(str2);//World
        String str3=str1.substring(4,7);
        System.out.println(str3);//oWo
        System.out.println(str1);
        str1="nihao";//这里并不是把原来的字符串"HelloWorld"改成"nihao",而是将str1的地址值改变了，原来的字符串是常量，不能被改变
        System.out.println(str1);
    }
}
```

## 5.8 字符串的转换相关方法

String当中与转换相关的常用方法有:

`public char[] toCharArray()`

将当前字符串拆分成为字符数组作为返回值。

`public byte[] getBytes()`

获得当前字符串底层的字节数组。

`public String replace(CharSequence oldstring, CharSequence newString)`

第一个参数为target，第二个参数为replacement，就是将原来的字符串中含有target字符（串）的位置替换为replacement这一字符（串）。这两个参数均用""输入。

将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。

注意：这里的CharSequence现阶段可以看成一个字符串类型。

```java
public class demo07_StringConvert {
    public static void main(String[] args) {
        char[] str1="Hello".toCharArray();
        System.out.println(str1.length);
        for (int i = 0; i < str1.length; i++) {
            System.out.println(str1[i]);
        }
        byte[] str2="Hello".getBytes();
        for (int i = 0; i < str1.length; i++) {
            System.out.println(str2[i]);
        }
        String str3="hello!halloween";
        String str4=str3.replace("l","j");
        System.out.println(str4);
    }
}
```



## 5.9 字符串的分割方法

分割字符串的方法:

`public string[] split(string regex)`

按照参数的规则，将字符串切分成为若干部分。

注意事项：

split方法的参数其实是一个“正则表达式”，

注意，如果按照英文句点“.”进行切分，则必须写`\\.`(两个反斜杠加一个.)

```java
public class demo08_StringSplit {
    public static void main(String[] args) {
        String str1="aaa,bbb,ccc";
        String str2="ddd eee fff";
        String str3="jj.sdjk.kds";
        String[] array1=str1.split(",");
        for (int i = 0; i < array1.length; i++) {
            System.out.println(array1[i]);
        }
        String[] array2=str2.split(" ");
        for (int i = 0; i < array2.length; i++) {
            System.out.println(array2[i]);
        }
        String[] array3=str1.split("\\.");
        for (int i = 0; i < array3.length; i++) {
            System.out.println(array3[i]);
        }
    }
}
```



------

# 6 静态static关键字

## 6.1 概述

一旦用了**static关键字**，那么这样的内容不再属于对象自己，而是**属于类**的。

所以凡是本类的对象，都共享同一份数据。该数据只在类当中保存唯一一份，那所有本类对象共享这一份数据。

------

## 6.2 静态成员变量

```java
public class demo11_StaticField {
    public static void main(String[] args) {
        Student one=new Student(18,"jim");
        one.room="101教室";
        Student two=new Student(19,"marry");
        System.out.println(one.getName()+one.getAge()+"岁"+one.room+one.getId()+"号");
        System.out.println(two.getName()+two.getAge()+"岁"+two.room+two.getId()+"号");

    }
}
```

```java
public class Student {
    private int age;
    private String name;
    static String room;
    private int id;
    private static int idCounter=0;
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Student(int age, String name) {
        this.age = age;
        this.name = name;
        this.id=++idCounter;
    }

    public Student() {
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

这段代码中只对one.room赋了值，但输出two.room时同样可以正常输出同一个班级。

而id也是如此，只对了idCounter++，但对象one和two都可以用这个idCounter。

------

## 6.3 静态static关键字修饰成员方法

一旦使用static修饰成员方法，那么这就成为了静态方法。

静态方法不属于对象，而是属于类的。

如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。

如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。

无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。

静态变量:类名称.静态变量
静态方法:类名称.静态方法()

首先要创建对象，然后才能使用没有static关键字的内容。

对于静态方法来说，可以通过对象名进行调用（不推荐）（因为会让人误以为这是一个成员方法），这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”；也可以直接通过类名称来调用（推荐）。

注意：

- 静态只能直接访问静态，不能直接访问不属于该方法本身的非静态。（重点）
  - 报错：无法从 static 上下文引用非 static 字段。
  - 原因：因为在内存当中是**先**有的静态内容，**后**有的非静态内容。“先人不知道后人，但是后人知道先人。”
- 调用本类当中的静态方法，可以省略类名称。
- 成员方法可以访问成员变量
- 成员方法可以访问静态变量
- 静态方法可以访问静态变量
- 静态方法当中不能用this关键字。
  - 原因: this代表当前对象，通过谁调用的方法，谁就是当前对象。而静态变量或方法并不是通过对象来调用的。

```java
public class demo12_StaticMethod {
    public static void main(String[] args) {
        MyClass stu=new MyClass();
        stu.method();
        stu.methodStatic();
        MyClass.methodStatic();
        demo12_StaticMethod.method1();
        method1();
    }
    public static void method1(){

    }
}
```

```java
public class MyClass {
    public void method(){
        System.out.println("成员");
    }
    int j=10;
    public static void methodStatic(){
        System.out.println("静态");
        int i=1;
        System.out.println(i);
        //System.out.println(j);
    }
}
```

------

## 6.4 静态static的内存图解

在方法区中有成员变量，也有静态变量，还有一个静态区。

上面那段代码中，静态区中有一个字符串room，里面存储了101教室。

在栈中使用Student.room的时候，先直接去方法区找到静态变量static String room;,然后再去静态区找到room,接着拿到字符串101教室。

注意:

根据类名称访问静态成员变量的时候，全程**和对象就没关系，只和类有关系**。

------

## 6.5 静态代码块

静态代码块的格式是:

```java
public class 类名称{

	static {

	// 静态代码块的内容

	}
}
```

特点，当第一次用到本类时，静态代码块执行唯一的一次。

静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

静态代码块的典型用途:用来一次性地对静态成员变量进行赋值。

------

# 7 工具类

## 7.1 数组工具类

java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。

`public static String toString(数组名)`

将参数数组按照默认格式[......,...,.....]变成字符串(按照默认格式，[元素1，元素2，元素3...])

注意：必须是一个数组才能用这个方法，很多类型的数组都能使用该方法。

------

`public static void sort(数组名)`

按照默认升序(从小到大) 对数组的元素进行排序。

注意：必须是一个数组才能用这个方法，很多类型的数组都能使用该方法。

备注:

- 如果是数值，sort默认按照升序从小到大排序
- 如果是字符串，sort默认按照字母升序
- 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 

```java
import java.util.Arrays;

public class demo02_Arrays {
    public static void main(String[] args) {
        int[] arr={5,6,4,1,9};
        String str=Arrays.toString(arr);
        System.out.println(str);
        Arrays.sort(arr);
        String str1=Arrays.toString(arr);
        System.out.println(str1);
        String[] arr2={"ccc","aaa","bbb"};
        Arrays.sort(arr2);
        System.out.println(Arrays.toString(arr2));
    }
}
```

------

## 7.2 Arrays练习

for循环倒序遍历快捷方法：

```
char[] chars={.........};
chars.forr然后回车就相当于：
for(i=chars.length-1;i>=0;i--){}

```

```java
import java.util.Arrays;
//题目：输入一个字符串，将该字符串按升序排序，并按倒序输出。
public class demo03_ArraysExercise01 {
    public static void main(String[] args) {
        String str="djfhkjjhlas54354";
        char[] chars= str.toCharArray();
        System.out.println(chars);
        Arrays.sort(chars);
        System.out.println(chars);
        for (int i = chars.length - 1; i >= 0; i--) {
            System.out.println(chars[i]);
        }
    }
}
```

------

## 7.3 数学工具类

`java.util.Math`类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。

`public static double abs(double num)`，获取绝对值。有多种重载。

`public static double ceil(double num)`，向上取整。

`public static double floor(double num)`: 向下取整。

`public static long round(double num)`;四舍五入。

`Math.PI`代表近似的圆周率常量 (double) 。

例子：

-10.8转换成为-10，有两种办法：

- 可以使用Math.ceil()方法，向上(向正方向)取整
- 可以将double或float强转成为int，自动舍弃所有小数位。

备注:如果使用Math.ceil方法，-10.8可以变成-10.0。注意double也是可以进行++的。

------

# 8 继承

## 8.1 继承性的概念

面向对象的三大特征:封装性、继承性、多态性。

继承是多态的前提，如果没有继承，就没有多态。

继承主要解决的问题就是: **共性抽取**

父类，也可以叫基类、超类。

子类，也可以叫派生类。

继承关系当中的特点:

- 1.子类可以拥有父类的“内容”
- 2.子类还可以拥有自己专有的内容

子类公共的内容（共同拥有的部分）就可以理解为父类，可以省去多次编写重复的代码。

子类可以拥有自己特有的方法。

------

## 8.2 继承的格式

在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当做父类看待。

例如父类是员工，子类是讲师，那么“讲师就是一个员工”。

关系，子类 is a 父类。

定义父类的格式：(一个普通的类定义)

```java
public class 父类名称{
//.......
}
```

定义子类的格式:

```java
public class 子类名称 extends 父类名称{
//.....
}
```

注意：

子类可以使用父类的方法。

用法：子类的对象.父类的方法

------

## 8.3 继承中成员变量的访问特点

子类可以继承父类的成员变量

父类对象只能使用父类的任何东西，如成员变量，不能使用任何子类的东西。

在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式:

- 直接通过子类对象访问成员变量.

  - （new语句的）等号左边是谁，就优先用谁，没有则向上一级（父类）找。

    例如：

    `Zi zi=new Zi();`

    `zi.num=0;`//这就是优先用子类对象zi的成员变量num

    如果该成员变量在子类和父类中都没有，则编译报错。

- 间接通过成员方法访问成员变量:

  - 该方法属于谁，就优先用谁，没有则向上找。

子类的成员方法也可以访问父类的成员变量，但如果子类和父类的成员变量名相同，则在子类的成员方法中优先使用本类的成员变量。

```java
public class Zi extends Fu{
    int numZi=200;
    int num=200;
    public void methodzi()
    {//因为本类当中有num，所以优先使用本类的num
        System.out.println(numFu);
    }
}
```

```java
public class Fu {
    int numFu=150;
    int num=100;
    public void methodfu()
    {
        System.out.println(num);
    }
}
```

```java
public class demo07_ExtendField {
    public static void main(String[] args) {
        Zi zi=new Zi();
        Fu fu=new Fu();
        System.out.println(zi.num);
        System.out.println(fu.num);
        System.out.println(fu.numFu);
        //System.out.println(fu.numZi);
        System.out.println(zi.numZi);
        System.out.println(zi.numFu);
        zi.methodzi();
        zi.methodfu();
        //fu.methodzi();
        fu.methodfu();
    }
}
```

------

## 8.4 区分子类方法中重名的三种变量

局部变量：**直接写成员变量名**

本类的成员变量：**this.成员变量名**

父类的成员变量：**super.成员变量名**

```java
public class Zi extends Fu{
    int num=200;
    public void method(){
        int num=10;
        System.out.println(num);//10
        System.out.println(this.num);//200
        System.out.println(super.num);//100//沿用上面的Fu类
    }
}
```

```java
public class demo08_ExtendsField {
    public static void main(String[] args) {
        Zi zi=new Zi();
        zi.method();
    }
}
```

------

## 8.5 继承中成员方法的访问特点

在父子类的继承关系当中，创建子类对象，访问成员方法的规则:

**创建的对象是谁(子类对象还是父类对象)，就优先用谁，如果没有则向上找。**

上面这句话的意思是：new右边的是谁，就优先用谁。

注意：

无论是成员方法还是成员变量，如果没有都是向上找父类，是绝对不会向下找子类的。

------

## 8.6 继承中方法的覆盖重写

### 概念

重写(Override)：在继承关系当中，方法的名称一样，参数列表也一样。

重写(override)：方法的名称一样，参数列表**也一样**。相当于是覆盖、覆写。

重载(overload)：方法的名称一样，参数列表**不一样**。

方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。

------

### 注意事项

方法覆盖重写的注意事项:

- 1.必须保证父子类之间方法的**名称**相同，**参数列表**也相同。

  @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解（@:annotation）就算不写，只要满足要求，也是正确的方法覆盖重写。

- 2.子类方法的返回值必须**小于等于**父类方法的返回值范围。

  小扩展提示: java.lang.0bject类是所有类的公共最高父类(祖宗类)，java.lang.String就是Object的子类。

- 3.子类方法的权限必须**大于等于**父类方法的权限修饰符。

  小扩展提示: public >protected > (default) > private

  备注：**(default)**不是关键宇default，而是什么都不写，留空。

- 绝大多数情况下，我们都是将子类和父类的返回值范围和权限都设置为相等的。

------

### 应用场景

设计原则:

对于已经投入使用的类，尽量不要进行修改。

推荐定义一个新的类，来重复利用其中的共性内容，并且添加改动新的内容。

这就是继承。

```java
public class Phone {
    public void show(){
        System.out.println("显示姓名");
    }
}
```

```java
public class NewPhone extends Phone{
    @Override
    public void show(){
        super.show();//把父类的show方法拿过来重复利用
        System.out.println("显示头像");//子类自己可以再来添加更多内容
    }
}
```

```java
public class demo09_Phone {
    public static void main(String[] args) {
        Phone phone=new Phone();
        phone.show();
        NewPhone newPhone=new NewPhone();
        newPhone.show();
    }
}
```

这种做法可以不用把原来旧的方法删掉，也不用在原来的方法上修改，在新的方法里面直接调用原来的方法，然后还可以增加新的功能，增加新的语句。比较方便。

------

## 8.7 继承中构造方法的访问特点

继承关系中，父子类构造方法的访问特点:

- 子类构造方法当中有一个默认隐含的“super()”调用，这个语句默认放在该子类构造的第一句（虽然你看不见），所以一定是先调用的父类构造，后执行的子类构造。
- 子类构造可以通过super关键宇来调用父类重载构造（n个参数）。
- super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。

总结:子类必须调用父类构造方法，不写则默认赠送super()，写了则用写的指定的super调用，super只能有唯一一个，还必须是位于子类构造方法的第一个语句。

只有子类构造方法，才能调用父类构造方法。其他的子类方法不能调用父类构造方法，即不能在其他子类方法中调用super()语句。

```java
public class Zi01 extends Fu01{
    public Zi01(){
        //不写super则默认在此位置有一个super();语句
        //如果父类构造有参数，则在super()语句中可以加上任意的一个同类型的参数
        super(10);//调用父类的重载的构造方法
        System.out.println("子类");
    }
    public void method(){
        //super(10);//只有子类构造方法，才能调用父类构造方法。
    }
}
```

```java
public class Fu01 {
    public Fu01(int num){
        System.out.println("父类");
    }
}
```

```java
public class demo10_FuZi {
    public static void main(String[] args) {
        Zi01 zi=new Zi01();
    }
}
```

------

## 8.8 super关键字的三种用法总结

super关键字的用法有三种:

- 在子类的成员方法中，访问父类的成员变量。
  - `System.out.println(super.num);`//其中num是父类的成员变量。
- 在子类的成员方法中，访问父类的成员方法。
  - `super.method();`//其中method是父类的成员方法。
- 在子类的构造方法中，访问父类的构造方法。
  - `public Zi(){super();}`//其中Zi()是子类构造方法。

------

## 8.9 this关键字的三种方法



super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：

- 在本类的成员方法中，访问本类的成员变量。
- 在本类的成员方法中，访问本类的另一个成员方法。
- 在本类的构造方法中，访问本类的另一个构造方法

在第三种用法当中要注意:

- A. this(...)调用也必须是构造方法的第一个语句，且是唯一一个，不能写两个this();语句，即使参数列表不一样也不行。
- B.super和this两种构造调用，不能同时使用。
- 在写了this();调用后，默认的super();调用则不会赠送。
- 某构造方法不能用对应的this();方法来调用自己，这是错误写法。
- this();语句不能进行递归调用，同上，不能调用自己对应的构造方法；即使是调用别的参数列表不同的构造方法，也不能循环递归，会报错，例子如下。

```java
public class Fu01 {
    public Fu01(int num){
        System.out.println("父类");
    }
}
```

```java
public class Zi02 extends Fu01{
    public void methodB(){
        this.method();//用于强调这个method方法是来自于本类的而不是父类的。当然没有这个this也可以。
        System.out.println("bbb");//如果没有this且本类中没有method方法的话，会自动去父类查找。
    }
    public void method(){
        System.out.println("aaa");
    }
    public Zi02(){
        //super(10);
        this(1);
    }
    public Zi02(int n){
        this(1,2);
    }
    public Zi02(int n,int m){
        //this();//出现了递归循环构造方法的调用，出错。
        super(1);
    }
}
```

------

## 8.10 super与this关键字的理解

在方法区中，子类中自动含有一个[[super_class]]，且指向父类

new一个子类对象，必须是先执行完父类构造方法，然后再执行子类构造方法的内容。

在堆中子类内容包括子类的成员方法（堆中保存的是地址值）、成员变量，还包含了父类内容，同样父类内容中含有父类的成员方法和成员变量。this代表子类内容，super代表父类内容。

在栈区中，一旦用到this关键字，则相当于是指针直接指向堆中的子类内容。一旦用到super关键字，则相当于是指针直接指向堆中的父类内容。

------

## 8.11 Java继承的三个特点

Java语言是**单继承**的。

一个类的直接父类只能有唯一一个。

Java语言可以**多级供承**。

我（C）有一个父亲(B)，我父亲还有一个父亲(A)，也就是爷爷。

A也算是C的父类。但不是直接父类。

一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。

Object类相当于祖宗类，他没有父类，他就是最高的类。

------

# 9 抽象

## 9.1 抽象的概念

假设父类是图形，子类是正方形、三角形、圆形，父类中含有计算面积的方法，但该方法不够具体，因为每种图形计算面积的方法都不同，但图形一定能计算面积，那么这个父类当中计算图形面积的方法就叫抽象方法。

如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个**抽象方法**。

------

## 9.2 抽象方法和抽象类的格式

抽象方法:就是加上abstract关键字，然后去掉大括号，直接分号结束。

抽象类，抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

```java
public abstract class Animal{//abstract一定要写
    //这是一个抽象方法，代表吃东西，但是具体吃什么(大括号的内容)不确定。
    public abstract void eat();//不用大括号，而是用;
    
    //抽象类里面也可以有普通的成员方法。
    public void normallMethod(){
        
    }
}
```

------

## 9.3 抽象方法和抽象类的使用

如何使用抽象类和抽象方法。

- 不能直接创建new抽象类对象。

- 必须用一个子类来继承抽象父类。

- 子类必须覆盖重写抽象父类当中所有的抽象方法。

  覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。

- 创建子类对象进行使用。

```java
public class Cat extends Animals{
    @Override
    public void eat(){
        System.out.println("猫吃鱼");
    }
}
```

```java
public class demo01_Main {
    public static void main(String[] args) {
        Cat cat=new Cat();
        cat.eat();
    }
}
```

------

## 9.4 抽象方法和抽象类的注意事项

关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。

- 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。

  - 理解:假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

- 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的

  - 理解:子类的构造方法中，有默认的super()，需要访问父类构造方法

- 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

  - 理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

- 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类.

  - 理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

- 一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。

  这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。

- 非抽象类中不能含有抽象方法。

- 抽象类的抽象方法一定要在非抽象子类中有一个非抽象的实现。

------

# 10 接口

## 10.1 接口的概述

接口就是一种**公共的规范标准**。只要符合规范标准，就可以大家通用。

## 10.2 接口的定义及其基本格式

接口就是多个类的公共规范。

接口是一种引用数据类型，最重要的内容就是其中的：抽象方法

如何定义一个接口的格式：

`public interface 接口名称{// 接口内容}`

备注:换成了关键字interface之后，编译生成的字节码文件仍然是:`.java -->.class。`

如果是Java 7，那么接口中可以包含的内容有:

- 常量
- 抽象方法

如果是Java 8，还可以额外包含有:

- 默认方法
- 静态方法

如果是Java9，还可以额外包含有：

- 私有方法

------

## 10.3 接口的抽象方法定义

在任何版本的Java中，接口都能定义抽象方法。

注意：抽象方法的定义一定是以分号;结尾的，一定不能有方法体。

格式:

`public abstract 返回值类型 方法名称(参数列表);`

注意事项：

- 接口当中的抽象方法，修饰符必须是两个固定的关键字:`public abstract`
- 这两个关键字修饰符，可以选择性地省略，可以全部省略，也可以部分省略。 不写defalut则默认为abstract
- 方法的三要素，可以随意定义。

```java
public interface MyInterfaceAbstract {
// 这是一个抽象方法
    public abstract void methodAbs1();
// 这也是抽象方法
    abstract void methodAbs2();
// 这也是抽象方法
    public void methodAbs3();
// 这也是抽象方法void methodAbs4();
    void methodAbs4();
}
```

## 10.4 接口的抽象方法使用

接口使用步骤：

- 接口不能直接使用，必须有一个“实现类”来“实现”该接口。

  - 格式:

    `public class 实现类名称 implements 接口名称 {...}`

- 接口的实现类必须覆盖重写(实现)接口中**所有**的抽象方法。

  实现:去掉abstract关键字，加上方法体大括号。

- 创建实现类的对象，进行使用。

注意事项：

如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。部分抽象方法没有重写，相当于是有一些抽象方法被继承下来，而只有抽象类中才能有抽象方法。

------

## 10.5 接口的默认方法定义

从Java 8开始，接口里允许定义默认方法。

格式:

`public default 返回值类型 方法名称(参数列表)(方法体}`

备注:接口当中的默认方法，可以解决接口升级的问题。

例子：一开始实现类中都覆盖重写了接口中所有的抽象方法，但是这个时候我在接口中新增了多个抽象方法，如果我有多个实现类，那我这些实现类都要改动，很麻烦。因此，在接口中用默认方法就可以变得简单很多，不用一个个地对实现类进行修改。

------

## 10.6 接口的默认方法使用

就算不写public，他也默认是public

但default不能省略。

接口的默认方法，可以通过接口实现类对象，直接调用。

接口的默认方法，也可以被接口实现类进行覆盖重写。

接口的默认方法，可以不用在实现类中覆盖重写。

在类中调用接口的默认方法，如果实现类中没有该默认方法，则自动向上在接口中寻找。

```java
public interface MyInterfaceAbstract {
    // 这是一个抽象方法
    public abstract void methodAbs1();
    // 这也是抽象方法
    abstract void methodAbs2();
    // 这也是抽象方法
    public void methodAbs3();
    // 这也是抽象方法void methodAbs4();
    void methodAbs4();
    public default void method() {
        System.out.println("默认");
    }
}
```

```java
public class MyInterfaceAbstractImpl implements MyInterfaceAbstract{
    @Override
    public void methodAbs1() {
        System.out.println("第一个");
    }
    @Override
    public void methodAbs2() {
        System.out.println("第二个");
    }
    @Override
    public void methodAbs3() {
        System.out.println("第三个");
    }
    @Override
    public void methodAbs4() {
        System.out.println("aaa");
    }
}
```

```java
public class MyInterfaceAbstractImpl01 implements MyInterfaceAbstract{
    @Override
    public void methodAbs1() {
        System.out.println("第一个");
    }

    @Override
    public void methodAbs2() {
        System.out.println("第二个");
    }

    @Override
    public void methodAbs3() {
        System.out.println("第三个");
    }

    @Override
    public void methodAbs4() {
        System.out.println("bbb");
    }
    @Override
    public void method(){
        System.out.println("01重写");
    }
}
```

```java
public class demo01_Interface {
    public static void main(String[] args) {
        //MyInterfaceAbstract in=new MyInterfaceAbstractImpl();
        //MyInterfaceAbstract in=new MyInterfaceAbstract();//错误写法，不能直接new接口对象来使用
        MyInterfaceAbstractImpl inter=new MyInterfaceAbstractImpl();
        inter.methodAbs4();
        MyInterfaceAbstractImpl01 inter02=new MyInterfaceAbstractImpl01();
        inter02.methodAbs4();
        inter.method();
        inter02.method();
    }
}
```



------

## 10.7 接口的静态方法

### 定义

从Java 8开始，接口当中允许定义静态方法。

格式:

`public static 返回值类型 方法名称(参数列表)(方法体}`

提示:就是将abstract或者default换成static即可，且带上方法体。

------

### 使用

注意事项，不能通过接口实现类的对象来调用接口当中的静态方法。

正确用法，通过接口名称，直接调用其中的静态方法。

格式：`接口名称.静态方法名(参数);`

------

## 10.8 接口的私有方法定义

问题描述:

我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。

但是这个共有方法不应该让实现类使用，应该是私有化的。

解决方案:

从Java 9开始，接口当中允许定义私有方法。

- 普通私有方法，解决多个**默认方法**之间重复代码问题

  - 格式:

    `private 返回值类型 方法名称(参数列表)(方法体}`

- 静态私有方法，解决多个**静态方法**之间重复代码问题

  - 格式:

    `private static 返回值类型 方法名称(参数列表){方法体}`

------

## 10.9 接口的私有方法使用

`private (static)返回值类型 方法名(参数列表){方法体}`

注意private和default不能同时使用。但private和static可以空时使用。

用实现类的对象名.默认方法名就可以使用默认方法了，默认方法再调用私有方法。

```java
public class demo02_Interface {
    public static void main(String[] args) {
        MyInterfaceStaticImpl inter=new MyInterfaceStaticImpl();
        //inter.methodStatic();//错误写法
        MyInterfaceStatic.methodStatic();
        inter.methodDefault01();
    }
}
```

```java
public class MyInterfaceStaticImpl implements MyInterfaceStatic{
    public void methodA(){
        //methodDefault();
    }
}
```

```java
public interface MyInterfaceStatic {
    public static void methodStatic(){
        System.out.println("静态方法");
        method1();
    }
    public default void methodDefault01(){
        System.out.println("默认A");
        methodDefault();
    }
    public default void methodDefault02(){
        System.out.println("默认B");
        methodDefault();
    }
    private void methodDefault(){
        System.out.println("默认");
    }
    private static void method1(){
        System.out.println("私有");
    }
}
```

------

## 10.10 接口的常量定义和使用

接口当中也可以定义“成员变量”，但是必须使用`public static final`三个关键字进行修饰。

从效果上看，这其实就是接口的**常量**。

格式：

`public static final 数据类型 常量名称=数据值;`

备注：一旦使用final关健字进行修饰，说明不可改变

注意事项:

- 接口当中的常量，可以省略public static final中的任意一个、任意几个，或者全部省略。注意:不写也照样是这样（默认带有public static final）。

- 接口当中的常量，必须进行赋值，不能不赋值。一旦赋值不可以修改

- 在接口中定义一个常量，与在类里面定义变量的方法差不多，直接int 一个变量。但是常量名要用完全大写，这样比较规范，如果常量名有多个单词，则要用下划线隔开。

  - 例如 `public static final int NUM_OF_MY_CLASS=10;`

  - 用法：在类中输出该常量,或者说直接访问该接口中的常量。

    `System.out.print(接口名.常量名);`

------

## 10.11 继承父类并实现多个接口

Java中的任何一个类都是Object类的直接子类或间接子类。

使用接口的时候，需要注意:

- 接口中是不能有静态代码块或者构造方法的。

- 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。

  - 格式：

    public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {// 覆盖重写所有抽象方法}

- 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。

- 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。

- 如果实现类（或抽象的实现类）所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

  - 原因：实现类（或抽象的实现类）中不能同时执行多个接口中的默认方法。
  - 无论该实现类是否抽象类，都要进行覆盖重写。

- 一个类如果他的直接父类当中的方法和接口当中的默认方法产生了冲突，则优先用父类当中的方法。

  - 在Java中，继承优先于接口实现。

- 一个类可以同时作为子类，也可以作为一个接口的实现类。

  - 例如:`public class Zi entends Fu implements MyInterface{}`

------

## 10.12 接口之间的多继承

- 类与类之间是单继承的。直接父类只有一个。

- 类与接口之间是多实现的。一个类可以实现多个接口。

- 接口与接口之间是多继承的。用extends关键字而不是implements。

  - 例如

    `public interface MyInterface extends MyInterfaceA,MyInterfaceB{方法体}`

注意事项：

- 多个父接口当中的抽象方法如果重复，没关系，因为没有方法体。
- 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，**而且要带着default关键字**。

------

# IO

```java
import java.io.*;
import java.io.File;
import java.io.FileInputStream;
//----------------------------------------------------

public static void output(ArrayList<CustomerInformation> list){
    String[] outputInformation=new String[list.size()];
    for (int i = 0; i < list.size(); i++) {
        outputInformation[i]="姓名："+list.get(i).name+"\n出生日期："+list.get(i).year+"年"+list.get(i).month+"月"+list.get(i).day+"日\n"+"手机号码："+list.get(i).phoneNumber+"\n消费金额："+list.get(i).money+"\n\n";
    }

    //创建一个文件对象file
    File file = new File("MarketRegistrationInformation.txt");

    try{

        //创建文件输出流对象fo
        FileOutputStream fo = new FileOutputStream(file);

        //向文件中写入内容
        for (int i=0;i<list.size();i++){
            byte [] byteContent = outputInformation[i].getBytes();	//将字符串转换文字节数组类型
            fo.write(byteContent);	//以字节数组类型写入内容
        }

        //关闭文件输出流
        fo.close();
        System.out.println("已创建test.txt文件，已写入内容");

    }catch(Exception e){
        System.out.println(e);
    }
}
```

```java
public static void input(){
    File file = new File("MarketRegistrationInformation.txt");
    try {
        //创建文件输入流对象
        FileInputStream fi = new FileInputStream(file);

        //读取文件内容
        byte[] byteArr = new byte[1000];	//创建个字节数组，给定长度为1000
        int len = fi.read(byteArr); 	//将读取到的文本元素放入byteArr数组中，返回数组长度
        System.out.println("读取的文件内容为：\n\n"+new String(byteArr,0,len));	//将字节型数组转换为字符串

        //关闭文件输入流
        fi.close();
    }catch(Exception e){
        System.out.println(e);
    }
}
```



------

# 备注

new对象的时候不需要等号两边的类型都相等

如：`Person per=new Person();`

我也可以写成

`Person per=new Student();`

------

# Git

## Git的使用

- 在准备写任务的文件夹下打开git bash，输入

  ```bash
  git clone 刚才复制的仓库链接
  ```

  然后按下回车

- 初始克隆时需要输入注册coding时的邮箱和密码，系统会弹出Windows安全中心输入用户名和密码的窗口

- 然后就可以看到仓库被克隆到本地gi

- 在克隆之后的文件夹当中，可以将自己的笔记、代码等放进里面的文件夹。

- 完成任务之后，在写任务的文件夹（仓库的根目录）下打开git bash，输入以下命令。

- ```bash
  git add .
  ```

  - 将新增的文件添加到暂存区内。

- ```bash
  git commit -m "备注"
  ```

  - 其中备注的内容必须要写，且有一定的规范。

- ```bash
  git push -u origin master
  ```

- 回车后重新回到coding仓库，刷新发现笔记和任务已经成功推上来

- 下次需要提交时重复以上步骤即可

- 之后可以查看当前目录下文件的状态 

  - ```bash
    git status
    ```

  - 如果有文件没有被添加到暂存区的话，他会用红色的字体来提示你，哪些文件没有添加。

------

一些其他的命令

- ```bash
  cd 文件夹名/
  ```

  - 进入当前目录下的这个文件夹

- ```bash
  ls
  ```

  - 查看当前文件夹下有什么文件
  - 然后他就会显示文件名

- ```bash
  git branch
  ```

  - 查看有什么分支
  - 然后会显示分支的名字

- ```bash
  git checkout -b dev
  ```

  - 创建了一个dev分支，并切换到该分支下

## 注意事项：

- 提交文件之后，然后在远程仓库里面编辑或者删除了一些文件，再在bash里面提交新的文件，这时候会报错，原因是没有把远程仓库里面的东西pull到本地仓库。

  - 解决办法：

    可以是重新克隆仓库。

    也可以是pull一些文件下来使得本地仓库和远程仓库里面的文件一样。

    ```bash
    git pull
    ```

    

- 

------

## Git提交规范

```bash
git commit -m "备注"
```

其中备注就是message，这个message的格式是：

```bash
<type>(<scope>): <subject>
```

注意冒号后面有空格。

### **type**包括：

- feat: 新功能 (feature)或功能变更相关。
- fix:修补、修复bug、漏洞相关。
- docs: 文档 (documentation)，改动了文档，注释相关，或者修改javadoc文档。
- style: 代码格式(不影响代码运行的变动)，修改了代码格式化相关，如删除空格、改变缩进、单双引号切换、增删分号等，并不会影响代码逻辑。
- refactor:代码重构(即不是新增功能，也不是修改bug、修复漏洞的代码变动)，重构代码，代码结构的调整相关（理论上不影响现有功能。
- perf：性能改动，性能、页面等优化相关
- test：增加或更改测试用例，单元测试相关
- build： 影响编译的更改相关，比如打包路径更改、npm过程更改等
- ci：持续集成方面的更改。现在有些build系统喜欢把ci功能使用yml描述。如有这种更改，建议使用ci
- chore：其它改动相关，比如文件的删除、构建流程修改、依赖库工具更新增加等
- revert：回滚版本相关

其实实际开发中最常用的就是 feat、fix 和 perf，git提交基本上都是实现需求，更改bug，性能优化。除了上述这些主要类型，我们也可以根据团队要求定制类型，毕竟规范是死的，人是活的嘛。比如为了大家更易读，我们只留几个常用的，并且全改成中文，如：

- 功能更改：新功能或功能变更相关
- 修复bug：修复bug相关
- 优化：性能改动，性能、页面等优化相关

没有好与不好之分，适合团队的就是最好的！

### **scope**

指影响范围，影响到的位置，具体到包即可。

### **subject**

指具体修改内容

示例:

```bash
feat(nacos): Add spring.config.import for extension-config import
```

意思是：提供了一个方式给外部配置进行导入。

markdown笔记图片展示问题建议使用图床解决.

## 分支

在大型项目里面，每个人都会有自己的一个分支。

每个人在自己的分支里面干活，可以将自己的代码上传到自己的分支里面。

等到你已经完成了分配给你的任务， 你就可以申请代码合并，把自己分支的代码合并到master主分支里面。



---

# 1 多态

## 1.1 多态的概述

面向对象三大特征: 封装性、继承性、多态性。

extends继承或者implements实现，是多态性的前提。

例如：一个对象既有学生形态，也有人类形态。

一个对象拥有多种形态，这就是:

**对象的多态性**。

注意：是对象具有多态性，而不是类具有多态性。

------

## 1.2 多态的格式与使用

代码当中体现多态性，其实就是一句话:父类引用指向子类对象。

### 格式

`父类名称 对象名 = new 子类名称();`

```java
Fu obj=new Zi();
obj.method();
//其中，在子类和父类中均有method()成员方法。但优先使用子类的成员方法，因为new的是子类。
```

左侧父类的引用，指向了右侧子类的对象

或者:

`接口名称 对象名 = new 实现类名称();`

------

## 1.3 多态中成员变量的使用特点

只有成员方法能覆盖重写，成员变量不能覆盖重写。

访问成员变量的两种方式：

- 直接通过对象名称访问成员变量，看等号左边是谁（是父类还是子类），优先用谁，没有则向上找
- 间接通过成员方法访问成员变量:看该方法属于谁，优先用谁，没有则向上找。

new等号左边是父类，那就不能.子类成员变量，意思就是不能向下找。

------

## 1.4 多态中成员方法的使用特点

在多态的代码当中，成员方法的访问规则是：

- 看new的是谁，就优先用谁，没有则向上找。

口诀:**编译看左边，运行看右边。**

编译看左边的意思是：看左边的类有没有点后面的成员方法。

对比一下:

成员变量：编译看左边，运行还看左边。

成员方法：编译看左边，运行看右边。

子类没有覆盖重写父类成员方法，那调用的就是父类的成员方法。

子类如果覆盖重写父类成员方法，那优先调用的就是子类成员方法。

------

## 1.5 使用多态的好处

如果不用多态，只用子类，那么写法是:

注意：父类Assistant中有抽象方法work();

```java
Teacher one = new Teacher();

one.work(); // 讲课

Assistant two = new Assistant();

two.work(); // 辅导
```

我现在唯一要做的事情，就是调用wvork方法，其他的功能不关心。

如果使用多态的写法，对比一下:

```java
Employee one = new Teacher();

one.work(); // 讲课

Employee two = new Assistant();

two.work(); // 辅导
```

好处:无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化.

------

## 1.6 对象的向上转型

对象的向上转型，其实就是多态写法:

格式: 

`父类名称 对象名 = new 子类名称0;`

`Animal animal = new Cat();`

含义:右侧创建一个子类对象，把它当做父类来看待使用.

例如：创建了一只猫，当做动物看待。

注意事项:

**向上转型一定是安全的。**从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。

类似于:

double num = 100: // 正确，int --> double，自动类型转换。

------

## 1.7 对象的向下转型

对象的向下转型，其实是一个**还原**的动作。

向下转型之后，原本的父类引用才能调用子类方法。

格式: 

`子类名称 对象名 = (子类名称) 父类对象；`

含义: 将父类对象，**还原** 成为本来的子类对象。

`Animal animal = new Cat();`

// 本来是猫，向上转型成为动物

`Cat cat =(Cat) animal;` 

//向下转型，进行“还原”动作.

// 本来是猫，已经被当做动物了，还原回来成为本来的猫

然后就可以调用catchMouse();

`cat.catchMouse();`

或者直接写:

`((Cat) animal).catchMouse();`

注意事项:

- a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫
- b.如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错：**ClassCastException**，类转换异常。

类似于:

int num = (int) 10.0: // 可以

int num = (nt) 10.5; // 不可以，精度损失

错误例子：

本来new的时候是一只猫，现在非要当做狗

错误写法!JDK旧版本编译不会报错，但是运行会出现异常，新版本JDK会报错。

`Dog dog = (Dog) animal;`

------

## 1.7 用instanceof关键字进行判断

如何知道这个父类的引用所指向的对象是猫还是狗呢？

如何才能知道一个父类引用的对象，**本来**是什么子类?

格式:

`对象 instanceof 类名称`

这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。

```java
Person per=new Student();
if (per instanceof Student){
    Student stu1=(Student) per;
    stu1.eat();
}
if (per instanceof Teacher){
    Teacher tea=(Teacher) per;
    tea.eat();
}
```

------

# 2 final关键字

## 2.1 final关键字概念与四种用法的概述

final关键字代表**最终、不可改变**的。

常见四种用法:

- 1.可以用来修饰一个类
- 2.可以用来修饰一个方法
- 3.还可以用来修饰一个局部变量
- 4.还可以用来修饰一个成员变量

------

## 2.2 final关键字用于修饰类

当final关键字用来修饰一个类的时候，格式:

`public final class 类名称{}`

含义:当前这个类不能有任何的子类。

注意:一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写，因为没有子类。

------

## 2.3 final关键字用于修饰成员方法

当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。

格式:

`修饰符 final 返回值类型 方法名称(参数列表){// 方法体}`

注意事项:

对于类、方法来说，abstract关键字和final关键字不能同时使用，因为他们互相矛盾，抽象方法一定要在子类有重载方法，而final不能重载。

------

## 2.4 final关键字用于修饰局部变量

一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。

“一次赋值，终生不变”

```java
final int num1=10;
num1=20;//错误写法
num1=10;//错误写法
final int num2;
num2=30;//正确写法!只要保证有唯一一次赋值即可
```

第二次赋值就算赋的值与第一次一样也是错的。

final先定义后赋值也是正确的。（分开两个语句）

对于基本类型来说，不可变说的是：变量当中的数据不可改变。

对于引用类型来说，不可变说的是变量当中的地址值不可改变，但变量中的值可以变，可以用Getter和Setter对其内容进行改变。

------

## 2.5 final关键字用于修饰成员变量

对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。

- 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
- 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
  - 如果使用构造方法赋值，必须保证类当中**所有重载的构造方法**，都最终会对final的成员变量进行赋值。而该变量的Setter方法要注释掉。不能重复赋值，只能赋值一次。
  - 如果使用直接赋值，就直接在变量名的等号右边赋值就行了。

------

## 2.6 四种权限修饰符

java中.java文件不是同一个文件夹就不算是同一个包。

如果一个文件夹中还有一个文件夹，最里层文件夹有一个.java文件，最外层文件夹有另一个.java文件，这个.java文件和里层文件夹是并列的，因此两个.java文件不属于同一个包。

java中有四种权限修饰符

| 从大到小     | public | protected | (default) | private |
| ------------ | ------ | --------- | --------- | ------- |
| 同一个类     | YES    | YES       | YES       | YES     |
| 同一个包     | YES    | YES       | YES       | NO      |
| 不同包子类   | YES    | YES       | NO        | NO      |
| 不同包非子类 | YES    | NO        | NO        | NO      |

注意：(default)并不是关键字default，而是什么东西都不写。

YESorNO代表能否访问对应位置的变量或方法。

------

## 2.7  内部类的概念与分类

内部类在某一个类的内部才能正常工作，若脱离了那个类，则内部类不能正常工作。

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。

例如:身体和心脏的关系。又如:汽车和发动机的关系。

分类：

- 成员内部类
- 局部内部类（包含匿名内部类）

------

## 2.8 成员内部类的定义

内部类使用外部类的东西，无论外部类是什么权限，内部类都能随意访问外部类，权限不受影响。

类名称最好用英文+数字，而不要用一些其他的字符，如“$”。

原因：

外部类Body中包含一个内部类Heart，则内部类的名称在文件管理器中显示为Body$Heart.class。外部类文件则为Body.class。

成员内部类的定义格式:

```
修饰符 class 外部类名称{
	修饰符 class 内部类名称{...}
}
```

注意:内用外，随意访间，外用内，需要new内部类对象。

------

## 2.9 成员内部类的使用

如何使用成员内部类?

有两种方式：

- 1.间接方式，在外部类的方法当中，使用内部类;然后main只是调用外部类的方法
- 2.直接方式。公式:
  - `类名称 对象名 = new 类名称();`
  - `外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();`

注意：公式法和间接方法都会调用类的构造方法。

```java
public class Demo02_InnerClass {
    public static void main(String[] args) {
    //间接方法
        Body bd=new Body();
        bd.bodyHeart();
    //直接方法
        Body.BodyHeart bd1=new Body().new BodyHeart();
        bd1.beat();
        new Body().new BodyHeart().beat();
    }
}

```

```java
public class Body {
    public Body() {
        System.out.println("外部类");
    }
    public class BodyHeart{
        public void beat(){
            System.out.println("砰砰砰");
            System.out.println(name);
        }
    }
    public String name="hyf";
    public void bodyHeart(){
        new BodyHeart().beat();
    }
}
```

------

## 2.10 内部类的同名变量访问

不能用super的原因：因为外部类并不是内部类的父类。

如果出现了重名现象，那么调用格式是：

`外部类名称.this.外部类成员变量名`

```java
public class Body {
    int num=30;// 外部类的成员变量
    public class BodyHeart{
        int num=20;// 内部类的成员变量
        public void print(){
            int num=10;// 内部类方法的局部变量
            System.out.println(num);// 局部变量，就近原则
            System.out.println(this.num);// 内部类的成员变量
            System.out.println(Body.this.num);// 外部类的成员变量
        }
        
    }
}
```

------

## 2.11 局部内部类定义

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

“局部”，只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

定义格式

```
修饰符 class 外部类名称{
	修饰符 返回值类型 外部类方法名称(参数列表){
		class 局部内部类名称 {...}
	}
}
```

定义一个类的时候，权限修饰符规则:

- 外部类: public / (default)
- 成员内部类: public / protected / (default) / private
- 局部内部类，什么都不能写
  - 注意：这里的意思与(default)并不一样。

```java
public class DemoMain {
    public static void main(String[] args) {
        Outer outer=new Outer();
        outer.method();
    }
}
```

```java
class Outer {
    public void method(){
        class Inner{
            int num=10;
            public void print(){
                System.out.println(num);
            }
        }
        Inner inner=new Inner();
        inner.print();
    }
}
```

------

## 2.12 局部内部类的finial问题

局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**有效final的**。

备注，从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

原因：

- new出来的对象在堆内存当中。
- 局部变量是跟着方法走的，局部变量存放在在栈内存当中。
- 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
- 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

如果我想继续在局部内部类调用其所在方法的局部变量，则要保证这个局部变量是final的，而如果不是final的，局部内部类则不能调用该局部变量。

注意：局部内部类的局部变量也应该是**有效final的**。

```java
public class DemoMain {
    public static void main(String[] args) {
        Outer outer=new Outer();
        outer.method();
    }
}
```

```java
class Outer {
    public void method(){
        final int no=1;

        class Inner{
            final int num=20;
            public void print(){
                System.out.println(num+no);
            }
        }
        Inner inner=new Inner();
        inner.print();
    }
}
```

------

## 2.13 匿名内部类

大括号里面的才是匿名内部类，也是局部内部类，大括号里面覆盖重写的方法是是来自于接口的抽象方法。

如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用**匿名内部类**。

匿名内部类的定义格式：

```
接口名称 对象名 = new 接口名称(){
	// 覆盖重写所有抽象方法
};
```

注意：最后的分号不能省略。

```java
public class Demo01_MyInterface {
    public static void main(String[] args) {
        MyInterface myInterface=new MyInterface() {
            @Override
            public void method() {
                System.out.println("匿名内部类");
            }
        };
        myInterface.method();
    }
}
```

错误写法：接口名称 对象名 = new 接口名称();

```java
public interface MyInterface {
    void method();
}
```

------

## 2.14 匿名内部类的注意事项

匿名内部类要重写接口的所有方法

对格式“new 接口名称() {...}”进行解析:

- new代表创建对象的动作
- 接口名称就是匿名内部类需要实现哪个接口
- {...},大括号里面的才是匿名内部类的内容

另外还要注意几点问题:

- 1.匿名内部类，在**创建对象**的时候，只能使用唯一一次。

  如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。

- 2.匿名对象，在**调用方法**的时候，只能调用唯一一次。

  如果希望同一个对象，调用多次方法，那么必须给对象起个名字。

- 3。匿名内部类是省略了**实现类名称/子类名称**，但是匿名对象是省略了**对象名称**。

  强调，**匿名内部类和匿名对象不是一回事**!!!

  ```java
  public class Demo01_MyInterface {
      public static void main(String[] args) {
          //使用匿名内部类
          MyInterface myInterface=new MyInterface() {
              @Override
              public void method() {
                  System.out.println("匿名内部类1");
              }
          };
          myInterface.method();
          MyInterface obj=new MyInterface() {
              @Override
              public void method() {
                  System.out.println("匿名内部类2");
              }
          };
          obj.method();
          //匿名内部类的匿名对象
          new MyInterface(){
              public void method(){
                  System.out.println("匿名内部类3");
              }
          }.method();
      }
  }
  ```

  ------

## 2.15 类作为成员变量类型

成员变量类型既可以是基本类型，也可以是引用类型，还可以是任何一种类class。任何一种类型都可以作为成员变量。

```java
package winter_holiday_training_camp.day10;
public class Demo02_Main {
    public static void main(String[] args) {
        Hero hero=new Hero();
        hero.setName("洪永峰");
        hero.setAge(20);
        Weapon weapon=new Weapon("要你命三千");
        //为英雄装备武器。
        hero.setWeapon(weapon);
        hero.attack();
    }
}
```

```java
package winter_holiday_training_camp.day10;
public class Hero {
    private String name;
    private int age;
    private Weapon weapon;
    public Hero() {
    }
    public Hero(String name, int age, Weapon weapon) {
        this.name = name;
        this.age = age;
        this.weapon = weapon;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Weapon getWeapon() {
        return weapon;
    }
    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;
    }
    public void attack(){
        System.out.println("年龄为"+age+"岁的"+name+"用"+weapon.getCode()+"攻击敌方。");
        //这里的weapon是一个对象，和其他成员变量的用法不同
    }
}
```

```java
package winter_holiday_training_camp.day10;
public class Weapon {
    private String code;
    public Weapon(String code) {
        this.code = code;
    }
    public Weapon() {
    }
    public String getCode() {
        return code;
    }
    public void setCode(String code) {
        this.code = code;
    }
}
```

------

## 2.16 接口作为方法的参数或返回值

java.util.List正是ArrayList所实现的接口。

`List<String> list = new ArrayList<>();`

左边是接口名称，右边是实现类名称，这就是多态写法。

```java
public class Demo03_Main {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        List<String> result=add(list);
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    public static List<String> add(List<String> list){
        list.add("jim");
        list.add("gogo");
        list.add("peggy");
        list.add("marry");
        return list;
    }
}
```

------

# 3 Object类

## 3.1 概述

java.lang.object类

类 object 是类层次结构的根(最顶层)类。每个类都使用 object 作为超(父)类。

所有对象（包括数组）都实现这个类的方法。

每个类默认继承了object类,所以可以使用object类中的tostring方法。

String tostring() 返回该对象的字符串表示。

对象名.tostring();返回值是该对象名的地址值

直换打印对象的名字,其实就是调用对象的tostring方法。

如果不想打印出对象的地址值，那就要在某一个对象所对应的类里面重写Object类的toString方法。

看一个类是否重写了tostring方法，直接打印这个类对应对象的名宇即可如果没有重写tostring方法,那么打印的就是对象的地址值(默认)如果重写tostring方法，那么就按照重写的方式打印。

```java
public class Demo01_Object {
    public static void main(String[] args) {
        Person p=new Person("洪永峰",20);
        System.out.println(p);
        String str=p.toString();
        System.out.println(str);
        Random random=new Random();
        System.out.println(random);//没有重写toString方法
        ArrayList<String> string=new ArrayList<>();
        System.out.println(string);//重写了toString方法
        Scanner scanner=new Scanner(System.in);
        System.out.println(scanner);//重写了toString方法
    }
}
```

------

## 3.2 Object类的equals方法

Person类默认继承了object类,所以可以使用object类的equals方法

boolean equals(object obj) 指示其他某个对象是否与此对象”相等”。

object类equals方法的源码:

```java
public boolean equals(Object obj) {
    return (this ==obj);
}
```

参数：

`object obj`:可以传递任意的对象

方法体:

==是比较运算符,返回的就是一个布尔值 true,false

基本数据类型:比较的是值

引用数据类型:比较的是两个对象的地址值

this是谁?那个对象调用的方法,方法中的this就是那个对象；

p1调用的equals方法,所以this就是p1

obj是谁?是传递过来的参数p2

用法

```java
Person p1=new Person();
Person p2=new Person();
System.out.println(p1.equals(p2));
```

------

## 3.3 重写Object类的equals方法

object类的equals方法默认比较的是两个对象的**地址值**，没有意义

所以我们满更重写equals方法，比较两个对象的属性值（如name，age）

对象的属性值一样,返回true;否则返回false

问题:

传入参数的时候，隐含着一个多态

`Object obj = p2 = new person("古力娜扎”,18);`

多态的弊端:无法使用子类特有的内容(属性,方法)

解决方法:

可以使用向下转型(强转]把Object类型转换为Person。

```java
@Override
    public boolean equals(Object obj){
        //使用向下转型把Object类型转换为Person类型
        Person person=(Person) obj;
        //比较两个对象的属性:一个是调用方法的this(p1),另一个是参数obj，也就是person
        return this.name.equals(person.name) && this.age==person.age;
    }
```

```java
public class Demo02_Object {
    public static void main(String[] args) {
        Person p1=new Person("jim",18);
        Person p2=new Person("jim",18);
        //Person p2=new Person("marry",20);
        System.out.println(p1.equals(p2));
    }
}
```

------

//getClass() != obj.getClass() 使用反射技术，判断变量obj是否为Person类型。getClass就是指当前的类。

等效于`if( obj instanceof Person)`

`if (obj == null ll getClass() ! obj.getclass()) return false;`

------

## 3.4 Objects类的equals方法

```java
String s1 = null;
String s2 = "abc";
//boolean b= sl.equals(s2);//NullPointerException 
//因为null是不能调用方法的,会抛出空指针异常

//Objects类的equals方法:
//对两个对象进行比较,防止空指针异常
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null &&a.equals(b));
}
boolean b2 = Objects.equals(s1,s2);
System.out.println(b2);
```

在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些**静态**的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant(容忍空指针的)，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。

在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个间题。

方法如下:

public static boolean equals(Object a，Object b) ;

判断两个对象是否相等

------

## 3.5 总结

对于变量来说，直接打印输出某个**变量名**和打印某个**变量名.toString()**其实是一样的。

但对于对象来说，打印的是地址值。

可以通过重写toString方法来打印对象的属性值。

String类里面的equals方法也是经过覆盖重写了Object类中的equals方法。

------

# 4 Date类

## 4.1 毫秒值的概念和作用

java.util.Date:表示日期和时间的类

注意：这是util包，不是sql包。

类 Date 表示特定的瞬间，精确到毫秒。

毫秒:千分之一秒 1000毫秒=1秒

特定的瞬间:一个时间点，一刹那时间

例如：2088-08-08 09:55:33:333 的瞬间

**毫秒值的作用**:可以对时间和日期进行计算

2099-01-03到 2088-01-01 中间一共有多少天

可以将日期转换为毫秒进行计算，计算完毕,在把毫秒转换为日期

把日期转换为毫秒:

- 当前的日期:2088-01-01
- **时间原点**(0毫秒):1970 年 1 月 1日 00:00:00(英国格林威治时间)
- 就是计算**当前**日期到时间原点之间一共经历了多少毫秒 

注意:中国属于东八区，会把时间增加8个小时

- 1970 年 1 月 1日 08:00:00

把毫秒转换为日期:

1天 == 24 x 60 x 60 = 86400秒 = 86400 X 1000= 86400000毫秒

System,out,println(System.currentTimeMillis())://获取当前系统时间到1970 年 1 月1 日 00:00:00经历了多少毫秒

使用这个语句要进行导包：

```java
import static java.lang.System.currentTimeMillis;
```

------

## 4.2 Date类的构造方法和成员方法

```java
public class Demo01 {
    public static void main(String[] args) {
        //Date类的空参数构造方法;
        //Date()获取的就是当前系统的日期和时间
        Date date=new Date();
        System.out.println(date);
        
        //Date类的而参数构造方法:
        //Date(Long date) :传递毫秒值,把毫秒转换为Date日期
        Date date1=new Date(2341654132166544655L);
        System.out.println(date1);
        //输出的日期则是以时间原点为基准，在此基础上加上参数毫秒值，最终得到加上毫秒值的日期。
        //注意：这个参数是long类型，传入时要加上L。
        //-----------------------------
        //Date类的成员方法
        //Long getTime() 
        //把日期转换为毫秒
        //(相当于System.currentTimeMillis())
        //返回压自 1970 年 1 月 1日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
        //注意：CST代表China Standard Time
        Date date = new Date();
        long time =date.getTime();
        System.out.println(time);
    }
}
```

------

## 4.3 DateFormat类和SimpleDateFormat类介绍

java.text.DateFormat:是Format的直接子类。是日期/时间格式化子类的抽象类。

作用:

格式化（也就是日期 ->文本）、解析（文本->日期)

成员方法:

`String format(Date date)` 

按照指定的模式,把Date日期,格式化为符合模式的字符串

`Date parse(string source)`

把符合模式的字符串,解析为Date日期

DateFormat类是一个**抽象类**，无法直接创建对象使用,但可以使用Dateformat的子类SimpleDateformat。

`java.text.SimpleDateformat extends Dateformat`

构造方法:

`SimpleDateFormat(String pattern)` 

用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。

参数:

String pattern:传递指定的模式

模式:区分大小写的

| y    | 年   |
| ---- | ---- |
| M    | 月   |
| d    | 日   |
| H    | 时   |
| m    | 分   |
| s    | 秒   |

写对应的模式，会把模式替换为对应的日期和时间

“yyyy-MM-dd  HH:mm:ss"

“yyyy年MM月dd日 HH时mm分ss秒”

注意:模式中的字母不能更改,连接模式的符号可以改变

------

## 4.4 DateFormat类的format方法和parse方法

使用DateFormat类中的方法format,把日期格式化为文本

String format(Date date) 

按照指定的模式,把Date日期,格式化为符合模式的字符串

使用步骤:

- 创建SimpleDateFormat对象,构造方法中传递指定的模式
- 调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本)

```java
public static void method01(){
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
    Date date=new Date();
    System.out.println(date);
    String text= sdf.format(date);
    System.out.println(text);
}
```



使用DateFormat类中的方法parse,把文本解析为日期

Date parse(string source) 把符合模式的字符串,解折为Date日期

使用步骤:

- 1.创建SimpleDateFormat对象,构造方法中传递指定的模式
- 2.调用SimpleDateforrat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期。

注意：

public Date parse(String source) throws ParseException

parse方法声明了一个异常叫ParseExcaption解折异常

如果字符串和构造方法中的模式不一样，那么程序就会抛出此异常。

调用一个抛出了异常的方法,就必须处理这个异常,要么throws继续声明抛出这一个异常,要么try...catch自己处理这个异常

```java
public class Demo01 {
    public static void main(String[] args) throws ParseException{
        Date date=new Date();
        System.out.println(date);
        method02();
    }
//上下两个方法都要用throws ParseException
    public static void method02() throws ParseException {
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
        Date date=sdf.parse("2023年01月19日  12时08分55秒");
        System.out.println(date);
    }
}
```

------

## 4.5 Calendar类

Calendar类是一个抽象类。

直接输出Calendar类的对象名，发现不是地址值，这说明Calendar类重写了toString方法。



java.util.Calendar类:日历类

Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY OF_MONTH、HOUR )

Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的**子类**(GregorianCalendar)的对象。

static Calendar getInstance() 使用默认时区和语言环境获得一个日历。

```java
public static void main(String[] args) throws ParseException{
    Calendar c=Calendar.getInstance();//多态
    System.out.println(c);
}
```

------

## 4.6 Calendar类的常用成员方法

Calendar类的成员方法:

- public int get(int field): 返回给定日历字段的值。

  - 参数：传递指定的日历字段（YEAR,MONTH....）

  - 返回值：日历字段代表具体的值

  - ```java
    public class Demo03 {
        public static void main(String[] args) {
            //使用getInstance方法获取CaLendar对象
    
            Calendar c = Calendar.getInstance();
            int year=c.get(Calendar.YEAR);
            System.out.println(year);
            int month= c.get(Calendar.MONTH);
            System.out.println(month+1);//西方的月份0-11 东方:1-12
            //int date = c.get(Calendar.DATE);
            //上下两种写法是一样的。
            int date = c.get(Calendar.DAY_OF_MONTH);
            System.out.println(date);
        }
    }
    ```

- public void set(int field，int value): 将给定的日历字段设置为给定值。

  - ```java
    private static void method03() {
        //使用getInstance方法获取CaLendar对象
        Calendar c=Calendar.getInstance();
    //设置年为9999
        c.set(Calendar.YEAR,9999);
    // 设置月为9
        c.set(Calendar.MONTH,9);
        //设置日9
        c.set(Calendar.DATE,9);
    //同时设置年月日，可以使用set的重软方法
        c.set(8888, 8,8);
        int year= c.get(Calendar.YEAR);
        System.out.println(year);
        int month= c.get(Calendar.MONTH);
        System.out.println(month);//西方的月份0-11 东方:1-12
        //int date = c.get(Calendar.DATE);
        int date = c.get(Calendar.DAY_OF_MONTH);
        System.out.println(date);
    }
    ```

  - public int get(int field): 返回给定日历字段的值。

    参数:传递指定的日历宇段(YEAR，MOWTH...)

    返回值:日历字段代表具体的值

- public abstract void add(int field, nt amount):根据据日历的规则，为给定的日历字添加或减去指定的时间量。

- public Date getTime(): 返回一个表示此calendar时间值(从历元到现在的毫秒偏移量)的Date对象。

成员方法的参数:

- int field;日历类的字段,可以使用calendar类的静态成员变量获取。
- public static final int YEAR=1;年
- public static final int MONTH= 2;月
- public static final int DATE =5;月中的某一天
- public static final int DAY_OF_MONTH =5;月中的某一天
- public static final int HOUR = 10;时
- public static final int  MINUTE = 12;分
- public static final int SECOND= 13;秒

------

# 网协小任务

Main.java

```java
package winter_holiday_training_camp.day09.WangXie;

import winter_holiday_training_camp.day09.网课视频.Teacher;

public class Main {
    public static void main(String[] args) {
/*
* -一个‘人’类，人类有姓名，身高，体重等成员变量，还有成员方法——吃饭
* ’学生‘类，学生类里面有姓名，学号，学院，专业等成员变量，还需要有成员方法——学习，学生类需要继承自人类，并重写吃饭方法
* 一个主方法，里面使用多态方式创建一个学生对象，然后使用这个对象调用方法
* 可以自行增加学习到的知识，比如使用增强for循环打印
* 所有源代码一并提交在笔记中
*
*
* */
        Person per=new Student();
        per.eat();
        Student stu=(Student) per;
        ((Student) per).sleep();
        stu.sleep();
        //Teacher teacher=(Teacher) stu;//错误写法

        if (per instanceof Student){
            Student stu1=(Student) per;
            stu1.eat();
        }
        if (per instanceof Teacher){
            Teacher tea=(Teacher) per;
            tea.eat();
        }
    }
}
```



Person.java

```java
package winter_holiday_training_camp.day09.WangXie;

public abstract class Person {
    private int height;
    private int weight;
    private String name;
    public void eat(){
        System.out.println("人吃饭");
    }
}
```



Student.java

```java
package winter_holiday_training_camp.day09.WangXie;

public class Student extends Person{
    private String name;
    private int number;
    private String school;
    private String major;
    public static void study(){
    }
    @Override
    public void eat(){
        super.eat();
        System.out.println("学生吃饭");
    }
    public void sleep(){
    }
}
```

