# 第一章 开发前言

## 1.2 计算机基础知识

### 二进制

十六进制HEX,十进制DEC，八进制OCT，二进制BIN

#### 十进制转二进制的方法：除法取余，然后倒序。

即先用十进制数作为被除数，2作为除数，用十进制数除以2，取其余数，而其商则继续作为被除数。商写在被除数的下方，余数写在商的右侧。用该商除以2，再取其余数，如此循环进行，直到商为0，最后将所有余数按从后到前的顺序输出，即最下面的余数放到最左端，最上面的余数放到最右端。最左端为最高位，最右端为最低位。

拓展：十进制数转任何小于十进制的数都可以用这种除法来算，只需要把除数换成对应的进制就可以了，其他的东西均不用改动。如十进制转8进制则把十进制数除以8即可。

---

#### 位权相加法

“8421”技巧

1100(2)==8+4=12(10)

二进制转十进制：拿二进制来举例，二进制最低位（最右端）（**假设**为第一位，其左侧为第二位）的数n等于十进制数的n$${*2^0}$$，第二位二进制数n等于十进制数n$${*2^1}$$，以此类推，第三位则为n$${*2^2}$$… 第k位则为$ n{*2}^{k-1} $.

拓展：

m进制转十进制：第一位n$${*m^0}$$，第二位m进制数n等于十进制数n$${*m^1}$$，以此类推，第三位则为n$${*m^2}$$… 第k位则为$ n{*m}^{k-1} $.

---

### 字节

位（bit）：一个数字0或者一个数字1,代表一位。
字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。

任何一个文件的空间都不会是0.5个字节

1 Byte = 8 bit

1 KB = 1024 Byte
1 MB = 1024 KB
1 GB = 1024 MB
1 TB = 1024 GB
1 PB = 1024 TB
1 EB = 1024 PB
1 ZB = 1024 EB

---

## 1.5 命令提示符

### 常用命令

MS-DOS(Microsoft Disk Operating System)

命令提示符（cmd）

启动：Win+R，输入cmd回车

#### 切换盘符

盘符名称:

* 注意：盘符不区分大小写

  例如：c:

  或：D:

#### 进入文件夹

cd 文件夹名称

* 如果想进入该盘符（文件夹）下的某一个文件夹，且该目录下这个文件夹的名字是与其他文件夹的首字符不一样，我们就可以用一个快捷的方法：若这个文件夹名为apk，则输入命令：cd a

  然后按一下Tab键，然后cmd就会自动帮你补全该文件夹的名字。如果首字符一样，也可以按Tab键，但是需要继续按多几次Tab键进行文件夹的选择，按一次Tab键，就代表着下一个文件夹，直到选到你想进去的那个文件夹。

#### 进入多级文件夹

cd 文件夹1\文件夹2\文件夹3

#### 返回上一级

cd ..

* 注意：到达盘符的根目录下再用cd ..也没用，不会再返回上一层目录了。

#### 直接回根路径

cd \

#### 查看当前文件夹里的内容

dir

内容里面：一个.代表当前路径，两个.代表上一级路径

#### 清屏

cls

#### 退出

exit

#### 选择之前输入过的命令

在光标闪烁的位置使用键盘上下键选择之前输入过的命令。非常方便。

#### 注意

java.exe的.exe可以不写进命令里面。其他文件也是如此。

---

# 第二章 Java语言开发环境搭建

## 2.1Java虚拟机--JVM

* **JVM** (lava Virtual Machine ) : Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上.
* **跨平台**: 任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行JVM上，而JVM运行在操作系统上。
* Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机.

---

## 2.2 JRE和JDK

JDK（开发）

* JRE（运行）
  * JVM(核心)
  * 运行类库
* 编译器等开发工具

---

## 2.4 环境配置

%SystemRoot%

SystemRoot代表了地址：系统盘符:\Windows

如果我们想让JAVA_HOME这个系统变量来代替某个地址，则可以在变量名两端加上%%，即%JAVA_HOME%.

假如现在JAVA_HOME的值为D:\Program Files\Java\jdk-19

则%JAVA_HOME%\bin实际上则是D:\Program Files\Java\jdk-19\bin

---

# 第三章 HelloWorld 入门程序

javac.exe为编译器

java.exe为解释器

javac命令要加后缀名

如javac HelloWorld.java

java命令不用加后缀名

如java HelloWorld

实际上运行的是HelloWorld.class

---

## HelloWorld代码

```java
public class HelloWorld{
	public static void main(String[] args){
		System.out.println("Hello,World!!!");
	}
}
```

代码中的第三个单词HelloWorld其实是类名称

生成.class 文件之后再修改源代码，如果不执行javac命令去编译，相当于编译之前运行.class，实际上输出的是修改代码之前的结果。

注意：

* public class HelloWorld中的类名称 HelloWorld(第一行的第三个单词)要和源文件的文件名保持一致，大小写也要一样，否则编译会出错。
* public class后面代表定义一个类的名称，类是Java当中所有源代码的基本组织单位。所有的代码都要在这里的{}内编写。
* 第二行的内容`public static void main(String[] args){}`是万年不变的固定写法，代表main方法。这一行代表程序执行的起点。
  * String[] args的第一个S是大写的，写成小写也会编译出错。
* 第三行代表打印输出语句 (其实就是屏幕显示)，希望显示什么东西，就在小括号当中填写什么内容。
  * System.out.println的S是大写的，写成小写也会编译出错。
* System.out.println();语句可以是空语句，实际上是进行2次换行。

---

## 关键字

关键字的特点：

* 完全小写的纯英文字母
* 有数字或符号等
* 在一些编辑器中该词语有特殊的颜色

注意：String字符串类型并不是关键字

---

## 标识符

自己起的名称都是标识符，比如类的名字、方法的名字和变量的名字等

* 命名规则： （硬性要求）

  * 标识符可以包含英文字母26个(区分大小写) 、0-9数字 、$（美元符号） 和_（下划线） 。

    注意：之前学C语言的时候一直以为$是不能作为标识符的，实际上是可以的。

  * 标识符不能以数字开头。

  * 标识符不能是关键字。

* 命名规范：（软性建议）

  * 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。
  * 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。
  * 变量名规范：全部小写。

# 第四章 常量

Java中：'你' 也是一个字符。

## 布尔常量

只有两种取值：true和false

## 空常量

null（小写），代表没有任何数据。也不能使用他。

---

## Java 常量

常量在程序运行时是不能被修改的。

在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：

```
final double PI = 3.1415927;
```

虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。

和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：

```
"Hello World"
"two\nlines"
"\"This is in quotes\""
```

字符串常量和字符变量都可以包含任何 Unicode 字符。例如：

```
char a = '\u0001';
String a = "\u0001";
```

---

## 用法

```java
System.out.println(12);//输出数字12
System.out.println("");//字符串两个双引号中间的内容为空，相当于换行符。
System.out.println("abd");//输出字符串abd
```

即使System.out.println（）括号内没有任何东西，他也能成功运行，相当于一个换行符。

每一条输出语句自带换行功能。

System.out.println('ab');错误

System.out.println('');两个单引号中间必须有且仅有一个字符，没有的话会编译错误

布尔常量的输出：

System.out.println(true);输出true

System.out.println(false);输出false

空常量不能直接用打印来输出，如System.out.println(null);，编译会出错

---

# 第五章 数据类型

## 基本数据类型

变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。

内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。

因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。

Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 -128（-2^7）；
- 最大值是 127（2^7-1）；
- 默认值是 0；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 -32768（-2^15）；
- 最大值是 32767（2^15 - 1）；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 0；
- 例子：short s = 1000，short r = -20000。

**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 -2,147,483,648（-2^31）；
- 最大值是 2,147,483,647（2^31 - 1）；
- 一般地整型变量默认为 int 类型；
- 默认值是 0 ；
- 例子：int a = 100000, int b = -200000。

**long：**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 -9,223,372,036,854,775,808（-2^63）；
- 最大值是 9,223,372,036,854,775,807（2^63 -1）；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 0L；
- 例子： long a = 100000L，long b = -200000L。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 0.0f；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

**double：**

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；

- 浮点数的默认类型为 double 类型；

- double类型同样不能表示精确的值，如货币；

- 默认值是 0.0d；

- 例子：

  ```java
  double   d1  = 7D ;
  double   d2  = 7.; 
  double   d3  =  8.0; 
  double   d4  =  8.D; 
  double   d5  =  12.9867; 
  ```

  7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。

**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 false；
- 例子：boolean one = true。

**char：**

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 \u0000（十进制等效值为 0）；
- 最大值是 \uffff（即为 65535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';。

**注意**：float和double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103 =3140，3.14E-3 就是 3.14 x 10-3 =0.00314。

实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。



 **Java 各个数据类型：**，**其内存占用和取值范围和C语言有很大不同**

| **数据类型** | 关键字  | 内存占用 | 取值范围               | **默认值**         |
| ------------ | ------- | -------- | ---------------------- | ------------------ |
| 字节型       | byte    | 1个字节  | -128~127               | 0                  |
| 短整型       | short   | 2个字节  | -32768~32767           | 0                  |
| 整型         | int     | 4个字节  | -2的31次方~2的31次方-1 | 0                  |
| 长整型       | long    | 8个字节  | -2的63次方~2的63次方-1 | 0L                 |
| 单精度浮点数 | float   | 4个字节  | 1.4013E-45~3.4028E+38  | 0.0f               |
| 双精度浮点数 | double  | 8个字节  | 4.9E-324~1.7977E+308   | 0.0d               |
| 字符型       | char    | 2个字节  | 0-65535                | '\u0000'(一个空格) |
| 布尔类型     | boolean | 1个字节  | true,false             | false              |

## **引用数据类型**

默认值为NULL

字符串、数组、类、接口、Lambda

```java
String str;//注意S一定是大写的
str="hello";
System.out.println(str);//可以正常输出字符串
```



**引用类型**

- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。

---

## 注意事项：

1. 字符串不是基本类型，而是引用类型。

2. 浮点型可能只是一个近似值，并非精确的值。

3. 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。

4. 浮点数当中默认类型是double。如果一定要使用float类型，需要在数字后面加上一个后缀F。
   如果是整数，默认为int类型，如果一定要使用long类型，需要在数字后面加上一个后缀L。推荐使用大写字母后缀。

5. 输出变量值时可以直接写System.out,println(变量名);

   不像C语言那样还要格式化输出。

6. long 类型赋值时如果超出整型的范围的话，要在数字后面加上L或l；如果没超出，等号右边默认为整型，则隐含了自动类型的转换。

7. 不能重定义变量。

8. 变量没有赋值的话不能直接对其输出，输出的话会报错。而C语言可以输出没有赋值的变量，他的值是一个随机数。

9. 作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止。执行完该大括号后，该变量自动消失。在定义该变量前面的所有位置，以及所属的大括号后的所有位置，该变量都无效。

10. 字面量可以赋给任何内置类型的变量。例如：

    ```
    byte a = 68;
    char a = 'A'
    ```

    byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。

    当使用字面量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：

    ```
    int decimal = 100;
    int octal = 0144;
    int hexa =  0x64;
    ```

    

------

Java语言支持一些特殊的转义字符序列。

| 符号   | 字符含义                 |
| ------ | ------------------------ |
| \n     | 换行 (0x0a)              |
| \r     | 回车 (0x0d)              |
| \f     | 换页符(0x0c)             |
| \b     | 退格 (0x08)              |
| \0     | 空字符 (0x0)             |
| \s     | 空格 (0x20)              |
| \t     | 制表符                   |
| \"     | 双引号                   |
| \'     | 单引号                   |
| \\     | 反斜杠                   |
| \ddd   | 八进制字符 (ddd)         |
| \uxxxx | 16进制Unicode字符 (xxxx) |

------

# 第六章 数据类型的转换

## 自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```
低  -------------（取值范围）---------------->  高

byte,short,char—> int —> long—> float —> double 
```

1.特点:代码不需要进行特殊处理，自动完成。
2.规则:数据范围从小(等号右侧)到大(等号左侧)。

数据类型转换必须满足如下规则：

- 不能对boolean类型进行类型转换。

- 不能把对象类型转换成不相关类的对象。

- 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

- 转换过程中可能导致溢出或损失精度，例如：

  ```
  int i =128;   
  byte b = (byte)i;
  ```

  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

  ```
  (int)23.7 == 23;        
  (int)-45.89f == -45
  ```



必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。

注意

* 若将取值范围大的数据类型赋值给取值范围小的数据类型，则会报错。从大到小不能发生自动类型转换。
* byte/short/char这三种类型都可以发生数学运算，例如加法“+”
* byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算
  * byte+byte相当于int+int，其结果也就是int，所以要用int来接收这个结果，否则会报错。
* boolean类型不能发生数据类型转换
* 范围大的类型强制转换为范围小的类型; 注意必须保证范围大的类型逻辑上的真实大小本来就没有超过范围小的类型的范围。

---

## 强制类型转换

1.特点:代码需要进行特殊的格式处理，不能自动完成。
2.格式: 范围小的类型 范困小的变量名= (范围小的类型) 原本范围大的数据。

- 条件是转换的数据类型必须是兼容的。
- 格式：(type)value type是要强制类型转换后的数据类型 
  - 实例：int num=(int) 100L;

注意：如果原本范围大的数据的值大于范围小的类型的取值范围，进行强制类型转换之后，则会发生数据溢出或精度损失。

如浮点数转整型，其小数位会全部舍弃，并不是四舍五入；数值大于整型的长整型数转整型数，会发生溢出，数据则不准确，很可能与真实值有较大的差别。

## 隐含强制类型转换

注意：`byte=30;`和`char a=65;`并不是自动类型转换，而是隐含强制类型转换。

- 整数的默认类型是 int。
- 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。

---

## ASCII码和Unicode码

Unicode码表里面甚至还包含有emoji的表情包

unicode码表:万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符，包含中文

‘中’=20013

注意：Java中可以将汉字赋值给char类型

---

# 第七章 运算

## 基本运算

只有对于整数的除法来说，取模运算符才有余数的意义。

注意事项
一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种

如`double result=10+2.5;`

则result=12.5，输出的也是12.5，Java不像C语言那样，后面还会补上几个0

对于字符串String(首字母大写，并不是关键字)来说，加号代表字符串连接操作
任何数据类型和字符串进行相加（连接）的时候，结果都会变成字符串

```java
String str="java";
System.out.println(str+20);//结果为java20
System.out.println(str+20+30);//结果为java2030
```

优先级：+运算符的结合方式是自左向右

### 自增自减

30++;是错误写法，因为常量不可以使用++和--

## 赋值运算

1.只有变量才能使用赋值运算符，常量不能进行赋值。
2.复合赋值运算符其中隐含了一个强制类型转换。

```java
byte num=30;
//实际上是：
/*num=num+5;
num=byte+int;
num=int+int;
num=int;
num=(byte)int;//隐含了强制类型的转换
num+=5;
System.out/println(num);//输出的就是35
*/
```

## 比较运算

大于小于等于不等于运算返回的是true和false，与C 语言不一样。C 返回的是1或0

1.比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false

2.如果进行多次判断，不能连着写。数学当中的写法，

例如: `1< x<3` 程序当中不允许这种写法，会报错。

## 逻辑运算

```java
System.out.println(true&&false);//结果是false
```

与“&&”，或“||”，具有短路效果:如果根据等号左边已经可以判断得到最终结果，那么等号右边的代码将不再执行，从而节省一定的性能。

注意事项:

逻辑运算符只能用于boolean值。与C语言不同，C的逻辑运算符左右两侧可以是一个常量或者不是boolean的变量。

与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可。

与、或两种运算符，如果有多个条件，可以连续写。

### 注意：

逻辑运算的结果是boolean

---

## 三元运算

格式:
数据类型 变量名称 条件判断 ? 表达式A : 表达式B;

注意事项:
1.必须同时保证表达式A和表达式B都符合左侧数据类型的要求

2.三元运算符的结果必须被使用。

```java
int result=3>4?2.5:10;//错误写法，2.5是double类型。
//而不是int类型
/*即使3>4是执行后面的表达式，但是在编译的时候，编译器是不知道3是否大于4，也不知道执行哪个表达式，所以编译会报错*/
a>b?a:b;//错误写法
System.out.println(a>b?a:b);//正确写法
```

## 编译器的两种优化

### 隐含的强制类型转换

对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过左侧的范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)强制转换。
如`byte num=30;`//int --> byte,不是自动类型转换

如果右侧超过了左侧范围，那么直接编译器报错。

```java
short s=1;
s+=1;//包括2个步骤
//1.s+1;2.强制类型转换
//相当于是s=(short)(s+1);
//如果是s=s+1;那么他的计算结果被提升为int 类型，再向short类型赋值时会报错。
```



### 编译器的常量优化

在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量,那么编译器javac将会直接将若干个常量表达式计算得到结果。

`short result  5 + 8;` // 等号右边全都是常量，没有任何变量参与运算编译之后，得到的.class字节码文件当中相当于直接就是:

`short result  =13;`//右侧的常量结果数值，没有超过左侧范围，所以正确。

这称为“编译器的常量优化”

但是注意:一旦表达式当中有变量参与，那么就不能进行这种优化了。| 

```java
short a=5;
short b=5;
short result=a+b;//错误写法，因为左侧需要是int类型//相当于short + short-->int + int -->int
short result=5+8;//正确写法
short result2=5+a+8;//不参与常量优化，因为有一个变量；
```

---

# 第八章 方法

java的方法类似于C 语言的函数

定义一个方法的基本格式:

```java
public static void 方法名称() {方法体}
```


方法名称的命名规则和变量一样，使用小驼峰(第一个单词首字母小写，其后单词首字母大写)

方法体:也就是大括号当中可以包含任意条语句。

方法的定义要在main方法之外，类名称之内进行。

如果在类名称之外定义，则会报错。如：需要 class、interface、enum 或 record。

在main方法之内定义，也会报错。

注意事项:

* 方法定义的先后顺序无所谓。
* 方法的定义不能产生嵌套包含关系。不能在一个方法的内部定义另一个方法。
* 方法定义好了之后，是不会执行的。如果要想执行，一定要进行方法的**调用**。

与C语言不一样，C的函数能嵌套定义且调用，但java的方法不能嵌套定义，如果嵌套定义则会报错。

---

# 第九章 IDEA的使用

所有源文件（代码）都要放在src文件夹目录下。

project包含module，module包含package，

新建模块module可以在左上角-文件-项目结构-模块里面进行。

新建软件包package可以在src文件夹处右键-新建-软件包，注意，软件包名称只能用英文和数字进行命名，用.间隔开相邻两个文件夹的名字。

`.`的左右两侧分别是两个文件夹

`cn.itcast`是一个约定俗成的写法，该公司的域名为itcast.cn则其包名就以`cn.itcast`开头来命名。

例如：包名为`cn.itcast.day04.demo01`

则在src文件夹下有一个cn的文件夹，cn文件夹下有一个itcast的文件夹，里面还有一个day04的文件夹，最里面还有个demo01的文件夹。

注意：.class文件存放在out文件夹下。

## 快捷的输入方法：

psvm等于`public class HelloWorld{}`

sout等于`System.out.println();`

5.fori等于

```java
for(int i=0;i<5;i++){}
```

array.fori等于（其中array是一个已知数组长度是数组）

```java
for(int i=0;i<array.length;i++){}
//array.length就等于数组元素的个数。
```

用shift+F6则将选中的名称修改，则与该名称相同的所有名称都会同时被修改

```java
int num;
System.out.println(num);
//我现在选中int 后面的那个num，然后按shift+F6，输入abc，//然后这两个num都会被同时改成abc
```



## 快捷键

| 快捷键             | 功能                                   |
| ------------------ | -------------------------------------- |
| alt+4(横排数字4)   | 打开/关闭运行界面框                    |
| alt+/              | 代码补全（自己改的，不是默认的）       |
| ctrl+shift+减号(-) | 全部折叠                               |
| ctrl+shift+加号(+) | 全部打开                               |
| Alt+Enter          | 导入包，自动修正代码                   |
| Ctrl+Y             | 删除光标所在行                         |
| Ctrl+D             | 复制光标所在行的内容，插入光标位置下面 |
| Ctrl+Alt+L         | 格式化代码(代码对齐)                   |
| Ctrl+/             | 单行注释                               |
| Ctrl+Shift+/       | 选中代码注释，多行注释，再按取消注释   |
| Alt+Insert         | 自动生成代码，toString，get，set等方法 |
| Alt+Shift+上下箭头 | 移动当前代码行                         |

---

# 第十章 语法

## 不换行输出的方法

`System.out.print();`

实际上`println`的`ln`是line的意思，他自带一个换行符\n(C语言中的)，把`ln`去掉就不会换行了。

## 定义方法的完整格式

```java
//修饰符 返回值类型 方法名称(参数类型 参数名称，...){
//		方法体
//		return 返回值;
//}
public static int sum(int a,int b){
    int result=a+b;
    return result;
}
```

修饰符，现阶段的固定写法:`public static`

返回值类型，也就是方法最终产生的数据结果是什么类型

方法名称:方法的名字，规则和变量一样，小驼峰

参数类型:进入方法的数据是什么类型

参数名称:进入方法的数据对应的变量名称

PS:参数如果有多个，使用逗号进行分隔

方法体，方法需要做的事情，若干行代码

return;两个作用，第一停止当前方法，第二将后面的返回值还给调用处

返回值，也就是方法执行后最终产生的数据结果

注意:return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应.

对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。即`return;`,作用是结束方法的执行。

注意：两个return不能连起来写。如：return;return;是错误的

---

## 方法的重载(overload)

对于功能类似的方法来说，因为参数列表不一样，却需要记住那么多不同的方法名称，太麻烦。
方法的重载(overload) ，多个方法的名称一样，但是参数列表不一样。
**好处**，只需要记住唯一一个方法名称，就可以实现类似的多个功能。

根据实参的个数与形参的个数进行方法的匹配，虽然方法的名称一样，但是形参的个数不一样。这样就可以成功匹配，如果实参个数大于所有方法之一的形参个数，则找不到任何方法来匹配，会报错。

### 注意事项

方法重载与下列因素相关!

* 参数类型不同
  * `public static int sum(int a){}`
  * `public static int sum(double a){}`
* 参数个数不同(有参数和没参数都可以正常重载)
  * `public static int sum(int a){}`
  * `public static int sum(int a,int b){}`
* 参数的多类型顺序不同
  * `public static int sum(int a,double b){}`
  * `public static int sum(double a,int b){}`
* 方法名称不同（例如大小写不同，但字母相同）则不能正确重载

方法重载与下列因素无关：

* 与参数的名称无关
  * `public static int sum(int a){}`
  * `public static int sum(int b){}`
  * 这两个方法是一毛一样的，无法区分
* 与方法的返回值类型无关
  * `public static int sum(int a){}`
  * `public static double sum(int a){}`
  * 这两个方法是一毛一样的，无法区分
* 与修饰符无关
  * 有无public
  * 有无static
  * 都一样

//**在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。**这就是与C语言不同的地方。

---

# 第十一章 数组

## 数组的特点：

* 数组是一种引用数据类型
* 数组当中的多个数据，类型必须统一
* 数组的长度在程序运行期间不可改变

数组的初始化:在内存当中创建一个数组，并且向其中赋予一些默认值。

## 两种常见的初始化方式

### 1.动态初始化(指定长度)

在创建数组的时候，直接指定数组当中的数据元素个数。

动态初始化数组的格式:

数据类型[] 数组名称 = new 数据类型[数组长度];

也可以是

```java
int[] array;

array=new int[3];
```

注意前后的数据类型要保持一致。

#### 解析含义：

左侧数据类型，也就是数组当中保存的数据，全都是统一的什么类型

左侧的中括号，代表我是一个数组

左侧数组名称，给数组取一个名字

右侧的new:代表创建数组的动作

右侧数据类型，必须和左边的数据类型保持一致

右侧中括号的长度:也就是数组当中，到底可以保存多少个数据，是一个int数字

### 2.静态初始化(指定内容)

在创建数组的时候，不直接指定数据个数多少，而是直接将具体

的数据内容进行指定。

静态初始化基本格式

数据类型[] 数组名称 =  new 数据类型[] { 元素1，元素2，...};

```java
int[] array=new int[] {5,15,30};//数组长度为3
String[] arrayB = new String[] {"hello","world","java"};
```

注意事项：

虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。

---

## 详细内容

将一个数组的数组名赋值给另一个另一个数组名

`int[] arrayB=arrayA;`

已知arrayA是一个已经存在的数组，已经分配了动态内存。

上面代码的含义是，将arrayA数组首元素的地址赋值给arrayB，此时数组arrayB就相当于是数组arrayA，不用在另外new，他们两个是同一个数组。

修改数组arrayB的单元实际上就是修改arrayA的单元，这一点与C语言的指针有点像。

---

## 常见问题

### 1. 数组索引越界异常

数组索引编号就相当于C语言的数组下标

数组的索引编号从0开始，一直到“**数组的长度-1**”为止。

如果访问数组元素的时候，索引编号并不存在，那么将会发生数

组索引越界异常**ArrayIndexOutOfBoundsException**

原因：索引编号写错了。

例如：

```java
int[] array=new int[3];

array[3]=1;//错误
//最大应该是array[2]
```

解决方法:修改成为存在的正确索引编号。

---

### 2. 空指针异常

所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有.

数组必须进行new初始化才能使用其中的元素

如果只是赋值了一个null，没有进行new创建

`int[] array=null;`

那么将会发生:

空指针异常 **NulLPointerException**

这个时候数组是没有元素的，因此`array[0]=1;`的写法也是错的

原因:忘了new

解决方法:补上new

---

# 第十二章 Java中的内存划分

Java的内存需要划分成为5个部分:

## 1.栈(Stack) :

存放的都是方法中的**局部变量**。**方法的运行一定要在栈当中运行。**

* **局部变量**: 方法的参数，或者是方法{}内部的变量
* **作用域**:一旦超出作用域，立刻从栈内存当中消失。

例如：存储`main(String[] args)｛｝`当中的内容，比如变量。

注意：`int[] array=new int[3];`

这里的int[]好比是一种数据类型，而array就相当于是变量名。

int[] array是存储在栈区，而int[3]是存储在堆中。

注意这里的赋值，是把数组的首单元的地址赋值给array这个变量，直接输出array这个数组名，得到的结果就是数组首个单元的地址。

`array[1]=10;`需要在栈中根据首元素地址来寻找array[1]的地址。

## 2.堆 (Heap) : 

**凡是new出来的东西，都在堆当中**。

* 堆内存里面的东西都有一个地址值: 16进制
* 堆内存里面的数据，都有默认值。规则:
  * 如果是整数：默认为0
  * 如果是浮点数：默认为0.0
  * 如果是宇符：默认为'\u0000'
  * 如果是布尔：默认为false
  * 如果是引用类型：默认为null

对数组中某元素的赋值，实际上是在把该值存储在堆中，

如：`array[1]=10;`

10是保存在堆中的。

## 3.方法区 (Method Area) : 

存储.class相关信息，包含方法的信息。

例如：

`public static void main(String[] args)`

类似于C语言中的函数声明，不储存方法的具体内容。

要想让该方法执行，必须要让main(String[] args)进栈（进入栈区）。

## 4.本地方法栈(Native Method Stack) : 

与操作系统相关

## 5.寄存器 (pc Register) :

 与CPU相关。





---

# 第十三章 面向对象

## 1.1 概念

面向过程:（例如C语言）

当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。

用for循环输出[10,20,30,40,50]这些数字，包括[]。

方法是用for循环，第一个元素之前输出一个[，到最后一个元素时将,改成]。

面向对象:(例如Java)

当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿.

```java
int[] array={10,20,30,40,50};
System.out.println(Arrays.toString(array));
```

使用面向对象，找一个JDK给我们提供好的Arrays类，其中有一个

toString方法，直接就能把数组变成想要的格式的字符串。

当输入Arrays.toString时按回车，IDEA会自动补全代码，并将

`import java.util.Arrays;`自动写在类名称之前。

### 面向对象的特点

面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。

面向对象的语言中，包含了三大基本特征，即封装、继承和多态

---

## 1.2 类和对象

### 什么是类

**类**:是一组相关**属性**和**行为**的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。

现实中，描述一类事物：

* 属性:就是该事物的状态信息。
* 行为: 就是该事物能够做什么。

举例：小猫。

属性：名字、体重、年龄、颜色。 

行为：走、跑、叫。

### 什么是对象

**对象**:是一类事物的具体体现。对象是类的一个**实例**(对象并不是找个女朋友)，必然具备该类事物的**属性**和**行为**。

现实中，一类事物的一个实例: 一只小猫。

举例: 一只小猫

属性: tom、5kg、2 years、yellow。 

行为: 溜墙根走、蹦哒的跑、喵喵叫。

### 类与对象的关系

* 类是对一类事物的**描述**，是**抽象的**。
* 对象是一类事物的**实例**，是**具体的**。
* **类是对象的模板，对象是类的实体**。

---

## 1.3 类的定义

#### **事物与类的对比**

现实世界的一类事物:

**属性**: 事物的状态信息。 **行为**: 事物能够做什么。

java中用class描述事物也是如此:

**成员变量**:对应事物的**属性** 

**成员方法**: 对应事物的**行为**

---

#### 类的定义格式

```java
public class Student{//没有static
    //成员变量
    String name;//姓名
    int age;//年龄
    //成员方法
    public void eat() {} // 吃饭
    public void sleep() {}//睡觉
    public void study() {} // 学习
}
```



**定义类**:就是定义类的成员，包括**成员变量**和**成员方法**

**成员变量**: 和以前定义变量几乎是一样的。只不过位置发生了改变。成员变量定义在类中，在方法外。

**成员方法**: 和以前定义方法几乎是一样的。只不过**把static去掉**

举例：

定义一个类，用来模拟“学生”事物。

其中就有两个组成部分

* **属性**（是什么）:
  * 姓名
  * 年龄
* **行为**(能做什么)：
  * 吃饭
  * 睡觉
  * 学习

对应到Java的**类**当中:

* **成员变量**(属性):
  * String name; // 姓名
  * int age; //年龄
* **成员方法**(行为)：
  * public void eat() {} // 吃饭
  * public void sleep() {}//睡觉
  * public void study() {} // 学习

**注意：成员变量不是局部变量。**

----

## 1.4 对象的创建及其使用

通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用

步骤如下：

* 1. 导包，也就是指出需要使用的类，在什么位置。

     import 包名称.类名称;

     `import cn.itcast.daye6.demo01.Student;`

     **对于和当前类属于同一个包的情况，可以省略导包语句不写。**

* 2. 创建。格式:

     类名称 对象名 = new 类名称();

     `Student stu = new Student():`

* 3. 使用，分为两种情况。

     * 使用成员变量。对象名.成员变量名

     * 使用成员方法。对象名.成员方法名(参数)

       也就是，想用谁，就用对象名点儿谁。

注意事项:

**如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。**

其实这个对象和C语言的结构体很像，成员变量都是一个概念，不同的是成员方法。

使用的格式也差不多，C语言是：结构体变量名.成员变量名，java是对象名.成员变量名。

在定义变量时没有初始化则直接输出该变量会报错。

如果在定义变量时没有初始化，但是new了一个对象，通过该对象来输出那个变量，结果则是默认值，不会报错。

---

